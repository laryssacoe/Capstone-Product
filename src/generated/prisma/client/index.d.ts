
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model CreatorProfile
 * 
 */
export type CreatorProfile = $Result.DefaultSelection<Prisma.$CreatorProfilePayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model Scenario
 * 
 */
export type Scenario = $Result.DefaultSelection<Prisma.$ScenarioPayload>
/**
 * Model JourneyProgress
 * 
 */
export type JourneyProgress = $Result.DefaultSelection<Prisma.$JourneyProgressPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model TwineStory
 * 
 */
export type TwineStory = $Result.DefaultSelection<Prisma.$TwineStoryPayload>
/**
 * Model StoryVersion
 * 
 */
export type StoryVersion = $Result.DefaultSelection<Prisma.$StoryVersionPayload>
/**
 * Model StoryAuditLog
 * 
 */
export type StoryAuditLog = $Result.DefaultSelection<Prisma.$StoryAuditLogPayload>
/**
 * Model StoryReview
 * 
 */
export type StoryReview = $Result.DefaultSelection<Prisma.$StoryReviewPayload>
/**
 * Model StoryPlaySession
 * 
 */
export type StoryPlaySession = $Result.DefaultSelection<Prisma.$StoryPlaySessionPayload>
/**
 * Model StoryNode
 * 
 */
export type StoryNode = $Result.DefaultSelection<Prisma.$StoryNodePayload>
/**
 * Model StoryPath
 * 
 */
export type StoryPath = $Result.DefaultSelection<Prisma.$StoryPathPayload>
/**
 * Model StoryTransition
 * 
 */
export type StoryTransition = $Result.DefaultSelection<Prisma.$StoryTransitionPayload>
/**
 * Model AvatarProfile
 * 
 */
export type AvatarProfile = $Result.DefaultSelection<Prisma.$AvatarProfilePayload>
/**
 * Model StoryInteraction
 * 
 */
export type StoryInteraction = $Result.DefaultSelection<Prisma.$StoryInteractionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  GUEST: 'GUEST',
  CONSUMER: 'CONSUMER',
  CREATOR: 'CREATOR',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const SessionKind: {
  GUEST: 'GUEST',
  AUTHENTICATED: 'AUTHENTICATED'
};

export type SessionKind = (typeof SessionKind)[keyof typeof SessionKind]


export const JourneyStatus: {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  ABANDONED: 'ABANDONED'
};

export type JourneyStatus = (typeof JourneyStatus)[keyof typeof JourneyStatus]


export const StoryStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  ARCHIVED: 'ARCHIVED'
};

export type StoryStatus = (typeof StoryStatus)[keyof typeof StoryStatus]


export const StoryVisibility: {
  PRIVATE: 'PRIVATE',
  UNLISTED: 'UNLISTED',
  PUBLIC: 'PUBLIC'
};

export type StoryVisibility = (typeof StoryVisibility)[keyof typeof StoryVisibility]


export const StoryNodeType: {
  NARRATIVE: 'NARRATIVE',
  DECISION: 'DECISION',
  RESOLUTION: 'RESOLUTION'
};

export type StoryNodeType = (typeof StoryNodeType)[keyof typeof StoryNodeType]


export const CreatorProfileStatus: {
  DRAFT: 'DRAFT',
  REVIEW: 'REVIEW',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type CreatorProfileStatus = (typeof CreatorProfileStatus)[keyof typeof CreatorProfileStatus]


export const StoryInteractionKind: {
  VIEW: 'VIEW',
  SELECT: 'SELECT',
  START: 'START'
};

export type StoryInteractionKind = (typeof StoryInteractionKind)[keyof typeof StoryInteractionKind]


export const StoryOwnershipStatus: {
  CREATOR_DRAFT: 'CREATOR_DRAFT',
  PENDING_TRANSFER: 'PENDING_TRANSFER',
  PLATFORM_OWNED: 'PLATFORM_OWNED',
  RETURNED: 'RETURNED'
};

export type StoryOwnershipStatus = (typeof StoryOwnershipStatus)[keyof typeof StoryOwnershipStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type SessionKind = $Enums.SessionKind

export const SessionKind: typeof $Enums.SessionKind

export type JourneyStatus = $Enums.JourneyStatus

export const JourneyStatus: typeof $Enums.JourneyStatus

export type StoryStatus = $Enums.StoryStatus

export const StoryStatus: typeof $Enums.StoryStatus

export type StoryVisibility = $Enums.StoryVisibility

export const StoryVisibility: typeof $Enums.StoryVisibility

export type StoryNodeType = $Enums.StoryNodeType

export const StoryNodeType: typeof $Enums.StoryNodeType

export type CreatorProfileStatus = $Enums.CreatorProfileStatus

export const CreatorProfileStatus: typeof $Enums.CreatorProfileStatus

export type StoryInteractionKind = $Enums.StoryInteractionKind

export const StoryInteractionKind: typeof $Enums.StoryInteractionKind

export type StoryOwnershipStatus = $Enums.StoryOwnershipStatus

export const StoryOwnershipStatus: typeof $Enums.StoryOwnershipStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creatorProfile`: Exposes CRUD operations for the **CreatorProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatorProfiles
    * const creatorProfiles = await prisma.creatorProfile.findMany()
    * ```
    */
  get creatorProfile(): Prisma.CreatorProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scenario`: Exposes CRUD operations for the **Scenario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scenarios
    * const scenarios = await prisma.scenario.findMany()
    * ```
    */
  get scenario(): Prisma.ScenarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journeyProgress`: Exposes CRUD operations for the **JourneyProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JourneyProgresses
    * const journeyProgresses = await prisma.journeyProgress.findMany()
    * ```
    */
  get journeyProgress(): Prisma.JourneyProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.twineStory`: Exposes CRUD operations for the **TwineStory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwineStories
    * const twineStories = await prisma.twineStory.findMany()
    * ```
    */
  get twineStory(): Prisma.TwineStoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storyVersion`: Exposes CRUD operations for the **StoryVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryVersions
    * const storyVersions = await prisma.storyVersion.findMany()
    * ```
    */
  get storyVersion(): Prisma.StoryVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storyAuditLog`: Exposes CRUD operations for the **StoryAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryAuditLogs
    * const storyAuditLogs = await prisma.storyAuditLog.findMany()
    * ```
    */
  get storyAuditLog(): Prisma.StoryAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storyReview`: Exposes CRUD operations for the **StoryReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryReviews
    * const storyReviews = await prisma.storyReview.findMany()
    * ```
    */
  get storyReview(): Prisma.StoryReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storyPlaySession`: Exposes CRUD operations for the **StoryPlaySession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryPlaySessions
    * const storyPlaySessions = await prisma.storyPlaySession.findMany()
    * ```
    */
  get storyPlaySession(): Prisma.StoryPlaySessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storyNode`: Exposes CRUD operations for the **StoryNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryNodes
    * const storyNodes = await prisma.storyNode.findMany()
    * ```
    */
  get storyNode(): Prisma.StoryNodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storyPath`: Exposes CRUD operations for the **StoryPath** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryPaths
    * const storyPaths = await prisma.storyPath.findMany()
    * ```
    */
  get storyPath(): Prisma.StoryPathDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storyTransition`: Exposes CRUD operations for the **StoryTransition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryTransitions
    * const storyTransitions = await prisma.storyTransition.findMany()
    * ```
    */
  get storyTransition(): Prisma.StoryTransitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avatarProfile`: Exposes CRUD operations for the **AvatarProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AvatarProfiles
    * const avatarProfiles = await prisma.avatarProfile.findMany()
    * ```
    */
  get avatarProfile(): Prisma.AvatarProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storyInteraction`: Exposes CRUD operations for the **StoryInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryInteractions
    * const storyInteractions = await prisma.storyInteraction.findMany()
    * ```
    */
  get storyInteraction(): Prisma.StoryInteractionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserProfile: 'UserProfile',
    CreatorProfile: 'CreatorProfile',
    UserSession: 'UserSession',
    Scenario: 'Scenario',
    JourneyProgress: 'JourneyProgress',
    Achievement: 'Achievement',
    UserAchievement: 'UserAchievement',
    TwineStory: 'TwineStory',
    StoryVersion: 'StoryVersion',
    StoryAuditLog: 'StoryAuditLog',
    StoryReview: 'StoryReview',
    StoryPlaySession: 'StoryPlaySession',
    StoryNode: 'StoryNode',
    StoryPath: 'StoryPath',
    StoryTransition: 'StoryTransition',
    AvatarProfile: 'AvatarProfile',
    StoryInteraction: 'StoryInteraction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userProfile" | "creatorProfile" | "userSession" | "scenario" | "journeyProgress" | "achievement" | "userAchievement" | "twineStory" | "storyVersion" | "storyAuditLog" | "storyReview" | "storyPlaySession" | "storyNode" | "storyPath" | "storyTransition" | "avatarProfile" | "storyInteraction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      CreatorProfile: {
        payload: Prisma.$CreatorProfilePayload<ExtArgs>
        fields: Prisma.CreatorProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatorProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatorProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorProfilePayload>
          }
          findFirst: {
            args: Prisma.CreatorProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatorProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorProfilePayload>
          }
          findMany: {
            args: Prisma.CreatorProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorProfilePayload>[]
          }
          create: {
            args: Prisma.CreatorProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorProfilePayload>
          }
          createMany: {
            args: Prisma.CreatorProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatorProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorProfilePayload>[]
          }
          delete: {
            args: Prisma.CreatorProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorProfilePayload>
          }
          update: {
            args: Prisma.CreatorProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorProfilePayload>
          }
          deleteMany: {
            args: Prisma.CreatorProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatorProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatorProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorProfilePayload>[]
          }
          upsert: {
            args: Prisma.CreatorProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorProfilePayload>
          }
          aggregate: {
            args: Prisma.CreatorProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreatorProfile>
          }
          groupBy: {
            args: Prisma.CreatorProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatorProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatorProfileCountArgs<ExtArgs>
            result: $Utils.Optional<CreatorProfileCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      Scenario: {
        payload: Prisma.$ScenarioPayload<ExtArgs>
        fields: Prisma.ScenarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScenarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScenarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          findFirst: {
            args: Prisma.ScenarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScenarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          findMany: {
            args: Prisma.ScenarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          create: {
            args: Prisma.ScenarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          createMany: {
            args: Prisma.ScenarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScenarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          delete: {
            args: Prisma.ScenarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          update: {
            args: Prisma.ScenarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          deleteMany: {
            args: Prisma.ScenarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScenarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScenarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          upsert: {
            args: Prisma.ScenarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          aggregate: {
            args: Prisma.ScenarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScenario>
          }
          groupBy: {
            args: Prisma.ScenarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScenarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScenarioCountArgs<ExtArgs>
            result: $Utils.Optional<ScenarioCountAggregateOutputType> | number
          }
        }
      }
      JourneyProgress: {
        payload: Prisma.$JourneyProgressPayload<ExtArgs>
        fields: Prisma.JourneyProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JourneyProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JourneyProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyProgressPayload>
          }
          findFirst: {
            args: Prisma.JourneyProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JourneyProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyProgressPayload>
          }
          findMany: {
            args: Prisma.JourneyProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyProgressPayload>[]
          }
          create: {
            args: Prisma.JourneyProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyProgressPayload>
          }
          createMany: {
            args: Prisma.JourneyProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JourneyProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyProgressPayload>[]
          }
          delete: {
            args: Prisma.JourneyProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyProgressPayload>
          }
          update: {
            args: Prisma.JourneyProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyProgressPayload>
          }
          deleteMany: {
            args: Prisma.JourneyProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JourneyProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JourneyProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyProgressPayload>[]
          }
          upsert: {
            args: Prisma.JourneyProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyProgressPayload>
          }
          aggregate: {
            args: Prisma.JourneyProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJourneyProgress>
          }
          groupBy: {
            args: Prisma.JourneyProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<JourneyProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.JourneyProgressCountArgs<ExtArgs>
            result: $Utils.Optional<JourneyProgressCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      TwineStory: {
        payload: Prisma.$TwineStoryPayload<ExtArgs>
        fields: Prisma.TwineStoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwineStoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwineStoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwineStoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwineStoryPayload>
          }
          findFirst: {
            args: Prisma.TwineStoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwineStoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwineStoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwineStoryPayload>
          }
          findMany: {
            args: Prisma.TwineStoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwineStoryPayload>[]
          }
          create: {
            args: Prisma.TwineStoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwineStoryPayload>
          }
          createMany: {
            args: Prisma.TwineStoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TwineStoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwineStoryPayload>[]
          }
          delete: {
            args: Prisma.TwineStoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwineStoryPayload>
          }
          update: {
            args: Prisma.TwineStoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwineStoryPayload>
          }
          deleteMany: {
            args: Prisma.TwineStoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwineStoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TwineStoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwineStoryPayload>[]
          }
          upsert: {
            args: Prisma.TwineStoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwineStoryPayload>
          }
          aggregate: {
            args: Prisma.TwineStoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwineStory>
          }
          groupBy: {
            args: Prisma.TwineStoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwineStoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwineStoryCountArgs<ExtArgs>
            result: $Utils.Optional<TwineStoryCountAggregateOutputType> | number
          }
        }
      }
      StoryVersion: {
        payload: Prisma.$StoryVersionPayload<ExtArgs>
        fields: Prisma.StoryVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>
          }
          findFirst: {
            args: Prisma.StoryVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>
          }
          findMany: {
            args: Prisma.StoryVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>[]
          }
          create: {
            args: Prisma.StoryVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>
          }
          createMany: {
            args: Prisma.StoryVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>[]
          }
          delete: {
            args: Prisma.StoryVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>
          }
          update: {
            args: Prisma.StoryVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>
          }
          deleteMany: {
            args: Prisma.StoryVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>[]
          }
          upsert: {
            args: Prisma.StoryVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>
          }
          aggregate: {
            args: Prisma.StoryVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryVersion>
          }
          groupBy: {
            args: Prisma.StoryVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryVersionCountArgs<ExtArgs>
            result: $Utils.Optional<StoryVersionCountAggregateOutputType> | number
          }
        }
      }
      StoryAuditLog: {
        payload: Prisma.$StoryAuditLogPayload<ExtArgs>
        fields: Prisma.StoryAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryAuditLogPayload>
          }
          findFirst: {
            args: Prisma.StoryAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryAuditLogPayload>
          }
          findMany: {
            args: Prisma.StoryAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryAuditLogPayload>[]
          }
          create: {
            args: Prisma.StoryAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryAuditLogPayload>
          }
          createMany: {
            args: Prisma.StoryAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryAuditLogPayload>[]
          }
          delete: {
            args: Prisma.StoryAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryAuditLogPayload>
          }
          update: {
            args: Prisma.StoryAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.StoryAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.StoryAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryAuditLogPayload>
          }
          aggregate: {
            args: Prisma.StoryAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryAuditLog>
          }
          groupBy: {
            args: Prisma.StoryAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<StoryAuditLogCountAggregateOutputType> | number
          }
        }
      }
      StoryReview: {
        payload: Prisma.$StoryReviewPayload<ExtArgs>
        fields: Prisma.StoryReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryReviewPayload>
          }
          findFirst: {
            args: Prisma.StoryReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryReviewPayload>
          }
          findMany: {
            args: Prisma.StoryReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryReviewPayload>[]
          }
          create: {
            args: Prisma.StoryReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryReviewPayload>
          }
          createMany: {
            args: Prisma.StoryReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryReviewPayload>[]
          }
          delete: {
            args: Prisma.StoryReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryReviewPayload>
          }
          update: {
            args: Prisma.StoryReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryReviewPayload>
          }
          deleteMany: {
            args: Prisma.StoryReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryReviewPayload>[]
          }
          upsert: {
            args: Prisma.StoryReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryReviewPayload>
          }
          aggregate: {
            args: Prisma.StoryReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryReview>
          }
          groupBy: {
            args: Prisma.StoryReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryReviewCountArgs<ExtArgs>
            result: $Utils.Optional<StoryReviewCountAggregateOutputType> | number
          }
        }
      }
      StoryPlaySession: {
        payload: Prisma.$StoryPlaySessionPayload<ExtArgs>
        fields: Prisma.StoryPlaySessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryPlaySessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPlaySessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryPlaySessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPlaySessionPayload>
          }
          findFirst: {
            args: Prisma.StoryPlaySessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPlaySessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryPlaySessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPlaySessionPayload>
          }
          findMany: {
            args: Prisma.StoryPlaySessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPlaySessionPayload>[]
          }
          create: {
            args: Prisma.StoryPlaySessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPlaySessionPayload>
          }
          createMany: {
            args: Prisma.StoryPlaySessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryPlaySessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPlaySessionPayload>[]
          }
          delete: {
            args: Prisma.StoryPlaySessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPlaySessionPayload>
          }
          update: {
            args: Prisma.StoryPlaySessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPlaySessionPayload>
          }
          deleteMany: {
            args: Prisma.StoryPlaySessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryPlaySessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryPlaySessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPlaySessionPayload>[]
          }
          upsert: {
            args: Prisma.StoryPlaySessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPlaySessionPayload>
          }
          aggregate: {
            args: Prisma.StoryPlaySessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryPlaySession>
          }
          groupBy: {
            args: Prisma.StoryPlaySessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryPlaySessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryPlaySessionCountArgs<ExtArgs>
            result: $Utils.Optional<StoryPlaySessionCountAggregateOutputType> | number
          }
        }
      }
      StoryNode: {
        payload: Prisma.$StoryNodePayload<ExtArgs>
        fields: Prisma.StoryNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryNodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryNodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryNodePayload>
          }
          findFirst: {
            args: Prisma.StoryNodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryNodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryNodePayload>
          }
          findMany: {
            args: Prisma.StoryNodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryNodePayload>[]
          }
          create: {
            args: Prisma.StoryNodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryNodePayload>
          }
          createMany: {
            args: Prisma.StoryNodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryNodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryNodePayload>[]
          }
          delete: {
            args: Prisma.StoryNodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryNodePayload>
          }
          update: {
            args: Prisma.StoryNodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryNodePayload>
          }
          deleteMany: {
            args: Prisma.StoryNodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryNodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryNodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryNodePayload>[]
          }
          upsert: {
            args: Prisma.StoryNodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryNodePayload>
          }
          aggregate: {
            args: Prisma.StoryNodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryNode>
          }
          groupBy: {
            args: Prisma.StoryNodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryNodeCountArgs<ExtArgs>
            result: $Utils.Optional<StoryNodeCountAggregateOutputType> | number
          }
        }
      }
      StoryPath: {
        payload: Prisma.$StoryPathPayload<ExtArgs>
        fields: Prisma.StoryPathFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryPathFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPathPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryPathFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPathPayload>
          }
          findFirst: {
            args: Prisma.StoryPathFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPathPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryPathFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPathPayload>
          }
          findMany: {
            args: Prisma.StoryPathFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPathPayload>[]
          }
          create: {
            args: Prisma.StoryPathCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPathPayload>
          }
          createMany: {
            args: Prisma.StoryPathCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryPathCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPathPayload>[]
          }
          delete: {
            args: Prisma.StoryPathDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPathPayload>
          }
          update: {
            args: Prisma.StoryPathUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPathPayload>
          }
          deleteMany: {
            args: Prisma.StoryPathDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryPathUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryPathUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPathPayload>[]
          }
          upsert: {
            args: Prisma.StoryPathUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPathPayload>
          }
          aggregate: {
            args: Prisma.StoryPathAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryPath>
          }
          groupBy: {
            args: Prisma.StoryPathGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryPathGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryPathCountArgs<ExtArgs>
            result: $Utils.Optional<StoryPathCountAggregateOutputType> | number
          }
        }
      }
      StoryTransition: {
        payload: Prisma.$StoryTransitionPayload<ExtArgs>
        fields: Prisma.StoryTransitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryTransitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryTransitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryTransitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryTransitionPayload>
          }
          findFirst: {
            args: Prisma.StoryTransitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryTransitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryTransitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryTransitionPayload>
          }
          findMany: {
            args: Prisma.StoryTransitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryTransitionPayload>[]
          }
          create: {
            args: Prisma.StoryTransitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryTransitionPayload>
          }
          createMany: {
            args: Prisma.StoryTransitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryTransitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryTransitionPayload>[]
          }
          delete: {
            args: Prisma.StoryTransitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryTransitionPayload>
          }
          update: {
            args: Prisma.StoryTransitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryTransitionPayload>
          }
          deleteMany: {
            args: Prisma.StoryTransitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryTransitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryTransitionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryTransitionPayload>[]
          }
          upsert: {
            args: Prisma.StoryTransitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryTransitionPayload>
          }
          aggregate: {
            args: Prisma.StoryTransitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryTransition>
          }
          groupBy: {
            args: Prisma.StoryTransitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryTransitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryTransitionCountArgs<ExtArgs>
            result: $Utils.Optional<StoryTransitionCountAggregateOutputType> | number
          }
        }
      }
      AvatarProfile: {
        payload: Prisma.$AvatarProfilePayload<ExtArgs>
        fields: Prisma.AvatarProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvatarProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvatarProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>
          }
          findFirst: {
            args: Prisma.AvatarProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvatarProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>
          }
          findMany: {
            args: Prisma.AvatarProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>[]
          }
          create: {
            args: Prisma.AvatarProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>
          }
          createMany: {
            args: Prisma.AvatarProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvatarProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>[]
          }
          delete: {
            args: Prisma.AvatarProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>
          }
          update: {
            args: Prisma.AvatarProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>
          }
          deleteMany: {
            args: Prisma.AvatarProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvatarProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvatarProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>[]
          }
          upsert: {
            args: Prisma.AvatarProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>
          }
          aggregate: {
            args: Prisma.AvatarProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvatarProfile>
          }
          groupBy: {
            args: Prisma.AvatarProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvatarProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvatarProfileCountArgs<ExtArgs>
            result: $Utils.Optional<AvatarProfileCountAggregateOutputType> | number
          }
        }
      }
      StoryInteraction: {
        payload: Prisma.$StoryInteractionPayload<ExtArgs>
        fields: Prisma.StoryInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryInteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryInteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryInteractionPayload>
          }
          findFirst: {
            args: Prisma.StoryInteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryInteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryInteractionPayload>
          }
          findMany: {
            args: Prisma.StoryInteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryInteractionPayload>[]
          }
          create: {
            args: Prisma.StoryInteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryInteractionPayload>
          }
          createMany: {
            args: Prisma.StoryInteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryInteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryInteractionPayload>[]
          }
          delete: {
            args: Prisma.StoryInteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryInteractionPayload>
          }
          update: {
            args: Prisma.StoryInteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryInteractionPayload>
          }
          deleteMany: {
            args: Prisma.StoryInteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryInteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryInteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryInteractionPayload>[]
          }
          upsert: {
            args: Prisma.StoryInteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryInteractionPayload>
          }
          aggregate: {
            args: Prisma.StoryInteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryInteraction>
          }
          groupBy: {
            args: Prisma.StoryInteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryInteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryInteractionCountArgs<ExtArgs>
            result: $Utils.Optional<StoryInteractionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userProfile?: UserProfileOmit
    creatorProfile?: CreatorProfileOmit
    userSession?: UserSessionOmit
    scenario?: ScenarioOmit
    journeyProgress?: JourneyProgressOmit
    achievement?: AchievementOmit
    userAchievement?: UserAchievementOmit
    twineStory?: TwineStoryOmit
    storyVersion?: StoryVersionOmit
    storyAuditLog?: StoryAuditLogOmit
    storyReview?: StoryReviewOmit
    storyPlaySession?: StoryPlaySessionOmit
    storyNode?: StoryNodeOmit
    storyPath?: StoryPathOmit
    storyTransition?: StoryTransitionOmit
    avatarProfile?: AvatarProfileOmit
    storyInteraction?: StoryInteractionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    journeys: number
    achievements: number
    storyPlays: number
    stories: number
    authoredVersions: number
    reviewedVersions: number
    reviews: number
    approvedStories: number
    originalStories: number
    reviewedCreatorProfiles: number
    storyAuditLogs: number
    storyInteractions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    journeys?: boolean | UserCountOutputTypeCountJourneysArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    storyPlays?: boolean | UserCountOutputTypeCountStoryPlaysArgs
    stories?: boolean | UserCountOutputTypeCountStoriesArgs
    authoredVersions?: boolean | UserCountOutputTypeCountAuthoredVersionsArgs
    reviewedVersions?: boolean | UserCountOutputTypeCountReviewedVersionsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    approvedStories?: boolean | UserCountOutputTypeCountApprovedStoriesArgs
    originalStories?: boolean | UserCountOutputTypeCountOriginalStoriesArgs
    reviewedCreatorProfiles?: boolean | UserCountOutputTypeCountReviewedCreatorProfilesArgs
    storyAuditLogs?: boolean | UserCountOutputTypeCountStoryAuditLogsArgs
    storyInteractions?: boolean | UserCountOutputTypeCountStoryInteractionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJourneysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JourneyProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoryPlaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryPlaySessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwineStoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthoredVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwineStoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOriginalStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwineStoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedCreatorProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatorProfileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoryAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryAuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoryInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryInteractionWhereInput
  }


  /**
   * Count Type CreatorProfileCountOutputType
   */

  export type CreatorProfileCountOutputType = {
    storiesSubmitted: number
  }

  export type CreatorProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storiesSubmitted?: boolean | CreatorProfileCountOutputTypeCountStoriesSubmittedArgs
  }

  // Custom InputTypes
  /**
   * CreatorProfileCountOutputType without action
   */
  export type CreatorProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfileCountOutputType
     */
    select?: CreatorProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreatorProfileCountOutputType without action
   */
  export type CreatorProfileCountOutputTypeCountStoriesSubmittedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwineStoryWhereInput
  }


  /**
   * Count Type UserSessionCountOutputType
   */

  export type UserSessionCountOutputType = {
    journeys: number
    storyPlays: number
    achievements: number
    storyInteractions: number
  }

  export type UserSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journeys?: boolean | UserSessionCountOutputTypeCountJourneysArgs
    storyPlays?: boolean | UserSessionCountOutputTypeCountStoryPlaysArgs
    achievements?: boolean | UserSessionCountOutputTypeCountAchievementsArgs
    storyInteractions?: boolean | UserSessionCountOutputTypeCountStoryInteractionsArgs
  }

  // Custom InputTypes
  /**
   * UserSessionCountOutputType without action
   */
  export type UserSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSessionCountOutputType
     */
    select?: UserSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserSessionCountOutputType without action
   */
  export type UserSessionCountOutputTypeCountJourneysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JourneyProgressWhereInput
  }

  /**
   * UserSessionCountOutputType without action
   */
  export type UserSessionCountOutputTypeCountStoryPlaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryPlaySessionWhereInput
  }

  /**
   * UserSessionCountOutputType without action
   */
  export type UserSessionCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserSessionCountOutputType without action
   */
  export type UserSessionCountOutputTypeCountStoryInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryInteractionWhereInput
  }


  /**
   * Count Type ScenarioCountOutputType
   */

  export type ScenarioCountOutputType = {
    journeys: number
  }

  export type ScenarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journeys?: boolean | ScenarioCountOutputTypeCountJourneysArgs
  }

  // Custom InputTypes
  /**
   * ScenarioCountOutputType without action
   */
  export type ScenarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioCountOutputType
     */
    select?: ScenarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScenarioCountOutputType without action
   */
  export type ScenarioCountOutputTypeCountJourneysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JourneyProgressWhereInput
  }


  /**
   * Count Type JourneyProgressCountOutputType
   */

  export type JourneyProgressCountOutputType = {
    achievements: number
  }

  export type JourneyProgressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievements?: boolean | JourneyProgressCountOutputTypeCountAchievementsArgs
  }

  // Custom InputTypes
  /**
   * JourneyProgressCountOutputType without action
   */
  export type JourneyProgressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgressCountOutputType
     */
    select?: JourneyProgressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JourneyProgressCountOutputType without action
   */
  export type JourneyProgressCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    userAwards: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAwards?: boolean | AchievementCountOutputTypeCountUserAwardsArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUserAwardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Count Type TwineStoryCountOutputType
   */

  export type TwineStoryCountOutputType = {
    versions: number
    playSessions: number
    nodes: number
    paths: number
    transitions: number
    avatars: number
    auditLogs: number
    interactions: number
  }

  export type TwineStoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | TwineStoryCountOutputTypeCountVersionsArgs
    playSessions?: boolean | TwineStoryCountOutputTypeCountPlaySessionsArgs
    nodes?: boolean | TwineStoryCountOutputTypeCountNodesArgs
    paths?: boolean | TwineStoryCountOutputTypeCountPathsArgs
    transitions?: boolean | TwineStoryCountOutputTypeCountTransitionsArgs
    avatars?: boolean | TwineStoryCountOutputTypeCountAvatarsArgs
    auditLogs?: boolean | TwineStoryCountOutputTypeCountAuditLogsArgs
    interactions?: boolean | TwineStoryCountOutputTypeCountInteractionsArgs
  }

  // Custom InputTypes
  /**
   * TwineStoryCountOutputType without action
   */
  export type TwineStoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStoryCountOutputType
     */
    select?: TwineStoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TwineStoryCountOutputType without action
   */
  export type TwineStoryCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryVersionWhereInput
  }

  /**
   * TwineStoryCountOutputType without action
   */
  export type TwineStoryCountOutputTypeCountPlaySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryPlaySessionWhereInput
  }

  /**
   * TwineStoryCountOutputType without action
   */
  export type TwineStoryCountOutputTypeCountNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryNodeWhereInput
  }

  /**
   * TwineStoryCountOutputType without action
   */
  export type TwineStoryCountOutputTypeCountPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryPathWhereInput
  }

  /**
   * TwineStoryCountOutputType without action
   */
  export type TwineStoryCountOutputTypeCountTransitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryTransitionWhereInput
  }

  /**
   * TwineStoryCountOutputType without action
   */
  export type TwineStoryCountOutputTypeCountAvatarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvatarProfileWhereInput
  }

  /**
   * TwineStoryCountOutputType without action
   */
  export type TwineStoryCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryAuditLogWhereInput
  }

  /**
   * TwineStoryCountOutputType without action
   */
  export type TwineStoryCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryInteractionWhereInput
  }


  /**
   * Count Type StoryVersionCountOutputType
   */

  export type StoryVersionCountOutputType = {
    reviews: number
    playSessions: number
  }

  export type StoryVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | StoryVersionCountOutputTypeCountReviewsArgs
    playSessions?: boolean | StoryVersionCountOutputTypeCountPlaySessionsArgs
  }

  // Custom InputTypes
  /**
   * StoryVersionCountOutputType without action
   */
  export type StoryVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersionCountOutputType
     */
    select?: StoryVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoryVersionCountOutputType without action
   */
  export type StoryVersionCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryReviewWhereInput
  }

  /**
   * StoryVersionCountOutputType without action
   */
  export type StoryVersionCountOutputTypeCountPlaySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryPlaySessionWhereInput
  }


  /**
   * Count Type StoryNodeCountOutputType
   */

  export type StoryNodeCountOutputType = {
    outgoing: number
    incoming: number
  }

  export type StoryNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outgoing?: boolean | StoryNodeCountOutputTypeCountOutgoingArgs
    incoming?: boolean | StoryNodeCountOutputTypeCountIncomingArgs
  }

  // Custom InputTypes
  /**
   * StoryNodeCountOutputType without action
   */
  export type StoryNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNodeCountOutputType
     */
    select?: StoryNodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoryNodeCountOutputType without action
   */
  export type StoryNodeCountOutputTypeCountOutgoingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryTransitionWhereInput
  }

  /**
   * StoryNodeCountOutputType without action
   */
  export type StoryNodeCountOutputTypeCountIncomingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryTransitionWhereInput
  }


  /**
   * Count Type StoryPathCountOutputType
   */

  export type StoryPathCountOutputType = {
    transitions: number
  }

  export type StoryPathCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transitions?: boolean | StoryPathCountOutputTypeCountTransitionsArgs
  }

  // Custom InputTypes
  /**
   * StoryPathCountOutputType without action
   */
  export type StoryPathCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPathCountOutputType
     */
    select?: StoryPathCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoryPathCountOutputType without action
   */
  export type StoryPathCountOutputTypeCountTransitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryTransitionWhereInput
  }


  /**
   * Count Type AvatarProfileCountOutputType
   */

  export type AvatarProfileCountOutputType = {
    interactions: number
  }

  export type AvatarProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interactions?: boolean | AvatarProfileCountOutputTypeCountInteractionsArgs
  }

  // Custom InputTypes
  /**
   * AvatarProfileCountOutputType without action
   */
  export type AvatarProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfileCountOutputType
     */
    select?: AvatarProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AvatarProfileCountOutputType without action
   */
  export type AvatarProfileCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryInteractionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    hashedPassword: string | null
    role: $Enums.UserRole | null
    onboardedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isAdmin: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    hashedPassword: string | null
    role: $Enums.UserRole | null
    onboardedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isAdmin: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    hashedPassword: number
    role: number
    onboardedAt: number
    createdAt: number
    updatedAt: number
    isAdmin: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    hashedPassword?: true
    role?: true
    onboardedAt?: true
    createdAt?: true
    updatedAt?: true
    isAdmin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    hashedPassword?: true
    role?: true
    onboardedAt?: true
    createdAt?: true
    updatedAt?: true
    isAdmin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    hashedPassword?: true
    role?: true
    onboardedAt?: true
    createdAt?: true
    updatedAt?: true
    isAdmin?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    username: string | null
    hashedPassword: string | null
    role: $Enums.UserRole
    onboardedAt: Date | null
    createdAt: Date
    updatedAt: Date
    isAdmin: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    hashedPassword?: boolean
    role?: boolean
    onboardedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAdmin?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    journeys?: boolean | User$journeysArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    storyPlays?: boolean | User$storyPlaysArgs<ExtArgs>
    stories?: boolean | User$storiesArgs<ExtArgs>
    authoredVersions?: boolean | User$authoredVersionsArgs<ExtArgs>
    reviewedVersions?: boolean | User$reviewedVersionsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    creatorProfile?: boolean | User$creatorProfileArgs<ExtArgs>
    approvedStories?: boolean | User$approvedStoriesArgs<ExtArgs>
    originalStories?: boolean | User$originalStoriesArgs<ExtArgs>
    reviewedCreatorProfiles?: boolean | User$reviewedCreatorProfilesArgs<ExtArgs>
    storyAuditLogs?: boolean | User$storyAuditLogsArgs<ExtArgs>
    storyInteractions?: boolean | User$storyInteractionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    hashedPassword?: boolean
    role?: boolean
    onboardedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAdmin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    hashedPassword?: boolean
    role?: boolean
    onboardedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAdmin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    hashedPassword?: boolean
    role?: boolean
    onboardedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAdmin?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "hashedPassword" | "role" | "onboardedAt" | "createdAt" | "updatedAt" | "isAdmin", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    journeys?: boolean | User$journeysArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    storyPlays?: boolean | User$storyPlaysArgs<ExtArgs>
    stories?: boolean | User$storiesArgs<ExtArgs>
    authoredVersions?: boolean | User$authoredVersionsArgs<ExtArgs>
    reviewedVersions?: boolean | User$reviewedVersionsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    creatorProfile?: boolean | User$creatorProfileArgs<ExtArgs>
    approvedStories?: boolean | User$approvedStoriesArgs<ExtArgs>
    originalStories?: boolean | User$originalStoriesArgs<ExtArgs>
    reviewedCreatorProfiles?: boolean | User$reviewedCreatorProfilesArgs<ExtArgs>
    storyAuditLogs?: boolean | User$storyAuditLogsArgs<ExtArgs>
    storyInteractions?: boolean | User$storyInteractionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs> | null
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      journeys: Prisma.$JourneyProgressPayload<ExtArgs>[]
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      storyPlays: Prisma.$StoryPlaySessionPayload<ExtArgs>[]
      stories: Prisma.$TwineStoryPayload<ExtArgs>[]
      authoredVersions: Prisma.$StoryVersionPayload<ExtArgs>[]
      reviewedVersions: Prisma.$StoryVersionPayload<ExtArgs>[]
      reviews: Prisma.$StoryReviewPayload<ExtArgs>[]
      creatorProfile: Prisma.$CreatorProfilePayload<ExtArgs> | null
      approvedStories: Prisma.$TwineStoryPayload<ExtArgs>[]
      originalStories: Prisma.$TwineStoryPayload<ExtArgs>[]
      reviewedCreatorProfiles: Prisma.$CreatorProfilePayload<ExtArgs>[]
      storyAuditLogs: Prisma.$StoryAuditLogPayload<ExtArgs>[]
      storyInteractions: Prisma.$StoryInteractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      username: string | null
      hashedPassword: string | null
      role: $Enums.UserRole
      onboardedAt: Date | null
      createdAt: Date
      updatedAt: Date
      isAdmin: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journeys<T extends User$journeysArgs<ExtArgs> = {}>(args?: Subset<T, User$journeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storyPlays<T extends User$storyPlaysArgs<ExtArgs> = {}>(args?: Subset<T, User$storyPlaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stories<T extends User$storiesArgs<ExtArgs> = {}>(args?: Subset<T, User$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    authoredVersions<T extends User$authoredVersionsArgs<ExtArgs> = {}>(args?: Subset<T, User$authoredVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewedVersions<T extends User$reviewedVersionsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creatorProfile<T extends User$creatorProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$creatorProfileArgs<ExtArgs>>): Prisma__CreatorProfileClient<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvedStories<T extends User$approvedStoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedStoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    originalStories<T extends User$originalStoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$originalStoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewedCreatorProfiles<T extends User$reviewedCreatorProfilesArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedCreatorProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storyAuditLogs<T extends User$storyAuditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$storyAuditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storyInteractions<T extends User$storyInteractionsArgs<ExtArgs> = {}>(args?: Subset<T, User$storyInteractionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly hashedPassword: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly onboardedAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.journeys
   */
  export type User$journeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    where?: JourneyProgressWhereInput
    orderBy?: JourneyProgressOrderByWithRelationInput | JourneyProgressOrderByWithRelationInput[]
    cursor?: JourneyProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JourneyProgressScalarFieldEnum | JourneyProgressScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.storyPlays
   */
  export type User$storyPlaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    where?: StoryPlaySessionWhereInput
    orderBy?: StoryPlaySessionOrderByWithRelationInput | StoryPlaySessionOrderByWithRelationInput[]
    cursor?: StoryPlaySessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryPlaySessionScalarFieldEnum | StoryPlaySessionScalarFieldEnum[]
  }

  /**
   * User.stories
   */
  export type User$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    where?: TwineStoryWhereInput
    orderBy?: TwineStoryOrderByWithRelationInput | TwineStoryOrderByWithRelationInput[]
    cursor?: TwineStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwineStoryScalarFieldEnum | TwineStoryScalarFieldEnum[]
  }

  /**
   * User.authoredVersions
   */
  export type User$authoredVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    where?: StoryVersionWhereInput
    orderBy?: StoryVersionOrderByWithRelationInput | StoryVersionOrderByWithRelationInput[]
    cursor?: StoryVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryVersionScalarFieldEnum | StoryVersionScalarFieldEnum[]
  }

  /**
   * User.reviewedVersions
   */
  export type User$reviewedVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    where?: StoryVersionWhereInput
    orderBy?: StoryVersionOrderByWithRelationInput | StoryVersionOrderByWithRelationInput[]
    cursor?: StoryVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryVersionScalarFieldEnum | StoryVersionScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewInclude<ExtArgs> | null
    where?: StoryReviewWhereInput
    orderBy?: StoryReviewOrderByWithRelationInput | StoryReviewOrderByWithRelationInput[]
    cursor?: StoryReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryReviewScalarFieldEnum | StoryReviewScalarFieldEnum[]
  }

  /**
   * User.creatorProfile
   */
  export type User$creatorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
    where?: CreatorProfileWhereInput
  }

  /**
   * User.approvedStories
   */
  export type User$approvedStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    where?: TwineStoryWhereInput
    orderBy?: TwineStoryOrderByWithRelationInput | TwineStoryOrderByWithRelationInput[]
    cursor?: TwineStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwineStoryScalarFieldEnum | TwineStoryScalarFieldEnum[]
  }

  /**
   * User.originalStories
   */
  export type User$originalStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    where?: TwineStoryWhereInput
    orderBy?: TwineStoryOrderByWithRelationInput | TwineStoryOrderByWithRelationInput[]
    cursor?: TwineStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwineStoryScalarFieldEnum | TwineStoryScalarFieldEnum[]
  }

  /**
   * User.reviewedCreatorProfiles
   */
  export type User$reviewedCreatorProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
    where?: CreatorProfileWhereInput
    orderBy?: CreatorProfileOrderByWithRelationInput | CreatorProfileOrderByWithRelationInput[]
    cursor?: CreatorProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatorProfileScalarFieldEnum | CreatorProfileScalarFieldEnum[]
  }

  /**
   * User.storyAuditLogs
   */
  export type User$storyAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogInclude<ExtArgs> | null
    where?: StoryAuditLogWhereInput
    orderBy?: StoryAuditLogOrderByWithRelationInput | StoryAuditLogOrderByWithRelationInput[]
    cursor?: StoryAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryAuditLogScalarFieldEnum | StoryAuditLogScalarFieldEnum[]
  }

  /**
   * User.storyInteractions
   */
  export type User$storyInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    where?: StoryInteractionWhereInput
    orderBy?: StoryInteractionOrderByWithRelationInput | StoryInteractionOrderByWithRelationInput[]
    cursor?: StoryInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryInteractionScalarFieldEnum | StoryInteractionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    avatarUrl: string | null
    bio: string | null
    timezone: string | null
    pronouns: string | null
    location: string | null
    publicEmail: string | null
    websiteUrl: string | null
    linkedinUrl: string | null
    twitterHandle: string | null
    instagramHandle: string | null
    tiktokHandle: string | null
    consentAcceptedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    avatarUrl: string | null
    bio: string | null
    timezone: string | null
    pronouns: string | null
    location: string | null
    publicEmail: string | null
    websiteUrl: string | null
    linkedinUrl: string | null
    twitterHandle: string | null
    instagramHandle: string | null
    tiktokHandle: string | null
    consentAcceptedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    displayName: number
    avatarUrl: number
    bio: number
    timezone: number
    pronouns: number
    location: number
    publicEmail: number
    websiteUrl: number
    linkedinUrl: number
    twitterHandle: number
    instagramHandle: number
    tiktokHandle: number
    expertiseTags: number
    customLinks: number
    consentAcceptedAt: number
    preferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    avatarUrl?: true
    bio?: true
    timezone?: true
    pronouns?: true
    location?: true
    publicEmail?: true
    websiteUrl?: true
    linkedinUrl?: true
    twitterHandle?: true
    instagramHandle?: true
    tiktokHandle?: true
    consentAcceptedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    avatarUrl?: true
    bio?: true
    timezone?: true
    pronouns?: true
    location?: true
    publicEmail?: true
    websiteUrl?: true
    linkedinUrl?: true
    twitterHandle?: true
    instagramHandle?: true
    tiktokHandle?: true
    consentAcceptedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    avatarUrl?: true
    bio?: true
    timezone?: true
    pronouns?: true
    location?: true
    publicEmail?: true
    websiteUrl?: true
    linkedinUrl?: true
    twitterHandle?: true
    instagramHandle?: true
    tiktokHandle?: true
    expertiseTags?: true
    customLinks?: true
    consentAcceptedAt?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    userId: string
    displayName: string | null
    avatarUrl: string | null
    bio: string | null
    timezone: string | null
    pronouns: string | null
    location: string | null
    publicEmail: string | null
    websiteUrl: string | null
    linkedinUrl: string | null
    twitterHandle: string | null
    instagramHandle: string | null
    tiktokHandle: string | null
    expertiseTags: string[]
    customLinks: JsonValue | null
    consentAcceptedAt: Date | null
    preferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    bio?: boolean
    timezone?: boolean
    pronouns?: boolean
    location?: boolean
    publicEmail?: boolean
    websiteUrl?: boolean
    linkedinUrl?: boolean
    twitterHandle?: boolean
    instagramHandle?: boolean
    tiktokHandle?: boolean
    expertiseTags?: boolean
    customLinks?: boolean
    consentAcceptedAt?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    bio?: boolean
    timezone?: boolean
    pronouns?: boolean
    location?: boolean
    publicEmail?: boolean
    websiteUrl?: boolean
    linkedinUrl?: boolean
    twitterHandle?: boolean
    instagramHandle?: boolean
    tiktokHandle?: boolean
    expertiseTags?: boolean
    customLinks?: boolean
    consentAcceptedAt?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    bio?: boolean
    timezone?: boolean
    pronouns?: boolean
    location?: boolean
    publicEmail?: boolean
    websiteUrl?: boolean
    linkedinUrl?: boolean
    twitterHandle?: boolean
    instagramHandle?: boolean
    tiktokHandle?: boolean
    expertiseTags?: boolean
    customLinks?: boolean
    consentAcceptedAt?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    bio?: boolean
    timezone?: boolean
    pronouns?: boolean
    location?: boolean
    publicEmail?: boolean
    websiteUrl?: boolean
    linkedinUrl?: boolean
    twitterHandle?: boolean
    instagramHandle?: boolean
    tiktokHandle?: boolean
    expertiseTags?: boolean
    customLinks?: boolean
    consentAcceptedAt?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "displayName" | "avatarUrl" | "bio" | "timezone" | "pronouns" | "location" | "publicEmail" | "websiteUrl" | "linkedinUrl" | "twitterHandle" | "instagramHandle" | "tiktokHandle" | "expertiseTags" | "customLinks" | "consentAcceptedAt" | "preferences" | "createdAt" | "updatedAt", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      displayName: string | null
      avatarUrl: string | null
      bio: string | null
      timezone: string | null
      pronouns: string | null
      location: string | null
      publicEmail: string | null
      websiteUrl: string | null
      linkedinUrl: string | null
      twitterHandle: string | null
      instagramHandle: string | null
      tiktokHandle: string | null
      expertiseTags: string[]
      customLinks: Prisma.JsonValue | null
      consentAcceptedAt: Date | null
      preferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly displayName: FieldRef<"UserProfile", 'String'>
    readonly avatarUrl: FieldRef<"UserProfile", 'String'>
    readonly bio: FieldRef<"UserProfile", 'String'>
    readonly timezone: FieldRef<"UserProfile", 'String'>
    readonly pronouns: FieldRef<"UserProfile", 'String'>
    readonly location: FieldRef<"UserProfile", 'String'>
    readonly publicEmail: FieldRef<"UserProfile", 'String'>
    readonly websiteUrl: FieldRef<"UserProfile", 'String'>
    readonly linkedinUrl: FieldRef<"UserProfile", 'String'>
    readonly twitterHandle: FieldRef<"UserProfile", 'String'>
    readonly instagramHandle: FieldRef<"UserProfile", 'String'>
    readonly tiktokHandle: FieldRef<"UserProfile", 'String'>
    readonly expertiseTags: FieldRef<"UserProfile", 'String[]'>
    readonly customLinks: FieldRef<"UserProfile", 'Json'>
    readonly consentAcceptedAt: FieldRef<"UserProfile", 'DateTime'>
    readonly preferences: FieldRef<"UserProfile", 'Json'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model CreatorProfile
   */

  export type AggregateCreatorProfile = {
    _count: CreatorProfileCountAggregateOutputType | null
    _min: CreatorProfileMinAggregateOutputType | null
    _max: CreatorProfileMaxAggregateOutputType | null
  }

  export type CreatorProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    penName: string | null
    headline: string | null
    tagline: string | null
    biography: string | null
    websiteUrl: string | null
    portfolioUrl: string | null
    contactEmail: string | null
    guidelinesAcceptedAt: Date | null
    termsAcceptedAt: Date | null
    consentAcceptedAt: Date | null
    consentStatement: string | null
    status: $Enums.CreatorProfileStatus | null
    completedAt: Date | null
    lastReviewedAt: Date | null
    lastReviewerId: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreatorProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    penName: string | null
    headline: string | null
    tagline: string | null
    biography: string | null
    websiteUrl: string | null
    portfolioUrl: string | null
    contactEmail: string | null
    guidelinesAcceptedAt: Date | null
    termsAcceptedAt: Date | null
    consentAcceptedAt: Date | null
    consentStatement: string | null
    status: $Enums.CreatorProfileStatus | null
    completedAt: Date | null
    lastReviewedAt: Date | null
    lastReviewerId: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreatorProfileCountAggregateOutputType = {
    id: number
    userId: number
    penName: number
    headline: number
    expertiseTags: number
    focusAreas: number
    languages: number
    tagline: number
    biography: number
    websiteUrl: number
    portfolioUrl: number
    contactEmail: number
    socialLinks: number
    payoutDetails: number
    guidelinesAcceptedAt: number
    termsAcceptedAt: number
    consentAcceptedAt: number
    consentStatement: number
    status: number
    completedAt: number
    lastReviewedAt: number
    lastReviewerId: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CreatorProfileMinAggregateInputType = {
    id?: true
    userId?: true
    penName?: true
    headline?: true
    tagline?: true
    biography?: true
    websiteUrl?: true
    portfolioUrl?: true
    contactEmail?: true
    guidelinesAcceptedAt?: true
    termsAcceptedAt?: true
    consentAcceptedAt?: true
    consentStatement?: true
    status?: true
    completedAt?: true
    lastReviewedAt?: true
    lastReviewerId?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreatorProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    penName?: true
    headline?: true
    tagline?: true
    biography?: true
    websiteUrl?: true
    portfolioUrl?: true
    contactEmail?: true
    guidelinesAcceptedAt?: true
    termsAcceptedAt?: true
    consentAcceptedAt?: true
    consentStatement?: true
    status?: true
    completedAt?: true
    lastReviewedAt?: true
    lastReviewerId?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreatorProfileCountAggregateInputType = {
    id?: true
    userId?: true
    penName?: true
    headline?: true
    expertiseTags?: true
    focusAreas?: true
    languages?: true
    tagline?: true
    biography?: true
    websiteUrl?: true
    portfolioUrl?: true
    contactEmail?: true
    socialLinks?: true
    payoutDetails?: true
    guidelinesAcceptedAt?: true
    termsAcceptedAt?: true
    consentAcceptedAt?: true
    consentStatement?: true
    status?: true
    completedAt?: true
    lastReviewedAt?: true
    lastReviewerId?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CreatorProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatorProfile to aggregate.
     */
    where?: CreatorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorProfiles to fetch.
     */
    orderBy?: CreatorProfileOrderByWithRelationInput | CreatorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatorProfiles
    **/
    _count?: true | CreatorProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatorProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatorProfileMaxAggregateInputType
  }

  export type GetCreatorProfileAggregateType<T extends CreatorProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatorProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatorProfile[P]>
      : GetScalarType<T[P], AggregateCreatorProfile[P]>
  }




  export type CreatorProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatorProfileWhereInput
    orderBy?: CreatorProfileOrderByWithAggregationInput | CreatorProfileOrderByWithAggregationInput[]
    by: CreatorProfileScalarFieldEnum[] | CreatorProfileScalarFieldEnum
    having?: CreatorProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatorProfileCountAggregateInputType | true
    _min?: CreatorProfileMinAggregateInputType
    _max?: CreatorProfileMaxAggregateInputType
  }

  export type CreatorProfileGroupByOutputType = {
    id: string
    userId: string
    penName: string | null
    headline: string | null
    expertiseTags: string[]
    focusAreas: string[]
    languages: string[]
    tagline: string | null
    biography: string | null
    websiteUrl: string | null
    portfolioUrl: string | null
    contactEmail: string | null
    socialLinks: JsonValue | null
    payoutDetails: JsonValue | null
    guidelinesAcceptedAt: Date | null
    termsAcceptedAt: Date | null
    consentAcceptedAt: Date | null
    consentStatement: string | null
    status: $Enums.CreatorProfileStatus
    completedAt: Date | null
    lastReviewedAt: Date | null
    lastReviewerId: string | null
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: CreatorProfileCountAggregateOutputType | null
    _min: CreatorProfileMinAggregateOutputType | null
    _max: CreatorProfileMaxAggregateOutputType | null
  }

  type GetCreatorProfileGroupByPayload<T extends CreatorProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatorProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatorProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatorProfileGroupByOutputType[P]>
            : GetScalarType<T[P], CreatorProfileGroupByOutputType[P]>
        }
      >
    >


  export type CreatorProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    penName?: boolean
    headline?: boolean
    expertiseTags?: boolean
    focusAreas?: boolean
    languages?: boolean
    tagline?: boolean
    biography?: boolean
    websiteUrl?: boolean
    portfolioUrl?: boolean
    contactEmail?: boolean
    socialLinks?: boolean
    payoutDetails?: boolean
    guidelinesAcceptedAt?: boolean
    termsAcceptedAt?: boolean
    consentAcceptedAt?: boolean
    consentStatement?: boolean
    status?: boolean
    completedAt?: boolean
    lastReviewedAt?: boolean
    lastReviewerId?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lastReviewer?: boolean | CreatorProfile$lastReviewerArgs<ExtArgs>
    storiesSubmitted?: boolean | CreatorProfile$storiesSubmittedArgs<ExtArgs>
    _count?: boolean | CreatorProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatorProfile"]>

  export type CreatorProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    penName?: boolean
    headline?: boolean
    expertiseTags?: boolean
    focusAreas?: boolean
    languages?: boolean
    tagline?: boolean
    biography?: boolean
    websiteUrl?: boolean
    portfolioUrl?: boolean
    contactEmail?: boolean
    socialLinks?: boolean
    payoutDetails?: boolean
    guidelinesAcceptedAt?: boolean
    termsAcceptedAt?: boolean
    consentAcceptedAt?: boolean
    consentStatement?: boolean
    status?: boolean
    completedAt?: boolean
    lastReviewedAt?: boolean
    lastReviewerId?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lastReviewer?: boolean | CreatorProfile$lastReviewerArgs<ExtArgs>
  }, ExtArgs["result"]["creatorProfile"]>

  export type CreatorProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    penName?: boolean
    headline?: boolean
    expertiseTags?: boolean
    focusAreas?: boolean
    languages?: boolean
    tagline?: boolean
    biography?: boolean
    websiteUrl?: boolean
    portfolioUrl?: boolean
    contactEmail?: boolean
    socialLinks?: boolean
    payoutDetails?: boolean
    guidelinesAcceptedAt?: boolean
    termsAcceptedAt?: boolean
    consentAcceptedAt?: boolean
    consentStatement?: boolean
    status?: boolean
    completedAt?: boolean
    lastReviewedAt?: boolean
    lastReviewerId?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lastReviewer?: boolean | CreatorProfile$lastReviewerArgs<ExtArgs>
  }, ExtArgs["result"]["creatorProfile"]>

  export type CreatorProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    penName?: boolean
    headline?: boolean
    expertiseTags?: boolean
    focusAreas?: boolean
    languages?: boolean
    tagline?: boolean
    biography?: boolean
    websiteUrl?: boolean
    portfolioUrl?: boolean
    contactEmail?: boolean
    socialLinks?: boolean
    payoutDetails?: boolean
    guidelinesAcceptedAt?: boolean
    termsAcceptedAt?: boolean
    consentAcceptedAt?: boolean
    consentStatement?: boolean
    status?: boolean
    completedAt?: boolean
    lastReviewedAt?: boolean
    lastReviewerId?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CreatorProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "penName" | "headline" | "expertiseTags" | "focusAreas" | "languages" | "tagline" | "biography" | "websiteUrl" | "portfolioUrl" | "contactEmail" | "socialLinks" | "payoutDetails" | "guidelinesAcceptedAt" | "termsAcceptedAt" | "consentAcceptedAt" | "consentStatement" | "status" | "completedAt" | "lastReviewedAt" | "lastReviewerId" | "rejectionReason" | "createdAt" | "updatedAt", ExtArgs["result"]["creatorProfile"]>
  export type CreatorProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lastReviewer?: boolean | CreatorProfile$lastReviewerArgs<ExtArgs>
    storiesSubmitted?: boolean | CreatorProfile$storiesSubmittedArgs<ExtArgs>
    _count?: boolean | CreatorProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreatorProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lastReviewer?: boolean | CreatorProfile$lastReviewerArgs<ExtArgs>
  }
  export type CreatorProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lastReviewer?: boolean | CreatorProfile$lastReviewerArgs<ExtArgs>
  }

  export type $CreatorProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreatorProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      lastReviewer: Prisma.$UserPayload<ExtArgs> | null
      storiesSubmitted: Prisma.$TwineStoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      penName: string | null
      headline: string | null
      expertiseTags: string[]
      focusAreas: string[]
      languages: string[]
      tagline: string | null
      biography: string | null
      websiteUrl: string | null
      portfolioUrl: string | null
      contactEmail: string | null
      socialLinks: Prisma.JsonValue | null
      payoutDetails: Prisma.JsonValue | null
      guidelinesAcceptedAt: Date | null
      termsAcceptedAt: Date | null
      consentAcceptedAt: Date | null
      consentStatement: string | null
      status: $Enums.CreatorProfileStatus
      completedAt: Date | null
      lastReviewedAt: Date | null
      lastReviewerId: string | null
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["creatorProfile"]>
    composites: {}
  }

  type CreatorProfileGetPayload<S extends boolean | null | undefined | CreatorProfileDefaultArgs> = $Result.GetResult<Prisma.$CreatorProfilePayload, S>

  type CreatorProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatorProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatorProfileCountAggregateInputType | true
    }

  export interface CreatorProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreatorProfile'], meta: { name: 'CreatorProfile' } }
    /**
     * Find zero or one CreatorProfile that matches the filter.
     * @param {CreatorProfileFindUniqueArgs} args - Arguments to find a CreatorProfile
     * @example
     * // Get one CreatorProfile
     * const creatorProfile = await prisma.creatorProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatorProfileFindUniqueArgs>(args: SelectSubset<T, CreatorProfileFindUniqueArgs<ExtArgs>>): Prisma__CreatorProfileClient<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreatorProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatorProfileFindUniqueOrThrowArgs} args - Arguments to find a CreatorProfile
     * @example
     * // Get one CreatorProfile
     * const creatorProfile = await prisma.creatorProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatorProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatorProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatorProfileClient<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreatorProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorProfileFindFirstArgs} args - Arguments to find a CreatorProfile
     * @example
     * // Get one CreatorProfile
     * const creatorProfile = await prisma.creatorProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatorProfileFindFirstArgs>(args?: SelectSubset<T, CreatorProfileFindFirstArgs<ExtArgs>>): Prisma__CreatorProfileClient<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreatorProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorProfileFindFirstOrThrowArgs} args - Arguments to find a CreatorProfile
     * @example
     * // Get one CreatorProfile
     * const creatorProfile = await prisma.creatorProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatorProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatorProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatorProfileClient<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreatorProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatorProfiles
     * const creatorProfiles = await prisma.creatorProfile.findMany()
     * 
     * // Get first 10 CreatorProfiles
     * const creatorProfiles = await prisma.creatorProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatorProfileWithIdOnly = await prisma.creatorProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatorProfileFindManyArgs>(args?: SelectSubset<T, CreatorProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreatorProfile.
     * @param {CreatorProfileCreateArgs} args - Arguments to create a CreatorProfile.
     * @example
     * // Create one CreatorProfile
     * const CreatorProfile = await prisma.creatorProfile.create({
     *   data: {
     *     // ... data to create a CreatorProfile
     *   }
     * })
     * 
     */
    create<T extends CreatorProfileCreateArgs>(args: SelectSubset<T, CreatorProfileCreateArgs<ExtArgs>>): Prisma__CreatorProfileClient<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreatorProfiles.
     * @param {CreatorProfileCreateManyArgs} args - Arguments to create many CreatorProfiles.
     * @example
     * // Create many CreatorProfiles
     * const creatorProfile = await prisma.creatorProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatorProfileCreateManyArgs>(args?: SelectSubset<T, CreatorProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreatorProfiles and returns the data saved in the database.
     * @param {CreatorProfileCreateManyAndReturnArgs} args - Arguments to create many CreatorProfiles.
     * @example
     * // Create many CreatorProfiles
     * const creatorProfile = await prisma.creatorProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreatorProfiles and only return the `id`
     * const creatorProfileWithIdOnly = await prisma.creatorProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatorProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatorProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreatorProfile.
     * @param {CreatorProfileDeleteArgs} args - Arguments to delete one CreatorProfile.
     * @example
     * // Delete one CreatorProfile
     * const CreatorProfile = await prisma.creatorProfile.delete({
     *   where: {
     *     // ... filter to delete one CreatorProfile
     *   }
     * })
     * 
     */
    delete<T extends CreatorProfileDeleteArgs>(args: SelectSubset<T, CreatorProfileDeleteArgs<ExtArgs>>): Prisma__CreatorProfileClient<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreatorProfile.
     * @param {CreatorProfileUpdateArgs} args - Arguments to update one CreatorProfile.
     * @example
     * // Update one CreatorProfile
     * const creatorProfile = await prisma.creatorProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatorProfileUpdateArgs>(args: SelectSubset<T, CreatorProfileUpdateArgs<ExtArgs>>): Prisma__CreatorProfileClient<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreatorProfiles.
     * @param {CreatorProfileDeleteManyArgs} args - Arguments to filter CreatorProfiles to delete.
     * @example
     * // Delete a few CreatorProfiles
     * const { count } = await prisma.creatorProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatorProfileDeleteManyArgs>(args?: SelectSubset<T, CreatorProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatorProfiles
     * const creatorProfile = await prisma.creatorProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatorProfileUpdateManyArgs>(args: SelectSubset<T, CreatorProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatorProfiles and returns the data updated in the database.
     * @param {CreatorProfileUpdateManyAndReturnArgs} args - Arguments to update many CreatorProfiles.
     * @example
     * // Update many CreatorProfiles
     * const creatorProfile = await prisma.creatorProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreatorProfiles and only return the `id`
     * const creatorProfileWithIdOnly = await prisma.creatorProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatorProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatorProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreatorProfile.
     * @param {CreatorProfileUpsertArgs} args - Arguments to update or create a CreatorProfile.
     * @example
     * // Update or create a CreatorProfile
     * const creatorProfile = await prisma.creatorProfile.upsert({
     *   create: {
     *     // ... data to create a CreatorProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatorProfile we want to update
     *   }
     * })
     */
    upsert<T extends CreatorProfileUpsertArgs>(args: SelectSubset<T, CreatorProfileUpsertArgs<ExtArgs>>): Prisma__CreatorProfileClient<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreatorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorProfileCountArgs} args - Arguments to filter CreatorProfiles to count.
     * @example
     * // Count the number of CreatorProfiles
     * const count = await prisma.creatorProfile.count({
     *   where: {
     *     // ... the filter for the CreatorProfiles we want to count
     *   }
     * })
    **/
    count<T extends CreatorProfileCountArgs>(
      args?: Subset<T, CreatorProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatorProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatorProfileAggregateArgs>(args: Subset<T, CreatorProfileAggregateArgs>): Prisma.PrismaPromise<GetCreatorProfileAggregateType<T>>

    /**
     * Group by CreatorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatorProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatorProfileGroupByArgs['orderBy'] }
        : { orderBy?: CreatorProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatorProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatorProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreatorProfile model
   */
  readonly fields: CreatorProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatorProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatorProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lastReviewer<T extends CreatorProfile$lastReviewerArgs<ExtArgs> = {}>(args?: Subset<T, CreatorProfile$lastReviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    storiesSubmitted<T extends CreatorProfile$storiesSubmittedArgs<ExtArgs> = {}>(args?: Subset<T, CreatorProfile$storiesSubmittedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreatorProfile model
   */
  interface CreatorProfileFieldRefs {
    readonly id: FieldRef<"CreatorProfile", 'String'>
    readonly userId: FieldRef<"CreatorProfile", 'String'>
    readonly penName: FieldRef<"CreatorProfile", 'String'>
    readonly headline: FieldRef<"CreatorProfile", 'String'>
    readonly expertiseTags: FieldRef<"CreatorProfile", 'String[]'>
    readonly focusAreas: FieldRef<"CreatorProfile", 'String[]'>
    readonly languages: FieldRef<"CreatorProfile", 'String[]'>
    readonly tagline: FieldRef<"CreatorProfile", 'String'>
    readonly biography: FieldRef<"CreatorProfile", 'String'>
    readonly websiteUrl: FieldRef<"CreatorProfile", 'String'>
    readonly portfolioUrl: FieldRef<"CreatorProfile", 'String'>
    readonly contactEmail: FieldRef<"CreatorProfile", 'String'>
    readonly socialLinks: FieldRef<"CreatorProfile", 'Json'>
    readonly payoutDetails: FieldRef<"CreatorProfile", 'Json'>
    readonly guidelinesAcceptedAt: FieldRef<"CreatorProfile", 'DateTime'>
    readonly termsAcceptedAt: FieldRef<"CreatorProfile", 'DateTime'>
    readonly consentAcceptedAt: FieldRef<"CreatorProfile", 'DateTime'>
    readonly consentStatement: FieldRef<"CreatorProfile", 'String'>
    readonly status: FieldRef<"CreatorProfile", 'CreatorProfileStatus'>
    readonly completedAt: FieldRef<"CreatorProfile", 'DateTime'>
    readonly lastReviewedAt: FieldRef<"CreatorProfile", 'DateTime'>
    readonly lastReviewerId: FieldRef<"CreatorProfile", 'String'>
    readonly rejectionReason: FieldRef<"CreatorProfile", 'String'>
    readonly createdAt: FieldRef<"CreatorProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"CreatorProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreatorProfile findUnique
   */
  export type CreatorProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
    /**
     * Filter, which CreatorProfile to fetch.
     */
    where: CreatorProfileWhereUniqueInput
  }

  /**
   * CreatorProfile findUniqueOrThrow
   */
  export type CreatorProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
    /**
     * Filter, which CreatorProfile to fetch.
     */
    where: CreatorProfileWhereUniqueInput
  }

  /**
   * CreatorProfile findFirst
   */
  export type CreatorProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
    /**
     * Filter, which CreatorProfile to fetch.
     */
    where?: CreatorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorProfiles to fetch.
     */
    orderBy?: CreatorProfileOrderByWithRelationInput | CreatorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatorProfiles.
     */
    cursor?: CreatorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatorProfiles.
     */
    distinct?: CreatorProfileScalarFieldEnum | CreatorProfileScalarFieldEnum[]
  }

  /**
   * CreatorProfile findFirstOrThrow
   */
  export type CreatorProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
    /**
     * Filter, which CreatorProfile to fetch.
     */
    where?: CreatorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorProfiles to fetch.
     */
    orderBy?: CreatorProfileOrderByWithRelationInput | CreatorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatorProfiles.
     */
    cursor?: CreatorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatorProfiles.
     */
    distinct?: CreatorProfileScalarFieldEnum | CreatorProfileScalarFieldEnum[]
  }

  /**
   * CreatorProfile findMany
   */
  export type CreatorProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
    /**
     * Filter, which CreatorProfiles to fetch.
     */
    where?: CreatorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorProfiles to fetch.
     */
    orderBy?: CreatorProfileOrderByWithRelationInput | CreatorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatorProfiles.
     */
    cursor?: CreatorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorProfiles.
     */
    skip?: number
    distinct?: CreatorProfileScalarFieldEnum | CreatorProfileScalarFieldEnum[]
  }

  /**
   * CreatorProfile create
   */
  export type CreatorProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a CreatorProfile.
     */
    data: XOR<CreatorProfileCreateInput, CreatorProfileUncheckedCreateInput>
  }

  /**
   * CreatorProfile createMany
   */
  export type CreatorProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreatorProfiles.
     */
    data: CreatorProfileCreateManyInput | CreatorProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatorProfile createManyAndReturn
   */
  export type CreatorProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * The data used to create many CreatorProfiles.
     */
    data: CreatorProfileCreateManyInput | CreatorProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatorProfile update
   */
  export type CreatorProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a CreatorProfile.
     */
    data: XOR<CreatorProfileUpdateInput, CreatorProfileUncheckedUpdateInput>
    /**
     * Choose, which CreatorProfile to update.
     */
    where: CreatorProfileWhereUniqueInput
  }

  /**
   * CreatorProfile updateMany
   */
  export type CreatorProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreatorProfiles.
     */
    data: XOR<CreatorProfileUpdateManyMutationInput, CreatorProfileUncheckedUpdateManyInput>
    /**
     * Filter which CreatorProfiles to update
     */
    where?: CreatorProfileWhereInput
    /**
     * Limit how many CreatorProfiles to update.
     */
    limit?: number
  }

  /**
   * CreatorProfile updateManyAndReturn
   */
  export type CreatorProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * The data used to update CreatorProfiles.
     */
    data: XOR<CreatorProfileUpdateManyMutationInput, CreatorProfileUncheckedUpdateManyInput>
    /**
     * Filter which CreatorProfiles to update
     */
    where?: CreatorProfileWhereInput
    /**
     * Limit how many CreatorProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatorProfile upsert
   */
  export type CreatorProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the CreatorProfile to update in case it exists.
     */
    where: CreatorProfileWhereUniqueInput
    /**
     * In case the CreatorProfile found by the `where` argument doesn't exist, create a new CreatorProfile with this data.
     */
    create: XOR<CreatorProfileCreateInput, CreatorProfileUncheckedCreateInput>
    /**
     * In case the CreatorProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatorProfileUpdateInput, CreatorProfileUncheckedUpdateInput>
  }

  /**
   * CreatorProfile delete
   */
  export type CreatorProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
    /**
     * Filter which CreatorProfile to delete.
     */
    where: CreatorProfileWhereUniqueInput
  }

  /**
   * CreatorProfile deleteMany
   */
  export type CreatorProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatorProfiles to delete
     */
    where?: CreatorProfileWhereInput
    /**
     * Limit how many CreatorProfiles to delete.
     */
    limit?: number
  }

  /**
   * CreatorProfile.lastReviewer
   */
  export type CreatorProfile$lastReviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CreatorProfile.storiesSubmitted
   */
  export type CreatorProfile$storiesSubmittedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    where?: TwineStoryWhereInput
    orderBy?: TwineStoryOrderByWithRelationInput | TwineStoryOrderByWithRelationInput[]
    cursor?: TwineStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwineStoryScalarFieldEnum | TwineStoryScalarFieldEnum[]
  }

  /**
   * CreatorProfile without action
   */
  export type CreatorProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    token: string | null
    kind: $Enums.SessionKind | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    token: string | null
    kind: $Enums.SessionKind | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    token: number
    kind: number
    userId: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    token?: true
    kind?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    token?: true
    kind?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    token?: true
    kind?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    token: string
    kind: $Enums.SessionKind
    userId: string | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    kind?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserSession$userArgs<ExtArgs>
    journeys?: boolean | UserSession$journeysArgs<ExtArgs>
    storyPlays?: boolean | UserSession$storyPlaysArgs<ExtArgs>
    achievements?: boolean | UserSession$achievementsArgs<ExtArgs>
    storyInteractions?: boolean | UserSession$storyInteractionsArgs<ExtArgs>
    _count?: boolean | UserSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    kind?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserSession$userArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    kind?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserSession$userArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    token?: boolean
    kind?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "kind" | "userId" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserSession$userArgs<ExtArgs>
    journeys?: boolean | UserSession$journeysArgs<ExtArgs>
    storyPlays?: boolean | UserSession$storyPlaysArgs<ExtArgs>
    achievements?: boolean | UserSession$achievementsArgs<ExtArgs>
    storyInteractions?: boolean | UserSession$storyInteractionsArgs<ExtArgs>
    _count?: boolean | UserSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserSession$userArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserSession$userArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      journeys: Prisma.$JourneyProgressPayload<ExtArgs>[]
      storyPlays: Prisma.$StoryPlaySessionPayload<ExtArgs>[]
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      storyInteractions: Prisma.$StoryInteractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      kind: $Enums.SessionKind
      userId: string | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserSession$userArgs<ExtArgs> = {}>(args?: Subset<T, UserSession$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    journeys<T extends UserSession$journeysArgs<ExtArgs> = {}>(args?: Subset<T, UserSession$journeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storyPlays<T extends UserSession$storyPlaysArgs<ExtArgs> = {}>(args?: Subset<T, UserSession$storyPlaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends UserSession$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, UserSession$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storyInteractions<T extends UserSession$storyInteractionsArgs<ExtArgs> = {}>(args?: Subset<T, UserSession$storyInteractionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly token: FieldRef<"UserSession", 'String'>
    readonly kind: FieldRef<"UserSession", 'SessionKind'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession.user
   */
  export type UserSession$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserSession.journeys
   */
  export type UserSession$journeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    where?: JourneyProgressWhereInput
    orderBy?: JourneyProgressOrderByWithRelationInput | JourneyProgressOrderByWithRelationInput[]
    cursor?: JourneyProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JourneyProgressScalarFieldEnum | JourneyProgressScalarFieldEnum[]
  }

  /**
   * UserSession.storyPlays
   */
  export type UserSession$storyPlaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    where?: StoryPlaySessionWhereInput
    orderBy?: StoryPlaySessionOrderByWithRelationInput | StoryPlaySessionOrderByWithRelationInput[]
    cursor?: StoryPlaySessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryPlaySessionScalarFieldEnum | StoryPlaySessionScalarFieldEnum[]
  }

  /**
   * UserSession.achievements
   */
  export type UserSession$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserSession.storyInteractions
   */
  export type UserSession$storyInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    where?: StoryInteractionWhereInput
    orderBy?: StoryInteractionOrderByWithRelationInput | StoryInteractionOrderByWithRelationInput[]
    cursor?: StoryInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryInteractionScalarFieldEnum | StoryInteractionScalarFieldEnum[]
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model Scenario
   */

  export type AggregateScenario = {
    _count: ScenarioCountAggregateOutputType | null
    _avg: ScenarioAvgAggregateOutputType | null
    _sum: ScenarioSumAggregateOutputType | null
    _min: ScenarioMinAggregateOutputType | null
    _max: ScenarioMaxAggregateOutputType | null
  }

  export type ScenarioAvgAggregateOutputType = {
    estimatedMinutes: number | null
  }

  export type ScenarioSumAggregateOutputType = {
    estimatedMinutes: number | null
  }

  export type ScenarioMinAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    issueTag: string | null
    difficulty: string | null
    estimatedMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScenarioMaxAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    issueTag: string | null
    difficulty: string | null
    estimatedMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScenarioCountAggregateOutputType = {
    id: number
    title: number
    summary: number
    issueTag: number
    difficulty: number
    estimatedMinutes: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScenarioAvgAggregateInputType = {
    estimatedMinutes?: true
  }

  export type ScenarioSumAggregateInputType = {
    estimatedMinutes?: true
  }

  export type ScenarioMinAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    issueTag?: true
    difficulty?: true
    estimatedMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScenarioMaxAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    issueTag?: true
    difficulty?: true
    estimatedMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScenarioCountAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    issueTag?: true
    difficulty?: true
    estimatedMinutes?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScenarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scenario to aggregate.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Scenarios
    **/
    _count?: true | ScenarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScenarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScenarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScenarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScenarioMaxAggregateInputType
  }

  export type GetScenarioAggregateType<T extends ScenarioAggregateArgs> = {
        [P in keyof T & keyof AggregateScenario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScenario[P]>
      : GetScalarType<T[P], AggregateScenario[P]>
  }




  export type ScenarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithAggregationInput | ScenarioOrderByWithAggregationInput[]
    by: ScenarioScalarFieldEnum[] | ScenarioScalarFieldEnum
    having?: ScenarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScenarioCountAggregateInputType | true
    _avg?: ScenarioAvgAggregateInputType
    _sum?: ScenarioSumAggregateInputType
    _min?: ScenarioMinAggregateInputType
    _max?: ScenarioMaxAggregateInputType
  }

  export type ScenarioGroupByOutputType = {
    id: string
    title: string
    summary: string | null
    issueTag: string | null
    difficulty: string | null
    estimatedMinutes: number | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ScenarioCountAggregateOutputType | null
    _avg: ScenarioAvgAggregateOutputType | null
    _sum: ScenarioSumAggregateOutputType | null
    _min: ScenarioMinAggregateOutputType | null
    _max: ScenarioMaxAggregateOutputType | null
  }

  type GetScenarioGroupByPayload<T extends ScenarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScenarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScenarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScenarioGroupByOutputType[P]>
            : GetScalarType<T[P], ScenarioGroupByOutputType[P]>
        }
      >
    >


  export type ScenarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    issueTag?: boolean
    difficulty?: boolean
    estimatedMinutes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    journeys?: boolean | Scenario$journeysArgs<ExtArgs>
    _count?: boolean | ScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    issueTag?: boolean
    difficulty?: boolean
    estimatedMinutes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    issueTag?: boolean
    difficulty?: boolean
    estimatedMinutes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectScalar = {
    id?: boolean
    title?: boolean
    summary?: boolean
    issueTag?: boolean
    difficulty?: boolean
    estimatedMinutes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScenarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "summary" | "issueTag" | "difficulty" | "estimatedMinutes" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["scenario"]>
  export type ScenarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journeys?: boolean | Scenario$journeysArgs<ExtArgs>
    _count?: boolean | ScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScenarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ScenarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ScenarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Scenario"
    objects: {
      journeys: Prisma.$JourneyProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      summary: string | null
      issueTag: string | null
      difficulty: string | null
      estimatedMinutes: number | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scenario"]>
    composites: {}
  }

  type ScenarioGetPayload<S extends boolean | null | undefined | ScenarioDefaultArgs> = $Result.GetResult<Prisma.$ScenarioPayload, S>

  type ScenarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScenarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScenarioCountAggregateInputType | true
    }

  export interface ScenarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Scenario'], meta: { name: 'Scenario' } }
    /**
     * Find zero or one Scenario that matches the filter.
     * @param {ScenarioFindUniqueArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScenarioFindUniqueArgs>(args: SelectSubset<T, ScenarioFindUniqueArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Scenario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScenarioFindUniqueOrThrowArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScenarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ScenarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scenario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindFirstArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScenarioFindFirstArgs>(args?: SelectSubset<T, ScenarioFindFirstArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scenario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindFirstOrThrowArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScenarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ScenarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Scenarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scenarios
     * const scenarios = await prisma.scenario.findMany()
     * 
     * // Get first 10 Scenarios
     * const scenarios = await prisma.scenario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scenarioWithIdOnly = await prisma.scenario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScenarioFindManyArgs>(args?: SelectSubset<T, ScenarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Scenario.
     * @param {ScenarioCreateArgs} args - Arguments to create a Scenario.
     * @example
     * // Create one Scenario
     * const Scenario = await prisma.scenario.create({
     *   data: {
     *     // ... data to create a Scenario
     *   }
     * })
     * 
     */
    create<T extends ScenarioCreateArgs>(args: SelectSubset<T, ScenarioCreateArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Scenarios.
     * @param {ScenarioCreateManyArgs} args - Arguments to create many Scenarios.
     * @example
     * // Create many Scenarios
     * const scenario = await prisma.scenario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScenarioCreateManyArgs>(args?: SelectSubset<T, ScenarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Scenarios and returns the data saved in the database.
     * @param {ScenarioCreateManyAndReturnArgs} args - Arguments to create many Scenarios.
     * @example
     * // Create many Scenarios
     * const scenario = await prisma.scenario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Scenarios and only return the `id`
     * const scenarioWithIdOnly = await prisma.scenario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScenarioCreateManyAndReturnArgs>(args?: SelectSubset<T, ScenarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Scenario.
     * @param {ScenarioDeleteArgs} args - Arguments to delete one Scenario.
     * @example
     * // Delete one Scenario
     * const Scenario = await prisma.scenario.delete({
     *   where: {
     *     // ... filter to delete one Scenario
     *   }
     * })
     * 
     */
    delete<T extends ScenarioDeleteArgs>(args: SelectSubset<T, ScenarioDeleteArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Scenario.
     * @param {ScenarioUpdateArgs} args - Arguments to update one Scenario.
     * @example
     * // Update one Scenario
     * const scenario = await prisma.scenario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScenarioUpdateArgs>(args: SelectSubset<T, ScenarioUpdateArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Scenarios.
     * @param {ScenarioDeleteManyArgs} args - Arguments to filter Scenarios to delete.
     * @example
     * // Delete a few Scenarios
     * const { count } = await prisma.scenario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScenarioDeleteManyArgs>(args?: SelectSubset<T, ScenarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scenarios
     * const scenario = await prisma.scenario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScenarioUpdateManyArgs>(args: SelectSubset<T, ScenarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scenarios and returns the data updated in the database.
     * @param {ScenarioUpdateManyAndReturnArgs} args - Arguments to update many Scenarios.
     * @example
     * // Update many Scenarios
     * const scenario = await prisma.scenario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Scenarios and only return the `id`
     * const scenarioWithIdOnly = await prisma.scenario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScenarioUpdateManyAndReturnArgs>(args: SelectSubset<T, ScenarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Scenario.
     * @param {ScenarioUpsertArgs} args - Arguments to update or create a Scenario.
     * @example
     * // Update or create a Scenario
     * const scenario = await prisma.scenario.upsert({
     *   create: {
     *     // ... data to create a Scenario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scenario we want to update
     *   }
     * })
     */
    upsert<T extends ScenarioUpsertArgs>(args: SelectSubset<T, ScenarioUpsertArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Scenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioCountArgs} args - Arguments to filter Scenarios to count.
     * @example
     * // Count the number of Scenarios
     * const count = await prisma.scenario.count({
     *   where: {
     *     // ... the filter for the Scenarios we want to count
     *   }
     * })
    **/
    count<T extends ScenarioCountArgs>(
      args?: Subset<T, ScenarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScenarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScenarioAggregateArgs>(args: Subset<T, ScenarioAggregateArgs>): Prisma.PrismaPromise<GetScenarioAggregateType<T>>

    /**
     * Group by Scenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScenarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScenarioGroupByArgs['orderBy'] }
        : { orderBy?: ScenarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScenarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScenarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Scenario model
   */
  readonly fields: ScenarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Scenario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScenarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journeys<T extends Scenario$journeysArgs<ExtArgs> = {}>(args?: Subset<T, Scenario$journeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Scenario model
   */
  interface ScenarioFieldRefs {
    readonly id: FieldRef<"Scenario", 'String'>
    readonly title: FieldRef<"Scenario", 'String'>
    readonly summary: FieldRef<"Scenario", 'String'>
    readonly issueTag: FieldRef<"Scenario", 'String'>
    readonly difficulty: FieldRef<"Scenario", 'String'>
    readonly estimatedMinutes: FieldRef<"Scenario", 'Int'>
    readonly metadata: FieldRef<"Scenario", 'Json'>
    readonly createdAt: FieldRef<"Scenario", 'DateTime'>
    readonly updatedAt: FieldRef<"Scenario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Scenario findUnique
   */
  export type ScenarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario findUniqueOrThrow
   */
  export type ScenarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario findFirst
   */
  export type ScenarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scenarios.
     */
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario findFirstOrThrow
   */
  export type ScenarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scenarios.
     */
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario findMany
   */
  export type ScenarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenarios to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario create
   */
  export type ScenarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Scenario.
     */
    data: XOR<ScenarioCreateInput, ScenarioUncheckedCreateInput>
  }

  /**
   * Scenario createMany
   */
  export type ScenarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Scenarios.
     */
    data: ScenarioCreateManyInput | ScenarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Scenario createManyAndReturn
   */
  export type ScenarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * The data used to create many Scenarios.
     */
    data: ScenarioCreateManyInput | ScenarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Scenario update
   */
  export type ScenarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Scenario.
     */
    data: XOR<ScenarioUpdateInput, ScenarioUncheckedUpdateInput>
    /**
     * Choose, which Scenario to update.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario updateMany
   */
  export type ScenarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Scenarios.
     */
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyInput>
    /**
     * Filter which Scenarios to update
     */
    where?: ScenarioWhereInput
    /**
     * Limit how many Scenarios to update.
     */
    limit?: number
  }

  /**
   * Scenario updateManyAndReturn
   */
  export type ScenarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * The data used to update Scenarios.
     */
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyInput>
    /**
     * Filter which Scenarios to update
     */
    where?: ScenarioWhereInput
    /**
     * Limit how many Scenarios to update.
     */
    limit?: number
  }

  /**
   * Scenario upsert
   */
  export type ScenarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Scenario to update in case it exists.
     */
    where: ScenarioWhereUniqueInput
    /**
     * In case the Scenario found by the `where` argument doesn't exist, create a new Scenario with this data.
     */
    create: XOR<ScenarioCreateInput, ScenarioUncheckedCreateInput>
    /**
     * In case the Scenario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScenarioUpdateInput, ScenarioUncheckedUpdateInput>
  }

  /**
   * Scenario delete
   */
  export type ScenarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter which Scenario to delete.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario deleteMany
   */
  export type ScenarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scenarios to delete
     */
    where?: ScenarioWhereInput
    /**
     * Limit how many Scenarios to delete.
     */
    limit?: number
  }

  /**
   * Scenario.journeys
   */
  export type Scenario$journeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    where?: JourneyProgressWhereInput
    orderBy?: JourneyProgressOrderByWithRelationInput | JourneyProgressOrderByWithRelationInput[]
    cursor?: JourneyProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JourneyProgressScalarFieldEnum | JourneyProgressScalarFieldEnum[]
  }

  /**
   * Scenario without action
   */
  export type ScenarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
  }


  /**
   * Model JourneyProgress
   */

  export type AggregateJourneyProgress = {
    _count: JourneyProgressCountAggregateOutputType | null
    _min: JourneyProgressMinAggregateOutputType | null
    _max: JourneyProgressMaxAggregateOutputType | null
  }

  export type JourneyProgressMinAggregateOutputType = {
    id: string | null
    scenarioId: string | null
    userId: string | null
    sessionId: string | null
    status: $Enums.JourneyStatus | null
    currentNode: string | null
    notes: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type JourneyProgressMaxAggregateOutputType = {
    id: string | null
    scenarioId: string | null
    userId: string | null
    sessionId: string | null
    status: $Enums.JourneyStatus | null
    currentNode: string | null
    notes: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type JourneyProgressCountAggregateOutputType = {
    id: number
    scenarioId: number
    userId: number
    sessionId: number
    status: number
    currentNode: number
    checkpoints: number
    resources: number
    notes: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type JourneyProgressMinAggregateInputType = {
    id?: true
    scenarioId?: true
    userId?: true
    sessionId?: true
    status?: true
    currentNode?: true
    notes?: true
    startedAt?: true
    completedAt?: true
  }

  export type JourneyProgressMaxAggregateInputType = {
    id?: true
    scenarioId?: true
    userId?: true
    sessionId?: true
    status?: true
    currentNode?: true
    notes?: true
    startedAt?: true
    completedAt?: true
  }

  export type JourneyProgressCountAggregateInputType = {
    id?: true
    scenarioId?: true
    userId?: true
    sessionId?: true
    status?: true
    currentNode?: true
    checkpoints?: true
    resources?: true
    notes?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type JourneyProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JourneyProgress to aggregate.
     */
    where?: JourneyProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JourneyProgresses to fetch.
     */
    orderBy?: JourneyProgressOrderByWithRelationInput | JourneyProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JourneyProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JourneyProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JourneyProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JourneyProgresses
    **/
    _count?: true | JourneyProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JourneyProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JourneyProgressMaxAggregateInputType
  }

  export type GetJourneyProgressAggregateType<T extends JourneyProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateJourneyProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJourneyProgress[P]>
      : GetScalarType<T[P], AggregateJourneyProgress[P]>
  }




  export type JourneyProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JourneyProgressWhereInput
    orderBy?: JourneyProgressOrderByWithAggregationInput | JourneyProgressOrderByWithAggregationInput[]
    by: JourneyProgressScalarFieldEnum[] | JourneyProgressScalarFieldEnum
    having?: JourneyProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JourneyProgressCountAggregateInputType | true
    _min?: JourneyProgressMinAggregateInputType
    _max?: JourneyProgressMaxAggregateInputType
  }

  export type JourneyProgressGroupByOutputType = {
    id: string
    scenarioId: string
    userId: string | null
    sessionId: string | null
    status: $Enums.JourneyStatus
    currentNode: string | null
    checkpoints: JsonValue | null
    resources: JsonValue | null
    notes: string | null
    startedAt: Date
    completedAt: Date | null
    _count: JourneyProgressCountAggregateOutputType | null
    _min: JourneyProgressMinAggregateOutputType | null
    _max: JourneyProgressMaxAggregateOutputType | null
  }

  type GetJourneyProgressGroupByPayload<T extends JourneyProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JourneyProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JourneyProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JourneyProgressGroupByOutputType[P]>
            : GetScalarType<T[P], JourneyProgressGroupByOutputType[P]>
        }
      >
    >


  export type JourneyProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scenarioId?: boolean
    userId?: boolean
    sessionId?: boolean
    status?: boolean
    currentNode?: boolean
    checkpoints?: boolean
    resources?: boolean
    notes?: boolean
    startedAt?: boolean
    completedAt?: boolean
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
    user?: boolean | JourneyProgress$userArgs<ExtArgs>
    session?: boolean | JourneyProgress$sessionArgs<ExtArgs>
    achievements?: boolean | JourneyProgress$achievementsArgs<ExtArgs>
    _count?: boolean | JourneyProgressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journeyProgress"]>

  export type JourneyProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scenarioId?: boolean
    userId?: boolean
    sessionId?: boolean
    status?: boolean
    currentNode?: boolean
    checkpoints?: boolean
    resources?: boolean
    notes?: boolean
    startedAt?: boolean
    completedAt?: boolean
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
    user?: boolean | JourneyProgress$userArgs<ExtArgs>
    session?: boolean | JourneyProgress$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["journeyProgress"]>

  export type JourneyProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scenarioId?: boolean
    userId?: boolean
    sessionId?: boolean
    status?: boolean
    currentNode?: boolean
    checkpoints?: boolean
    resources?: boolean
    notes?: boolean
    startedAt?: boolean
    completedAt?: boolean
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
    user?: boolean | JourneyProgress$userArgs<ExtArgs>
    session?: boolean | JourneyProgress$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["journeyProgress"]>

  export type JourneyProgressSelectScalar = {
    id?: boolean
    scenarioId?: boolean
    userId?: boolean
    sessionId?: boolean
    status?: boolean
    currentNode?: boolean
    checkpoints?: boolean
    resources?: boolean
    notes?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type JourneyProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scenarioId" | "userId" | "sessionId" | "status" | "currentNode" | "checkpoints" | "resources" | "notes" | "startedAt" | "completedAt", ExtArgs["result"]["journeyProgress"]>
  export type JourneyProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
    user?: boolean | JourneyProgress$userArgs<ExtArgs>
    session?: boolean | JourneyProgress$sessionArgs<ExtArgs>
    achievements?: boolean | JourneyProgress$achievementsArgs<ExtArgs>
    _count?: boolean | JourneyProgressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JourneyProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
    user?: boolean | JourneyProgress$userArgs<ExtArgs>
    session?: boolean | JourneyProgress$sessionArgs<ExtArgs>
  }
  export type JourneyProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
    user?: boolean | JourneyProgress$userArgs<ExtArgs>
    session?: boolean | JourneyProgress$sessionArgs<ExtArgs>
  }

  export type $JourneyProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JourneyProgress"
    objects: {
      scenario: Prisma.$ScenarioPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      session: Prisma.$UserSessionPayload<ExtArgs> | null
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scenarioId: string
      userId: string | null
      sessionId: string | null
      status: $Enums.JourneyStatus
      currentNode: string | null
      checkpoints: Prisma.JsonValue | null
      resources: Prisma.JsonValue | null
      notes: string | null
      startedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["journeyProgress"]>
    composites: {}
  }

  type JourneyProgressGetPayload<S extends boolean | null | undefined | JourneyProgressDefaultArgs> = $Result.GetResult<Prisma.$JourneyProgressPayload, S>

  type JourneyProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JourneyProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JourneyProgressCountAggregateInputType | true
    }

  export interface JourneyProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JourneyProgress'], meta: { name: 'JourneyProgress' } }
    /**
     * Find zero or one JourneyProgress that matches the filter.
     * @param {JourneyProgressFindUniqueArgs} args - Arguments to find a JourneyProgress
     * @example
     * // Get one JourneyProgress
     * const journeyProgress = await prisma.journeyProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JourneyProgressFindUniqueArgs>(args: SelectSubset<T, JourneyProgressFindUniqueArgs<ExtArgs>>): Prisma__JourneyProgressClient<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JourneyProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JourneyProgressFindUniqueOrThrowArgs} args - Arguments to find a JourneyProgress
     * @example
     * // Get one JourneyProgress
     * const journeyProgress = await prisma.journeyProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JourneyProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, JourneyProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JourneyProgressClient<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JourneyProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyProgressFindFirstArgs} args - Arguments to find a JourneyProgress
     * @example
     * // Get one JourneyProgress
     * const journeyProgress = await prisma.journeyProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JourneyProgressFindFirstArgs>(args?: SelectSubset<T, JourneyProgressFindFirstArgs<ExtArgs>>): Prisma__JourneyProgressClient<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JourneyProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyProgressFindFirstOrThrowArgs} args - Arguments to find a JourneyProgress
     * @example
     * // Get one JourneyProgress
     * const journeyProgress = await prisma.journeyProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JourneyProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, JourneyProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__JourneyProgressClient<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JourneyProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JourneyProgresses
     * const journeyProgresses = await prisma.journeyProgress.findMany()
     * 
     * // Get first 10 JourneyProgresses
     * const journeyProgresses = await prisma.journeyProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journeyProgressWithIdOnly = await prisma.journeyProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JourneyProgressFindManyArgs>(args?: SelectSubset<T, JourneyProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JourneyProgress.
     * @param {JourneyProgressCreateArgs} args - Arguments to create a JourneyProgress.
     * @example
     * // Create one JourneyProgress
     * const JourneyProgress = await prisma.journeyProgress.create({
     *   data: {
     *     // ... data to create a JourneyProgress
     *   }
     * })
     * 
     */
    create<T extends JourneyProgressCreateArgs>(args: SelectSubset<T, JourneyProgressCreateArgs<ExtArgs>>): Prisma__JourneyProgressClient<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JourneyProgresses.
     * @param {JourneyProgressCreateManyArgs} args - Arguments to create many JourneyProgresses.
     * @example
     * // Create many JourneyProgresses
     * const journeyProgress = await prisma.journeyProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JourneyProgressCreateManyArgs>(args?: SelectSubset<T, JourneyProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JourneyProgresses and returns the data saved in the database.
     * @param {JourneyProgressCreateManyAndReturnArgs} args - Arguments to create many JourneyProgresses.
     * @example
     * // Create many JourneyProgresses
     * const journeyProgress = await prisma.journeyProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JourneyProgresses and only return the `id`
     * const journeyProgressWithIdOnly = await prisma.journeyProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JourneyProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, JourneyProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JourneyProgress.
     * @param {JourneyProgressDeleteArgs} args - Arguments to delete one JourneyProgress.
     * @example
     * // Delete one JourneyProgress
     * const JourneyProgress = await prisma.journeyProgress.delete({
     *   where: {
     *     // ... filter to delete one JourneyProgress
     *   }
     * })
     * 
     */
    delete<T extends JourneyProgressDeleteArgs>(args: SelectSubset<T, JourneyProgressDeleteArgs<ExtArgs>>): Prisma__JourneyProgressClient<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JourneyProgress.
     * @param {JourneyProgressUpdateArgs} args - Arguments to update one JourneyProgress.
     * @example
     * // Update one JourneyProgress
     * const journeyProgress = await prisma.journeyProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JourneyProgressUpdateArgs>(args: SelectSubset<T, JourneyProgressUpdateArgs<ExtArgs>>): Prisma__JourneyProgressClient<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JourneyProgresses.
     * @param {JourneyProgressDeleteManyArgs} args - Arguments to filter JourneyProgresses to delete.
     * @example
     * // Delete a few JourneyProgresses
     * const { count } = await prisma.journeyProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JourneyProgressDeleteManyArgs>(args?: SelectSubset<T, JourneyProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JourneyProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JourneyProgresses
     * const journeyProgress = await prisma.journeyProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JourneyProgressUpdateManyArgs>(args: SelectSubset<T, JourneyProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JourneyProgresses and returns the data updated in the database.
     * @param {JourneyProgressUpdateManyAndReturnArgs} args - Arguments to update many JourneyProgresses.
     * @example
     * // Update many JourneyProgresses
     * const journeyProgress = await prisma.journeyProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JourneyProgresses and only return the `id`
     * const journeyProgressWithIdOnly = await prisma.journeyProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JourneyProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, JourneyProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JourneyProgress.
     * @param {JourneyProgressUpsertArgs} args - Arguments to update or create a JourneyProgress.
     * @example
     * // Update or create a JourneyProgress
     * const journeyProgress = await prisma.journeyProgress.upsert({
     *   create: {
     *     // ... data to create a JourneyProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JourneyProgress we want to update
     *   }
     * })
     */
    upsert<T extends JourneyProgressUpsertArgs>(args: SelectSubset<T, JourneyProgressUpsertArgs<ExtArgs>>): Prisma__JourneyProgressClient<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JourneyProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyProgressCountArgs} args - Arguments to filter JourneyProgresses to count.
     * @example
     * // Count the number of JourneyProgresses
     * const count = await prisma.journeyProgress.count({
     *   where: {
     *     // ... the filter for the JourneyProgresses we want to count
     *   }
     * })
    **/
    count<T extends JourneyProgressCountArgs>(
      args?: Subset<T, JourneyProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JourneyProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JourneyProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JourneyProgressAggregateArgs>(args: Subset<T, JourneyProgressAggregateArgs>): Prisma.PrismaPromise<GetJourneyProgressAggregateType<T>>

    /**
     * Group by JourneyProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JourneyProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JourneyProgressGroupByArgs['orderBy'] }
        : { orderBy?: JourneyProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JourneyProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJourneyProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JourneyProgress model
   */
  readonly fields: JourneyProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JourneyProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JourneyProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scenario<T extends ScenarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScenarioDefaultArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends JourneyProgress$userArgs<ExtArgs> = {}>(args?: Subset<T, JourneyProgress$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    session<T extends JourneyProgress$sessionArgs<ExtArgs> = {}>(args?: Subset<T, JourneyProgress$sessionArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    achievements<T extends JourneyProgress$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, JourneyProgress$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JourneyProgress model
   */
  interface JourneyProgressFieldRefs {
    readonly id: FieldRef<"JourneyProgress", 'String'>
    readonly scenarioId: FieldRef<"JourneyProgress", 'String'>
    readonly userId: FieldRef<"JourneyProgress", 'String'>
    readonly sessionId: FieldRef<"JourneyProgress", 'String'>
    readonly status: FieldRef<"JourneyProgress", 'JourneyStatus'>
    readonly currentNode: FieldRef<"JourneyProgress", 'String'>
    readonly checkpoints: FieldRef<"JourneyProgress", 'Json'>
    readonly resources: FieldRef<"JourneyProgress", 'Json'>
    readonly notes: FieldRef<"JourneyProgress", 'String'>
    readonly startedAt: FieldRef<"JourneyProgress", 'DateTime'>
    readonly completedAt: FieldRef<"JourneyProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JourneyProgress findUnique
   */
  export type JourneyProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    /**
     * Filter, which JourneyProgress to fetch.
     */
    where: JourneyProgressWhereUniqueInput
  }

  /**
   * JourneyProgress findUniqueOrThrow
   */
  export type JourneyProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    /**
     * Filter, which JourneyProgress to fetch.
     */
    where: JourneyProgressWhereUniqueInput
  }

  /**
   * JourneyProgress findFirst
   */
  export type JourneyProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    /**
     * Filter, which JourneyProgress to fetch.
     */
    where?: JourneyProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JourneyProgresses to fetch.
     */
    orderBy?: JourneyProgressOrderByWithRelationInput | JourneyProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JourneyProgresses.
     */
    cursor?: JourneyProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JourneyProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JourneyProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JourneyProgresses.
     */
    distinct?: JourneyProgressScalarFieldEnum | JourneyProgressScalarFieldEnum[]
  }

  /**
   * JourneyProgress findFirstOrThrow
   */
  export type JourneyProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    /**
     * Filter, which JourneyProgress to fetch.
     */
    where?: JourneyProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JourneyProgresses to fetch.
     */
    orderBy?: JourneyProgressOrderByWithRelationInput | JourneyProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JourneyProgresses.
     */
    cursor?: JourneyProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JourneyProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JourneyProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JourneyProgresses.
     */
    distinct?: JourneyProgressScalarFieldEnum | JourneyProgressScalarFieldEnum[]
  }

  /**
   * JourneyProgress findMany
   */
  export type JourneyProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    /**
     * Filter, which JourneyProgresses to fetch.
     */
    where?: JourneyProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JourneyProgresses to fetch.
     */
    orderBy?: JourneyProgressOrderByWithRelationInput | JourneyProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JourneyProgresses.
     */
    cursor?: JourneyProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JourneyProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JourneyProgresses.
     */
    skip?: number
    distinct?: JourneyProgressScalarFieldEnum | JourneyProgressScalarFieldEnum[]
  }

  /**
   * JourneyProgress create
   */
  export type JourneyProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a JourneyProgress.
     */
    data: XOR<JourneyProgressCreateInput, JourneyProgressUncheckedCreateInput>
  }

  /**
   * JourneyProgress createMany
   */
  export type JourneyProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JourneyProgresses.
     */
    data: JourneyProgressCreateManyInput | JourneyProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JourneyProgress createManyAndReturn
   */
  export type JourneyProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * The data used to create many JourneyProgresses.
     */
    data: JourneyProgressCreateManyInput | JourneyProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JourneyProgress update
   */
  export type JourneyProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a JourneyProgress.
     */
    data: XOR<JourneyProgressUpdateInput, JourneyProgressUncheckedUpdateInput>
    /**
     * Choose, which JourneyProgress to update.
     */
    where: JourneyProgressWhereUniqueInput
  }

  /**
   * JourneyProgress updateMany
   */
  export type JourneyProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JourneyProgresses.
     */
    data: XOR<JourneyProgressUpdateManyMutationInput, JourneyProgressUncheckedUpdateManyInput>
    /**
     * Filter which JourneyProgresses to update
     */
    where?: JourneyProgressWhereInput
    /**
     * Limit how many JourneyProgresses to update.
     */
    limit?: number
  }

  /**
   * JourneyProgress updateManyAndReturn
   */
  export type JourneyProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * The data used to update JourneyProgresses.
     */
    data: XOR<JourneyProgressUpdateManyMutationInput, JourneyProgressUncheckedUpdateManyInput>
    /**
     * Filter which JourneyProgresses to update
     */
    where?: JourneyProgressWhereInput
    /**
     * Limit how many JourneyProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JourneyProgress upsert
   */
  export type JourneyProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the JourneyProgress to update in case it exists.
     */
    where: JourneyProgressWhereUniqueInput
    /**
     * In case the JourneyProgress found by the `where` argument doesn't exist, create a new JourneyProgress with this data.
     */
    create: XOR<JourneyProgressCreateInput, JourneyProgressUncheckedCreateInput>
    /**
     * In case the JourneyProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JourneyProgressUpdateInput, JourneyProgressUncheckedUpdateInput>
  }

  /**
   * JourneyProgress delete
   */
  export type JourneyProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    /**
     * Filter which JourneyProgress to delete.
     */
    where: JourneyProgressWhereUniqueInput
  }

  /**
   * JourneyProgress deleteMany
   */
  export type JourneyProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JourneyProgresses to delete
     */
    where?: JourneyProgressWhereInput
    /**
     * Limit how many JourneyProgresses to delete.
     */
    limit?: number
  }

  /**
   * JourneyProgress.user
   */
  export type JourneyProgress$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * JourneyProgress.session
   */
  export type JourneyProgress$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
  }

  /**
   * JourneyProgress.achievements
   */
  export type JourneyProgress$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * JourneyProgress without action
   */
  export type JourneyProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    points: number | null
  }

  export type AchievementSumAggregateOutputType = {
    points: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    description: string | null
    points: number | null
    icon: string | null
    unlockHint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    description: string | null
    points: number | null
    icon: string | null
    unlockHint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    code: number
    title: number
    description: number
    points: number
    icon: number
    unlockHint: number
    unlockLogic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    points?: true
  }

  export type AchievementSumAggregateInputType = {
    points?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    code?: true
    title?: true
    description?: true
    points?: true
    icon?: true
    unlockHint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    code?: true
    title?: true
    description?: true
    points?: true
    icon?: true
    unlockHint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    code?: true
    title?: true
    description?: true
    points?: true
    icon?: true
    unlockHint?: true
    unlockLogic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    code: string
    title: string
    description: string
    points: number
    icon: string | null
    unlockHint: string | null
    unlockLogic: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    description?: boolean
    points?: boolean
    icon?: boolean
    unlockHint?: boolean
    unlockLogic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userAwards?: boolean | Achievement$userAwardsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    description?: boolean
    points?: boolean
    icon?: boolean
    unlockHint?: boolean
    unlockLogic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    description?: boolean
    points?: boolean
    icon?: boolean
    unlockHint?: boolean
    unlockLogic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    code?: boolean
    title?: boolean
    description?: boolean
    points?: boolean
    icon?: boolean
    unlockHint?: boolean
    unlockLogic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "title" | "description" | "points" | "icon" | "unlockHint" | "unlockLogic" | "createdAt" | "updatedAt", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAwards?: boolean | Achievement$userAwardsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      userAwards: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      title: string
      description: string
      points: number
      icon: string | null
      unlockHint: string | null
      unlockLogic: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userAwards<T extends Achievement$userAwardsArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$userAwardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly code: FieldRef<"Achievement", 'String'>
    readonly title: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly points: FieldRef<"Achievement", 'Int'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly unlockHint: FieldRef<"Achievement", 'String'>
    readonly unlockLogic: FieldRef<"Achievement", 'Json'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
    readonly updatedAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement.userAwards
   */
  export type Achievement$userAwardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    achievementId: string | null
    userId: string | null
    sessionId: string | null
    journeyId: string | null
    unlockedAt: Date | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    achievementId: string | null
    userId: string | null
    sessionId: string | null
    journeyId: string | null
    unlockedAt: Date | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    achievementId: number
    userId: number
    sessionId: number
    journeyId: number
    unlockedAt: number
    metadata: number
    _all: number
  }


  export type UserAchievementMinAggregateInputType = {
    id?: true
    achievementId?: true
    userId?: true
    sessionId?: true
    journeyId?: true
    unlockedAt?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    achievementId?: true
    userId?: true
    sessionId?: true
    journeyId?: true
    unlockedAt?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    achievementId?: true
    userId?: true
    sessionId?: true
    journeyId?: true
    unlockedAt?: true
    metadata?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    achievementId: string
    userId: string | null
    sessionId: string | null
    journeyId: string | null
    unlockedAt: Date
    metadata: JsonValue | null
    _count: UserAchievementCountAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    achievementId?: boolean
    userId?: boolean
    sessionId?: boolean
    journeyId?: boolean
    unlockedAt?: boolean
    metadata?: boolean
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
    user?: boolean | UserAchievement$userArgs<ExtArgs>
    session?: boolean | UserAchievement$sessionArgs<ExtArgs>
    journey?: boolean | UserAchievement$journeyArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    achievementId?: boolean
    userId?: boolean
    sessionId?: boolean
    journeyId?: boolean
    unlockedAt?: boolean
    metadata?: boolean
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
    user?: boolean | UserAchievement$userArgs<ExtArgs>
    session?: boolean | UserAchievement$sessionArgs<ExtArgs>
    journey?: boolean | UserAchievement$journeyArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    achievementId?: boolean
    userId?: boolean
    sessionId?: boolean
    journeyId?: boolean
    unlockedAt?: boolean
    metadata?: boolean
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
    user?: boolean | UserAchievement$userArgs<ExtArgs>
    session?: boolean | UserAchievement$sessionArgs<ExtArgs>
    journey?: boolean | UserAchievement$journeyArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    achievementId?: boolean
    userId?: boolean
    sessionId?: boolean
    journeyId?: boolean
    unlockedAt?: boolean
    metadata?: boolean
  }

  export type UserAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "achievementId" | "userId" | "sessionId" | "journeyId" | "unlockedAt" | "metadata", ExtArgs["result"]["userAchievement"]>
  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
    user?: boolean | UserAchievement$userArgs<ExtArgs>
    session?: boolean | UserAchievement$sessionArgs<ExtArgs>
    journey?: boolean | UserAchievement$journeyArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
    user?: boolean | UserAchievement$userArgs<ExtArgs>
    session?: boolean | UserAchievement$sessionArgs<ExtArgs>
    journey?: boolean | UserAchievement$journeyArgs<ExtArgs>
  }
  export type UserAchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
    user?: boolean | UserAchievement$userArgs<ExtArgs>
    session?: boolean | UserAchievement$sessionArgs<ExtArgs>
    journey?: boolean | UserAchievement$journeyArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      achievement: Prisma.$AchievementPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      session: Prisma.$UserSessionPayload<ExtArgs> | null
      journey: Prisma.$JourneyProgressPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      achievementId: string
      userId: string | null
      sessionId: string | null
      journeyId: string | null
      unlockedAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements and returns the data updated in the database.
     * @param {UserAchievementUpdateManyAndReturnArgs} args - Arguments to update many UserAchievements.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserAchievement$userArgs<ExtArgs> = {}>(args?: Subset<T, UserAchievement$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    session<T extends UserAchievement$sessionArgs<ExtArgs> = {}>(args?: Subset<T, UserAchievement$sessionArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    journey<T extends UserAchievement$journeyArgs<ExtArgs> = {}>(args?: Subset<T, UserAchievement$journeyArgs<ExtArgs>>): Prisma__JourneyProgressClient<$Result.GetResult<Prisma.$JourneyProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly achievementId: FieldRef<"UserAchievement", 'String'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
    readonly sessionId: FieldRef<"UserAchievement", 'String'>
    readonly journeyId: FieldRef<"UserAchievement", 'String'>
    readonly unlockedAt: FieldRef<"UserAchievement", 'DateTime'>
    readonly metadata: FieldRef<"UserAchievement", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
  }

  /**
   * UserAchievement updateManyAndReturn
   */
  export type UserAchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to delete.
     */
    limit?: number
  }

  /**
   * UserAchievement.user
   */
  export type UserAchievement$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserAchievement.session
   */
  export type UserAchievement$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
  }

  /**
   * UserAchievement.journey
   */
  export type UserAchievement$journeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyProgress
     */
    select?: JourneyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JourneyProgress
     */
    omit?: JourneyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyProgressInclude<ExtArgs> | null
    where?: JourneyProgressWhereInput
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model TwineStory
   */

  export type AggregateTwineStory = {
    _count: TwineStoryCountAggregateOutputType | null
    _min: TwineStoryMinAggregateOutputType | null
    _max: TwineStoryMaxAggregateOutputType | null
  }

  export type TwineStoryMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    summary: string | null
    visibility: $Enums.StoryVisibility | null
    ownerId: string | null
    originalCreatorId: string | null
    originalCreatorProfileId: string | null
    approvedById: string | null
    ownershipStatus: $Enums.StoryOwnershipStatus | null
    submittedAt: Date | null
    transferConsentAt: Date | null
    transferConsentIp: string | null
    transferConsentUserAgent: string | null
    approvalToken: string | null
    approvalTokenExpiresAt: Date | null
    approvedAt: Date | null
    reviewComment: string | null
    creditText: string | null
    latestVersionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwineStoryMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    summary: string | null
    visibility: $Enums.StoryVisibility | null
    ownerId: string | null
    originalCreatorId: string | null
    originalCreatorProfileId: string | null
    approvedById: string | null
    ownershipStatus: $Enums.StoryOwnershipStatus | null
    submittedAt: Date | null
    transferConsentAt: Date | null
    transferConsentIp: string | null
    transferConsentUserAgent: string | null
    approvalToken: string | null
    approvalTokenExpiresAt: Date | null
    approvedAt: Date | null
    reviewComment: string | null
    creditText: string | null
    latestVersionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwineStoryCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    summary: number
    tags: number
    visibility: number
    ownerId: number
    originalCreatorId: number
    originalCreatorProfileId: number
    approvedById: number
    ownershipStatus: number
    submittedAt: number
    transferConsentAt: number
    transferConsentIp: number
    transferConsentUserAgent: number
    approvalToken: number
    approvalTokenExpiresAt: number
    approvedAt: number
    reviewComment: number
    creditText: number
    latestVersionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwineStoryMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    summary?: true
    visibility?: true
    ownerId?: true
    originalCreatorId?: true
    originalCreatorProfileId?: true
    approvedById?: true
    ownershipStatus?: true
    submittedAt?: true
    transferConsentAt?: true
    transferConsentIp?: true
    transferConsentUserAgent?: true
    approvalToken?: true
    approvalTokenExpiresAt?: true
    approvedAt?: true
    reviewComment?: true
    creditText?: true
    latestVersionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwineStoryMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    summary?: true
    visibility?: true
    ownerId?: true
    originalCreatorId?: true
    originalCreatorProfileId?: true
    approvedById?: true
    ownershipStatus?: true
    submittedAt?: true
    transferConsentAt?: true
    transferConsentIp?: true
    transferConsentUserAgent?: true
    approvalToken?: true
    approvalTokenExpiresAt?: true
    approvedAt?: true
    reviewComment?: true
    creditText?: true
    latestVersionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwineStoryCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    summary?: true
    tags?: true
    visibility?: true
    ownerId?: true
    originalCreatorId?: true
    originalCreatorProfileId?: true
    approvedById?: true
    ownershipStatus?: true
    submittedAt?: true
    transferConsentAt?: true
    transferConsentIp?: true
    transferConsentUserAgent?: true
    approvalToken?: true
    approvalTokenExpiresAt?: true
    approvedAt?: true
    reviewComment?: true
    creditText?: true
    latestVersionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwineStoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwineStory to aggregate.
     */
    where?: TwineStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwineStories to fetch.
     */
    orderBy?: TwineStoryOrderByWithRelationInput | TwineStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwineStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwineStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwineStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwineStories
    **/
    _count?: true | TwineStoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwineStoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwineStoryMaxAggregateInputType
  }

  export type GetTwineStoryAggregateType<T extends TwineStoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTwineStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwineStory[P]>
      : GetScalarType<T[P], AggregateTwineStory[P]>
  }




  export type TwineStoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwineStoryWhereInput
    orderBy?: TwineStoryOrderByWithAggregationInput | TwineStoryOrderByWithAggregationInput[]
    by: TwineStoryScalarFieldEnum[] | TwineStoryScalarFieldEnum
    having?: TwineStoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwineStoryCountAggregateInputType | true
    _min?: TwineStoryMinAggregateInputType
    _max?: TwineStoryMaxAggregateInputType
  }

  export type TwineStoryGroupByOutputType = {
    id: string
    slug: string
    title: string
    summary: string | null
    tags: string[]
    visibility: $Enums.StoryVisibility
    ownerId: string | null
    originalCreatorId: string | null
    originalCreatorProfileId: string | null
    approvedById: string | null
    ownershipStatus: $Enums.StoryOwnershipStatus
    submittedAt: Date | null
    transferConsentAt: Date | null
    transferConsentIp: string | null
    transferConsentUserAgent: string | null
    approvalToken: string | null
    approvalTokenExpiresAt: Date | null
    approvedAt: Date | null
    reviewComment: string | null
    creditText: string | null
    latestVersionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TwineStoryCountAggregateOutputType | null
    _min: TwineStoryMinAggregateOutputType | null
    _max: TwineStoryMaxAggregateOutputType | null
  }

  type GetTwineStoryGroupByPayload<T extends TwineStoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwineStoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwineStoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwineStoryGroupByOutputType[P]>
            : GetScalarType<T[P], TwineStoryGroupByOutputType[P]>
        }
      >
    >


  export type TwineStorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    summary?: boolean
    tags?: boolean
    visibility?: boolean
    ownerId?: boolean
    originalCreatorId?: boolean
    originalCreatorProfileId?: boolean
    approvedById?: boolean
    ownershipStatus?: boolean
    submittedAt?: boolean
    transferConsentAt?: boolean
    transferConsentIp?: boolean
    transferConsentUserAgent?: boolean
    approvalToken?: boolean
    approvalTokenExpiresAt?: boolean
    approvedAt?: boolean
    reviewComment?: boolean
    creditText?: boolean
    latestVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | TwineStory$ownerArgs<ExtArgs>
    originalCreator?: boolean | TwineStory$originalCreatorArgs<ExtArgs>
    originalCreatorProfile?: boolean | TwineStory$originalCreatorProfileArgs<ExtArgs>
    approvedBy?: boolean | TwineStory$approvedByArgs<ExtArgs>
    versions?: boolean | TwineStory$versionsArgs<ExtArgs>
    latestVersion?: boolean | TwineStory$latestVersionArgs<ExtArgs>
    playSessions?: boolean | TwineStory$playSessionsArgs<ExtArgs>
    nodes?: boolean | TwineStory$nodesArgs<ExtArgs>
    paths?: boolean | TwineStory$pathsArgs<ExtArgs>
    transitions?: boolean | TwineStory$transitionsArgs<ExtArgs>
    avatars?: boolean | TwineStory$avatarsArgs<ExtArgs>
    auditLogs?: boolean | TwineStory$auditLogsArgs<ExtArgs>
    interactions?: boolean | TwineStory$interactionsArgs<ExtArgs>
    _count?: boolean | TwineStoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twineStory"]>

  export type TwineStorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    summary?: boolean
    tags?: boolean
    visibility?: boolean
    ownerId?: boolean
    originalCreatorId?: boolean
    originalCreatorProfileId?: boolean
    approvedById?: boolean
    ownershipStatus?: boolean
    submittedAt?: boolean
    transferConsentAt?: boolean
    transferConsentIp?: boolean
    transferConsentUserAgent?: boolean
    approvalToken?: boolean
    approvalTokenExpiresAt?: boolean
    approvedAt?: boolean
    reviewComment?: boolean
    creditText?: boolean
    latestVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | TwineStory$ownerArgs<ExtArgs>
    originalCreator?: boolean | TwineStory$originalCreatorArgs<ExtArgs>
    originalCreatorProfile?: boolean | TwineStory$originalCreatorProfileArgs<ExtArgs>
    approvedBy?: boolean | TwineStory$approvedByArgs<ExtArgs>
    latestVersion?: boolean | TwineStory$latestVersionArgs<ExtArgs>
  }, ExtArgs["result"]["twineStory"]>

  export type TwineStorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    summary?: boolean
    tags?: boolean
    visibility?: boolean
    ownerId?: boolean
    originalCreatorId?: boolean
    originalCreatorProfileId?: boolean
    approvedById?: boolean
    ownershipStatus?: boolean
    submittedAt?: boolean
    transferConsentAt?: boolean
    transferConsentIp?: boolean
    transferConsentUserAgent?: boolean
    approvalToken?: boolean
    approvalTokenExpiresAt?: boolean
    approvedAt?: boolean
    reviewComment?: boolean
    creditText?: boolean
    latestVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | TwineStory$ownerArgs<ExtArgs>
    originalCreator?: boolean | TwineStory$originalCreatorArgs<ExtArgs>
    originalCreatorProfile?: boolean | TwineStory$originalCreatorProfileArgs<ExtArgs>
    approvedBy?: boolean | TwineStory$approvedByArgs<ExtArgs>
    latestVersion?: boolean | TwineStory$latestVersionArgs<ExtArgs>
  }, ExtArgs["result"]["twineStory"]>

  export type TwineStorySelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    summary?: boolean
    tags?: boolean
    visibility?: boolean
    ownerId?: boolean
    originalCreatorId?: boolean
    originalCreatorProfileId?: boolean
    approvedById?: boolean
    ownershipStatus?: boolean
    submittedAt?: boolean
    transferConsentAt?: boolean
    transferConsentIp?: boolean
    transferConsentUserAgent?: boolean
    approvalToken?: boolean
    approvalTokenExpiresAt?: boolean
    approvedAt?: boolean
    reviewComment?: boolean
    creditText?: boolean
    latestVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TwineStoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "summary" | "tags" | "visibility" | "ownerId" | "originalCreatorId" | "originalCreatorProfileId" | "approvedById" | "ownershipStatus" | "submittedAt" | "transferConsentAt" | "transferConsentIp" | "transferConsentUserAgent" | "approvalToken" | "approvalTokenExpiresAt" | "approvedAt" | "reviewComment" | "creditText" | "latestVersionId" | "createdAt" | "updatedAt", ExtArgs["result"]["twineStory"]>
  export type TwineStoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | TwineStory$ownerArgs<ExtArgs>
    originalCreator?: boolean | TwineStory$originalCreatorArgs<ExtArgs>
    originalCreatorProfile?: boolean | TwineStory$originalCreatorProfileArgs<ExtArgs>
    approvedBy?: boolean | TwineStory$approvedByArgs<ExtArgs>
    versions?: boolean | TwineStory$versionsArgs<ExtArgs>
    latestVersion?: boolean | TwineStory$latestVersionArgs<ExtArgs>
    playSessions?: boolean | TwineStory$playSessionsArgs<ExtArgs>
    nodes?: boolean | TwineStory$nodesArgs<ExtArgs>
    paths?: boolean | TwineStory$pathsArgs<ExtArgs>
    transitions?: boolean | TwineStory$transitionsArgs<ExtArgs>
    avatars?: boolean | TwineStory$avatarsArgs<ExtArgs>
    auditLogs?: boolean | TwineStory$auditLogsArgs<ExtArgs>
    interactions?: boolean | TwineStory$interactionsArgs<ExtArgs>
    _count?: boolean | TwineStoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TwineStoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | TwineStory$ownerArgs<ExtArgs>
    originalCreator?: boolean | TwineStory$originalCreatorArgs<ExtArgs>
    originalCreatorProfile?: boolean | TwineStory$originalCreatorProfileArgs<ExtArgs>
    approvedBy?: boolean | TwineStory$approvedByArgs<ExtArgs>
    latestVersion?: boolean | TwineStory$latestVersionArgs<ExtArgs>
  }
  export type TwineStoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | TwineStory$ownerArgs<ExtArgs>
    originalCreator?: boolean | TwineStory$originalCreatorArgs<ExtArgs>
    originalCreatorProfile?: boolean | TwineStory$originalCreatorProfileArgs<ExtArgs>
    approvedBy?: boolean | TwineStory$approvedByArgs<ExtArgs>
    latestVersion?: boolean | TwineStory$latestVersionArgs<ExtArgs>
  }

  export type $TwineStoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwineStory"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
      originalCreator: Prisma.$UserPayload<ExtArgs> | null
      originalCreatorProfile: Prisma.$CreatorProfilePayload<ExtArgs> | null
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
      versions: Prisma.$StoryVersionPayload<ExtArgs>[]
      latestVersion: Prisma.$StoryVersionPayload<ExtArgs> | null
      playSessions: Prisma.$StoryPlaySessionPayload<ExtArgs>[]
      nodes: Prisma.$StoryNodePayload<ExtArgs>[]
      paths: Prisma.$StoryPathPayload<ExtArgs>[]
      transitions: Prisma.$StoryTransitionPayload<ExtArgs>[]
      avatars: Prisma.$AvatarProfilePayload<ExtArgs>[]
      auditLogs: Prisma.$StoryAuditLogPayload<ExtArgs>[]
      interactions: Prisma.$StoryInteractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      summary: string | null
      tags: string[]
      visibility: $Enums.StoryVisibility
      ownerId: string | null
      originalCreatorId: string | null
      originalCreatorProfileId: string | null
      approvedById: string | null
      ownershipStatus: $Enums.StoryOwnershipStatus
      submittedAt: Date | null
      transferConsentAt: Date | null
      transferConsentIp: string | null
      transferConsentUserAgent: string | null
      approvalToken: string | null
      approvalTokenExpiresAt: Date | null
      approvedAt: Date | null
      reviewComment: string | null
      creditText: string | null
      latestVersionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["twineStory"]>
    composites: {}
  }

  type TwineStoryGetPayload<S extends boolean | null | undefined | TwineStoryDefaultArgs> = $Result.GetResult<Prisma.$TwineStoryPayload, S>

  type TwineStoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TwineStoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TwineStoryCountAggregateInputType | true
    }

  export interface TwineStoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwineStory'], meta: { name: 'TwineStory' } }
    /**
     * Find zero or one TwineStory that matches the filter.
     * @param {TwineStoryFindUniqueArgs} args - Arguments to find a TwineStory
     * @example
     * // Get one TwineStory
     * const twineStory = await prisma.twineStory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwineStoryFindUniqueArgs>(args: SelectSubset<T, TwineStoryFindUniqueArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TwineStory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TwineStoryFindUniqueOrThrowArgs} args - Arguments to find a TwineStory
     * @example
     * // Get one TwineStory
     * const twineStory = await prisma.twineStory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwineStoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TwineStoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwineStory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwineStoryFindFirstArgs} args - Arguments to find a TwineStory
     * @example
     * // Get one TwineStory
     * const twineStory = await prisma.twineStory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwineStoryFindFirstArgs>(args?: SelectSubset<T, TwineStoryFindFirstArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwineStory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwineStoryFindFirstOrThrowArgs} args - Arguments to find a TwineStory
     * @example
     * // Get one TwineStory
     * const twineStory = await prisma.twineStory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwineStoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TwineStoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TwineStories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwineStoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwineStories
     * const twineStories = await prisma.twineStory.findMany()
     * 
     * // Get first 10 TwineStories
     * const twineStories = await prisma.twineStory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twineStoryWithIdOnly = await prisma.twineStory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwineStoryFindManyArgs>(args?: SelectSubset<T, TwineStoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TwineStory.
     * @param {TwineStoryCreateArgs} args - Arguments to create a TwineStory.
     * @example
     * // Create one TwineStory
     * const TwineStory = await prisma.twineStory.create({
     *   data: {
     *     // ... data to create a TwineStory
     *   }
     * })
     * 
     */
    create<T extends TwineStoryCreateArgs>(args: SelectSubset<T, TwineStoryCreateArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TwineStories.
     * @param {TwineStoryCreateManyArgs} args - Arguments to create many TwineStories.
     * @example
     * // Create many TwineStories
     * const twineStory = await prisma.twineStory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwineStoryCreateManyArgs>(args?: SelectSubset<T, TwineStoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TwineStories and returns the data saved in the database.
     * @param {TwineStoryCreateManyAndReturnArgs} args - Arguments to create many TwineStories.
     * @example
     * // Create many TwineStories
     * const twineStory = await prisma.twineStory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TwineStories and only return the `id`
     * const twineStoryWithIdOnly = await prisma.twineStory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TwineStoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TwineStoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TwineStory.
     * @param {TwineStoryDeleteArgs} args - Arguments to delete one TwineStory.
     * @example
     * // Delete one TwineStory
     * const TwineStory = await prisma.twineStory.delete({
     *   where: {
     *     // ... filter to delete one TwineStory
     *   }
     * })
     * 
     */
    delete<T extends TwineStoryDeleteArgs>(args: SelectSubset<T, TwineStoryDeleteArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TwineStory.
     * @param {TwineStoryUpdateArgs} args - Arguments to update one TwineStory.
     * @example
     * // Update one TwineStory
     * const twineStory = await prisma.twineStory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwineStoryUpdateArgs>(args: SelectSubset<T, TwineStoryUpdateArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TwineStories.
     * @param {TwineStoryDeleteManyArgs} args - Arguments to filter TwineStories to delete.
     * @example
     * // Delete a few TwineStories
     * const { count } = await prisma.twineStory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwineStoryDeleteManyArgs>(args?: SelectSubset<T, TwineStoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwineStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwineStoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwineStories
     * const twineStory = await prisma.twineStory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwineStoryUpdateManyArgs>(args: SelectSubset<T, TwineStoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwineStories and returns the data updated in the database.
     * @param {TwineStoryUpdateManyAndReturnArgs} args - Arguments to update many TwineStories.
     * @example
     * // Update many TwineStories
     * const twineStory = await prisma.twineStory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TwineStories and only return the `id`
     * const twineStoryWithIdOnly = await prisma.twineStory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TwineStoryUpdateManyAndReturnArgs>(args: SelectSubset<T, TwineStoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TwineStory.
     * @param {TwineStoryUpsertArgs} args - Arguments to update or create a TwineStory.
     * @example
     * // Update or create a TwineStory
     * const twineStory = await prisma.twineStory.upsert({
     *   create: {
     *     // ... data to create a TwineStory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwineStory we want to update
     *   }
     * })
     */
    upsert<T extends TwineStoryUpsertArgs>(args: SelectSubset<T, TwineStoryUpsertArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TwineStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwineStoryCountArgs} args - Arguments to filter TwineStories to count.
     * @example
     * // Count the number of TwineStories
     * const count = await prisma.twineStory.count({
     *   where: {
     *     // ... the filter for the TwineStories we want to count
     *   }
     * })
    **/
    count<T extends TwineStoryCountArgs>(
      args?: Subset<T, TwineStoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwineStoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwineStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwineStoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwineStoryAggregateArgs>(args: Subset<T, TwineStoryAggregateArgs>): Prisma.PrismaPromise<GetTwineStoryAggregateType<T>>

    /**
     * Group by TwineStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwineStoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwineStoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwineStoryGroupByArgs['orderBy'] }
        : { orderBy?: TwineStoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwineStoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwineStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwineStory model
   */
  readonly fields: TwineStoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwineStory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwineStoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends TwineStory$ownerArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    originalCreator<T extends TwineStory$originalCreatorArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$originalCreatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    originalCreatorProfile<T extends TwineStory$originalCreatorProfileArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$originalCreatorProfileArgs<ExtArgs>>): Prisma__CreatorProfileClient<$Result.GetResult<Prisma.$CreatorProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends TwineStory$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    versions<T extends TwineStory$versionsArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    latestVersion<T extends TwineStory$latestVersionArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$latestVersionArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    playSessions<T extends TwineStory$playSessionsArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$playSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nodes<T extends TwineStory$nodesArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paths<T extends TwineStory$pathsArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$pathsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transitions<T extends TwineStory$transitionsArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$transitionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    avatars<T extends TwineStory$avatarsArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$avatarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends TwineStory$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends TwineStory$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, TwineStory$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwineStory model
   */
  interface TwineStoryFieldRefs {
    readonly id: FieldRef<"TwineStory", 'String'>
    readonly slug: FieldRef<"TwineStory", 'String'>
    readonly title: FieldRef<"TwineStory", 'String'>
    readonly summary: FieldRef<"TwineStory", 'String'>
    readonly tags: FieldRef<"TwineStory", 'String[]'>
    readonly visibility: FieldRef<"TwineStory", 'StoryVisibility'>
    readonly ownerId: FieldRef<"TwineStory", 'String'>
    readonly originalCreatorId: FieldRef<"TwineStory", 'String'>
    readonly originalCreatorProfileId: FieldRef<"TwineStory", 'String'>
    readonly approvedById: FieldRef<"TwineStory", 'String'>
    readonly ownershipStatus: FieldRef<"TwineStory", 'StoryOwnershipStatus'>
    readonly submittedAt: FieldRef<"TwineStory", 'DateTime'>
    readonly transferConsentAt: FieldRef<"TwineStory", 'DateTime'>
    readonly transferConsentIp: FieldRef<"TwineStory", 'String'>
    readonly transferConsentUserAgent: FieldRef<"TwineStory", 'String'>
    readonly approvalToken: FieldRef<"TwineStory", 'String'>
    readonly approvalTokenExpiresAt: FieldRef<"TwineStory", 'DateTime'>
    readonly approvedAt: FieldRef<"TwineStory", 'DateTime'>
    readonly reviewComment: FieldRef<"TwineStory", 'String'>
    readonly creditText: FieldRef<"TwineStory", 'String'>
    readonly latestVersionId: FieldRef<"TwineStory", 'String'>
    readonly createdAt: FieldRef<"TwineStory", 'DateTime'>
    readonly updatedAt: FieldRef<"TwineStory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TwineStory findUnique
   */
  export type TwineStoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    /**
     * Filter, which TwineStory to fetch.
     */
    where: TwineStoryWhereUniqueInput
  }

  /**
   * TwineStory findUniqueOrThrow
   */
  export type TwineStoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    /**
     * Filter, which TwineStory to fetch.
     */
    where: TwineStoryWhereUniqueInput
  }

  /**
   * TwineStory findFirst
   */
  export type TwineStoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    /**
     * Filter, which TwineStory to fetch.
     */
    where?: TwineStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwineStories to fetch.
     */
    orderBy?: TwineStoryOrderByWithRelationInput | TwineStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwineStories.
     */
    cursor?: TwineStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwineStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwineStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwineStories.
     */
    distinct?: TwineStoryScalarFieldEnum | TwineStoryScalarFieldEnum[]
  }

  /**
   * TwineStory findFirstOrThrow
   */
  export type TwineStoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    /**
     * Filter, which TwineStory to fetch.
     */
    where?: TwineStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwineStories to fetch.
     */
    orderBy?: TwineStoryOrderByWithRelationInput | TwineStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwineStories.
     */
    cursor?: TwineStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwineStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwineStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwineStories.
     */
    distinct?: TwineStoryScalarFieldEnum | TwineStoryScalarFieldEnum[]
  }

  /**
   * TwineStory findMany
   */
  export type TwineStoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    /**
     * Filter, which TwineStories to fetch.
     */
    where?: TwineStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwineStories to fetch.
     */
    orderBy?: TwineStoryOrderByWithRelationInput | TwineStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwineStories.
     */
    cursor?: TwineStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwineStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwineStories.
     */
    skip?: number
    distinct?: TwineStoryScalarFieldEnum | TwineStoryScalarFieldEnum[]
  }

  /**
   * TwineStory create
   */
  export type TwineStoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TwineStory.
     */
    data: XOR<TwineStoryCreateInput, TwineStoryUncheckedCreateInput>
  }

  /**
   * TwineStory createMany
   */
  export type TwineStoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwineStories.
     */
    data: TwineStoryCreateManyInput | TwineStoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwineStory createManyAndReturn
   */
  export type TwineStoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * The data used to create many TwineStories.
     */
    data: TwineStoryCreateManyInput | TwineStoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TwineStory update
   */
  export type TwineStoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TwineStory.
     */
    data: XOR<TwineStoryUpdateInput, TwineStoryUncheckedUpdateInput>
    /**
     * Choose, which TwineStory to update.
     */
    where: TwineStoryWhereUniqueInput
  }

  /**
   * TwineStory updateMany
   */
  export type TwineStoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwineStories.
     */
    data: XOR<TwineStoryUpdateManyMutationInput, TwineStoryUncheckedUpdateManyInput>
    /**
     * Filter which TwineStories to update
     */
    where?: TwineStoryWhereInput
    /**
     * Limit how many TwineStories to update.
     */
    limit?: number
  }

  /**
   * TwineStory updateManyAndReturn
   */
  export type TwineStoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * The data used to update TwineStories.
     */
    data: XOR<TwineStoryUpdateManyMutationInput, TwineStoryUncheckedUpdateManyInput>
    /**
     * Filter which TwineStories to update
     */
    where?: TwineStoryWhereInput
    /**
     * Limit how many TwineStories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TwineStory upsert
   */
  export type TwineStoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TwineStory to update in case it exists.
     */
    where: TwineStoryWhereUniqueInput
    /**
     * In case the TwineStory found by the `where` argument doesn't exist, create a new TwineStory with this data.
     */
    create: XOR<TwineStoryCreateInput, TwineStoryUncheckedCreateInput>
    /**
     * In case the TwineStory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwineStoryUpdateInput, TwineStoryUncheckedUpdateInput>
  }

  /**
   * TwineStory delete
   */
  export type TwineStoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    /**
     * Filter which TwineStory to delete.
     */
    where: TwineStoryWhereUniqueInput
  }

  /**
   * TwineStory deleteMany
   */
  export type TwineStoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwineStories to delete
     */
    where?: TwineStoryWhereInput
    /**
     * Limit how many TwineStories to delete.
     */
    limit?: number
  }

  /**
   * TwineStory.owner
   */
  export type TwineStory$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TwineStory.originalCreator
   */
  export type TwineStory$originalCreatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TwineStory.originalCreatorProfile
   */
  export type TwineStory$originalCreatorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorProfile
     */
    select?: CreatorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatorProfile
     */
    omit?: CreatorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorProfileInclude<ExtArgs> | null
    where?: CreatorProfileWhereInput
  }

  /**
   * TwineStory.approvedBy
   */
  export type TwineStory$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TwineStory.versions
   */
  export type TwineStory$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    where?: StoryVersionWhereInput
    orderBy?: StoryVersionOrderByWithRelationInput | StoryVersionOrderByWithRelationInput[]
    cursor?: StoryVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryVersionScalarFieldEnum | StoryVersionScalarFieldEnum[]
  }

  /**
   * TwineStory.latestVersion
   */
  export type TwineStory$latestVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    where?: StoryVersionWhereInput
  }

  /**
   * TwineStory.playSessions
   */
  export type TwineStory$playSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    where?: StoryPlaySessionWhereInput
    orderBy?: StoryPlaySessionOrderByWithRelationInput | StoryPlaySessionOrderByWithRelationInput[]
    cursor?: StoryPlaySessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryPlaySessionScalarFieldEnum | StoryPlaySessionScalarFieldEnum[]
  }

  /**
   * TwineStory.nodes
   */
  export type TwineStory$nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeInclude<ExtArgs> | null
    where?: StoryNodeWhereInput
    orderBy?: StoryNodeOrderByWithRelationInput | StoryNodeOrderByWithRelationInput[]
    cursor?: StoryNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryNodeScalarFieldEnum | StoryNodeScalarFieldEnum[]
  }

  /**
   * TwineStory.paths
   */
  export type TwineStory$pathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathInclude<ExtArgs> | null
    where?: StoryPathWhereInput
    orderBy?: StoryPathOrderByWithRelationInput | StoryPathOrderByWithRelationInput[]
    cursor?: StoryPathWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryPathScalarFieldEnum | StoryPathScalarFieldEnum[]
  }

  /**
   * TwineStory.transitions
   */
  export type TwineStory$transitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    where?: StoryTransitionWhereInput
    orderBy?: StoryTransitionOrderByWithRelationInput | StoryTransitionOrderByWithRelationInput[]
    cursor?: StoryTransitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryTransitionScalarFieldEnum | StoryTransitionScalarFieldEnum[]
  }

  /**
   * TwineStory.avatars
   */
  export type TwineStory$avatarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    where?: AvatarProfileWhereInput
    orderBy?: AvatarProfileOrderByWithRelationInput | AvatarProfileOrderByWithRelationInput[]
    cursor?: AvatarProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvatarProfileScalarFieldEnum | AvatarProfileScalarFieldEnum[]
  }

  /**
   * TwineStory.auditLogs
   */
  export type TwineStory$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogInclude<ExtArgs> | null
    where?: StoryAuditLogWhereInput
    orderBy?: StoryAuditLogOrderByWithRelationInput | StoryAuditLogOrderByWithRelationInput[]
    cursor?: StoryAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryAuditLogScalarFieldEnum | StoryAuditLogScalarFieldEnum[]
  }

  /**
   * TwineStory.interactions
   */
  export type TwineStory$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    where?: StoryInteractionWhereInput
    orderBy?: StoryInteractionOrderByWithRelationInput | StoryInteractionOrderByWithRelationInput[]
    cursor?: StoryInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryInteractionScalarFieldEnum | StoryInteractionScalarFieldEnum[]
  }

  /**
   * TwineStory without action
   */
  export type TwineStoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
  }


  /**
   * Model StoryVersion
   */

  export type AggregateStoryVersion = {
    _count: StoryVersionCountAggregateOutputType | null
    _avg: StoryVersionAvgAggregateOutputType | null
    _sum: StoryVersionSumAggregateOutputType | null
    _min: StoryVersionMinAggregateOutputType | null
    _max: StoryVersionMaxAggregateOutputType | null
  }

  export type StoryVersionAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type StoryVersionSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type StoryVersionMinAggregateOutputType = {
    id: string | null
    storyId: string | null
    authorId: string | null
    reviewerId: string | null
    versionNumber: number | null
    status: $Enums.StoryStatus | null
    changelog: string | null
    sourceUrl: string | null
    assetPath: string | null
    submittedAt: Date | null
    reviewedAt: Date | null
    ownershipStatus: $Enums.StoryOwnershipStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryVersionMaxAggregateOutputType = {
    id: string | null
    storyId: string | null
    authorId: string | null
    reviewerId: string | null
    versionNumber: number | null
    status: $Enums.StoryStatus | null
    changelog: string | null
    sourceUrl: string | null
    assetPath: string | null
    submittedAt: Date | null
    reviewedAt: Date | null
    ownershipStatus: $Enums.StoryOwnershipStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryVersionCountAggregateOutputType = {
    id: number
    storyId: number
    authorId: number
    reviewerId: number
    versionNumber: number
    status: number
    changelog: number
    content: number
    sourceUrl: number
    assetPath: number
    metadata: number
    submittedAt: number
    reviewedAt: number
    ownershipStatus: number
    consentSnapshot: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoryVersionAvgAggregateInputType = {
    versionNumber?: true
  }

  export type StoryVersionSumAggregateInputType = {
    versionNumber?: true
  }

  export type StoryVersionMinAggregateInputType = {
    id?: true
    storyId?: true
    authorId?: true
    reviewerId?: true
    versionNumber?: true
    status?: true
    changelog?: true
    sourceUrl?: true
    assetPath?: true
    submittedAt?: true
    reviewedAt?: true
    ownershipStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryVersionMaxAggregateInputType = {
    id?: true
    storyId?: true
    authorId?: true
    reviewerId?: true
    versionNumber?: true
    status?: true
    changelog?: true
    sourceUrl?: true
    assetPath?: true
    submittedAt?: true
    reviewedAt?: true
    ownershipStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryVersionCountAggregateInputType = {
    id?: true
    storyId?: true
    authorId?: true
    reviewerId?: true
    versionNumber?: true
    status?: true
    changelog?: true
    content?: true
    sourceUrl?: true
    assetPath?: true
    metadata?: true
    submittedAt?: true
    reviewedAt?: true
    ownershipStatus?: true
    consentSnapshot?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoryVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryVersion to aggregate.
     */
    where?: StoryVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryVersions to fetch.
     */
    orderBy?: StoryVersionOrderByWithRelationInput | StoryVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryVersions
    **/
    _count?: true | StoryVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoryVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoryVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryVersionMaxAggregateInputType
  }

  export type GetStoryVersionAggregateType<T extends StoryVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryVersion[P]>
      : GetScalarType<T[P], AggregateStoryVersion[P]>
  }




  export type StoryVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryVersionWhereInput
    orderBy?: StoryVersionOrderByWithAggregationInput | StoryVersionOrderByWithAggregationInput[]
    by: StoryVersionScalarFieldEnum[] | StoryVersionScalarFieldEnum
    having?: StoryVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryVersionCountAggregateInputType | true
    _avg?: StoryVersionAvgAggregateInputType
    _sum?: StoryVersionSumAggregateInputType
    _min?: StoryVersionMinAggregateInputType
    _max?: StoryVersionMaxAggregateInputType
  }

  export type StoryVersionGroupByOutputType = {
    id: string
    storyId: string
    authorId: string | null
    reviewerId: string | null
    versionNumber: number
    status: $Enums.StoryStatus
    changelog: string | null
    content: JsonValue | null
    sourceUrl: string | null
    assetPath: string | null
    metadata: JsonValue | null
    submittedAt: Date | null
    reviewedAt: Date | null
    ownershipStatus: $Enums.StoryOwnershipStatus
    consentSnapshot: JsonValue | null
    createdAt: Date
    updatedAt: Date | null
    _count: StoryVersionCountAggregateOutputType | null
    _avg: StoryVersionAvgAggregateOutputType | null
    _sum: StoryVersionSumAggregateOutputType | null
    _min: StoryVersionMinAggregateOutputType | null
    _max: StoryVersionMaxAggregateOutputType | null
  }

  type GetStoryVersionGroupByPayload<T extends StoryVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryVersionGroupByOutputType[P]>
            : GetScalarType<T[P], StoryVersionGroupByOutputType[P]>
        }
      >
    >


  export type StoryVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    authorId?: boolean
    reviewerId?: boolean
    versionNumber?: boolean
    status?: boolean
    changelog?: boolean
    content?: boolean
    sourceUrl?: boolean
    assetPath?: boolean
    metadata?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    ownershipStatus?: boolean
    consentSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    featuredIn?: boolean | StoryVersion$featuredInArgs<ExtArgs>
    author?: boolean | StoryVersion$authorArgs<ExtArgs>
    reviewer?: boolean | StoryVersion$reviewerArgs<ExtArgs>
    reviews?: boolean | StoryVersion$reviewsArgs<ExtArgs>
    playSessions?: boolean | StoryVersion$playSessionsArgs<ExtArgs>
    _count?: boolean | StoryVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyVersion"]>

  export type StoryVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    authorId?: boolean
    reviewerId?: boolean
    versionNumber?: boolean
    status?: boolean
    changelog?: boolean
    content?: boolean
    sourceUrl?: boolean
    assetPath?: boolean
    metadata?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    ownershipStatus?: boolean
    consentSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    author?: boolean | StoryVersion$authorArgs<ExtArgs>
    reviewer?: boolean | StoryVersion$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["storyVersion"]>

  export type StoryVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    authorId?: boolean
    reviewerId?: boolean
    versionNumber?: boolean
    status?: boolean
    changelog?: boolean
    content?: boolean
    sourceUrl?: boolean
    assetPath?: boolean
    metadata?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    ownershipStatus?: boolean
    consentSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    author?: boolean | StoryVersion$authorArgs<ExtArgs>
    reviewer?: boolean | StoryVersion$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["storyVersion"]>

  export type StoryVersionSelectScalar = {
    id?: boolean
    storyId?: boolean
    authorId?: boolean
    reviewerId?: boolean
    versionNumber?: boolean
    status?: boolean
    changelog?: boolean
    content?: boolean
    sourceUrl?: boolean
    assetPath?: boolean
    metadata?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    ownershipStatus?: boolean
    consentSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoryVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storyId" | "authorId" | "reviewerId" | "versionNumber" | "status" | "changelog" | "content" | "sourceUrl" | "assetPath" | "metadata" | "submittedAt" | "reviewedAt" | "ownershipStatus" | "consentSnapshot" | "createdAt" | "updatedAt", ExtArgs["result"]["storyVersion"]>
  export type StoryVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    featuredIn?: boolean | StoryVersion$featuredInArgs<ExtArgs>
    author?: boolean | StoryVersion$authorArgs<ExtArgs>
    reviewer?: boolean | StoryVersion$reviewerArgs<ExtArgs>
    reviews?: boolean | StoryVersion$reviewsArgs<ExtArgs>
    playSessions?: boolean | StoryVersion$playSessionsArgs<ExtArgs>
    _count?: boolean | StoryVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoryVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    author?: boolean | StoryVersion$authorArgs<ExtArgs>
    reviewer?: boolean | StoryVersion$reviewerArgs<ExtArgs>
  }
  export type StoryVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    author?: boolean | StoryVersion$authorArgs<ExtArgs>
    reviewer?: boolean | StoryVersion$reviewerArgs<ExtArgs>
  }

  export type $StoryVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryVersion"
    objects: {
      story: Prisma.$TwineStoryPayload<ExtArgs>
      featuredIn: Prisma.$TwineStoryPayload<ExtArgs> | null
      author: Prisma.$UserPayload<ExtArgs> | null
      reviewer: Prisma.$UserPayload<ExtArgs> | null
      reviews: Prisma.$StoryReviewPayload<ExtArgs>[]
      playSessions: Prisma.$StoryPlaySessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storyId: string
      authorId: string | null
      reviewerId: string | null
      versionNumber: number
      status: $Enums.StoryStatus
      changelog: string | null
      content: Prisma.JsonValue | null
      sourceUrl: string | null
      assetPath: string | null
      metadata: Prisma.JsonValue | null
      submittedAt: Date | null
      reviewedAt: Date | null
      ownershipStatus: $Enums.StoryOwnershipStatus
      consentSnapshot: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["storyVersion"]>
    composites: {}
  }

  type StoryVersionGetPayload<S extends boolean | null | undefined | StoryVersionDefaultArgs> = $Result.GetResult<Prisma.$StoryVersionPayload, S>

  type StoryVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryVersionCountAggregateInputType | true
    }

  export interface StoryVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryVersion'], meta: { name: 'StoryVersion' } }
    /**
     * Find zero or one StoryVersion that matches the filter.
     * @param {StoryVersionFindUniqueArgs} args - Arguments to find a StoryVersion
     * @example
     * // Get one StoryVersion
     * const storyVersion = await prisma.storyVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryVersionFindUniqueArgs>(args: SelectSubset<T, StoryVersionFindUniqueArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoryVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryVersionFindUniqueOrThrowArgs} args - Arguments to find a StoryVersion
     * @example
     * // Get one StoryVersion
     * const storyVersion = await prisma.storyVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionFindFirstArgs} args - Arguments to find a StoryVersion
     * @example
     * // Get one StoryVersion
     * const storyVersion = await prisma.storyVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryVersionFindFirstArgs>(args?: SelectSubset<T, StoryVersionFindFirstArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionFindFirstOrThrowArgs} args - Arguments to find a StoryVersion
     * @example
     * // Get one StoryVersion
     * const storyVersion = await prisma.storyVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoryVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryVersions
     * const storyVersions = await prisma.storyVersion.findMany()
     * 
     * // Get first 10 StoryVersions
     * const storyVersions = await prisma.storyVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyVersionWithIdOnly = await prisma.storyVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryVersionFindManyArgs>(args?: SelectSubset<T, StoryVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoryVersion.
     * @param {StoryVersionCreateArgs} args - Arguments to create a StoryVersion.
     * @example
     * // Create one StoryVersion
     * const StoryVersion = await prisma.storyVersion.create({
     *   data: {
     *     // ... data to create a StoryVersion
     *   }
     * })
     * 
     */
    create<T extends StoryVersionCreateArgs>(args: SelectSubset<T, StoryVersionCreateArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoryVersions.
     * @param {StoryVersionCreateManyArgs} args - Arguments to create many StoryVersions.
     * @example
     * // Create many StoryVersions
     * const storyVersion = await prisma.storyVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryVersionCreateManyArgs>(args?: SelectSubset<T, StoryVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryVersions and returns the data saved in the database.
     * @param {StoryVersionCreateManyAndReturnArgs} args - Arguments to create many StoryVersions.
     * @example
     * // Create many StoryVersions
     * const storyVersion = await prisma.storyVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryVersions and only return the `id`
     * const storyVersionWithIdOnly = await prisma.storyVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoryVersion.
     * @param {StoryVersionDeleteArgs} args - Arguments to delete one StoryVersion.
     * @example
     * // Delete one StoryVersion
     * const StoryVersion = await prisma.storyVersion.delete({
     *   where: {
     *     // ... filter to delete one StoryVersion
     *   }
     * })
     * 
     */
    delete<T extends StoryVersionDeleteArgs>(args: SelectSubset<T, StoryVersionDeleteArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoryVersion.
     * @param {StoryVersionUpdateArgs} args - Arguments to update one StoryVersion.
     * @example
     * // Update one StoryVersion
     * const storyVersion = await prisma.storyVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryVersionUpdateArgs>(args: SelectSubset<T, StoryVersionUpdateArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoryVersions.
     * @param {StoryVersionDeleteManyArgs} args - Arguments to filter StoryVersions to delete.
     * @example
     * // Delete a few StoryVersions
     * const { count } = await prisma.storyVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryVersionDeleteManyArgs>(args?: SelectSubset<T, StoryVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryVersions
     * const storyVersion = await prisma.storyVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryVersionUpdateManyArgs>(args: SelectSubset<T, StoryVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryVersions and returns the data updated in the database.
     * @param {StoryVersionUpdateManyAndReturnArgs} args - Arguments to update many StoryVersions.
     * @example
     * // Update many StoryVersions
     * const storyVersion = await prisma.storyVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoryVersions and only return the `id`
     * const storyVersionWithIdOnly = await prisma.storyVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoryVersion.
     * @param {StoryVersionUpsertArgs} args - Arguments to update or create a StoryVersion.
     * @example
     * // Update or create a StoryVersion
     * const storyVersion = await prisma.storyVersion.upsert({
     *   create: {
     *     // ... data to create a StoryVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryVersion we want to update
     *   }
     * })
     */
    upsert<T extends StoryVersionUpsertArgs>(args: SelectSubset<T, StoryVersionUpsertArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoryVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionCountArgs} args - Arguments to filter StoryVersions to count.
     * @example
     * // Count the number of StoryVersions
     * const count = await prisma.storyVersion.count({
     *   where: {
     *     // ... the filter for the StoryVersions we want to count
     *   }
     * })
    **/
    count<T extends StoryVersionCountArgs>(
      args?: Subset<T, StoryVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryVersionAggregateArgs>(args: Subset<T, StoryVersionAggregateArgs>): Prisma.PrismaPromise<GetStoryVersionAggregateType<T>>

    /**
     * Group by StoryVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryVersionGroupByArgs['orderBy'] }
        : { orderBy?: StoryVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryVersion model
   */
  readonly fields: StoryVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends TwineStoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TwineStoryDefaultArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    featuredIn<T extends StoryVersion$featuredInArgs<ExtArgs> = {}>(args?: Subset<T, StoryVersion$featuredInArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    author<T extends StoryVersion$authorArgs<ExtArgs> = {}>(args?: Subset<T, StoryVersion$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends StoryVersion$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, StoryVersion$reviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviews<T extends StoryVersion$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, StoryVersion$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playSessions<T extends StoryVersion$playSessionsArgs<ExtArgs> = {}>(args?: Subset<T, StoryVersion$playSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryVersion model
   */
  interface StoryVersionFieldRefs {
    readonly id: FieldRef<"StoryVersion", 'String'>
    readonly storyId: FieldRef<"StoryVersion", 'String'>
    readonly authorId: FieldRef<"StoryVersion", 'String'>
    readonly reviewerId: FieldRef<"StoryVersion", 'String'>
    readonly versionNumber: FieldRef<"StoryVersion", 'Int'>
    readonly status: FieldRef<"StoryVersion", 'StoryStatus'>
    readonly changelog: FieldRef<"StoryVersion", 'String'>
    readonly content: FieldRef<"StoryVersion", 'Json'>
    readonly sourceUrl: FieldRef<"StoryVersion", 'String'>
    readonly assetPath: FieldRef<"StoryVersion", 'String'>
    readonly metadata: FieldRef<"StoryVersion", 'Json'>
    readonly submittedAt: FieldRef<"StoryVersion", 'DateTime'>
    readonly reviewedAt: FieldRef<"StoryVersion", 'DateTime'>
    readonly ownershipStatus: FieldRef<"StoryVersion", 'StoryOwnershipStatus'>
    readonly consentSnapshot: FieldRef<"StoryVersion", 'Json'>
    readonly createdAt: FieldRef<"StoryVersion", 'DateTime'>
    readonly updatedAt: FieldRef<"StoryVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoryVersion findUnique
   */
  export type StoryVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * Filter, which StoryVersion to fetch.
     */
    where: StoryVersionWhereUniqueInput
  }

  /**
   * StoryVersion findUniqueOrThrow
   */
  export type StoryVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * Filter, which StoryVersion to fetch.
     */
    where: StoryVersionWhereUniqueInput
  }

  /**
   * StoryVersion findFirst
   */
  export type StoryVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * Filter, which StoryVersion to fetch.
     */
    where?: StoryVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryVersions to fetch.
     */
    orderBy?: StoryVersionOrderByWithRelationInput | StoryVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryVersions.
     */
    cursor?: StoryVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryVersions.
     */
    distinct?: StoryVersionScalarFieldEnum | StoryVersionScalarFieldEnum[]
  }

  /**
   * StoryVersion findFirstOrThrow
   */
  export type StoryVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * Filter, which StoryVersion to fetch.
     */
    where?: StoryVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryVersions to fetch.
     */
    orderBy?: StoryVersionOrderByWithRelationInput | StoryVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryVersions.
     */
    cursor?: StoryVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryVersions.
     */
    distinct?: StoryVersionScalarFieldEnum | StoryVersionScalarFieldEnum[]
  }

  /**
   * StoryVersion findMany
   */
  export type StoryVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * Filter, which StoryVersions to fetch.
     */
    where?: StoryVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryVersions to fetch.
     */
    orderBy?: StoryVersionOrderByWithRelationInput | StoryVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryVersions.
     */
    cursor?: StoryVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryVersions.
     */
    skip?: number
    distinct?: StoryVersionScalarFieldEnum | StoryVersionScalarFieldEnum[]
  }

  /**
   * StoryVersion create
   */
  export type StoryVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryVersion.
     */
    data: XOR<StoryVersionCreateInput, StoryVersionUncheckedCreateInput>
  }

  /**
   * StoryVersion createMany
   */
  export type StoryVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryVersions.
     */
    data: StoryVersionCreateManyInput | StoryVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryVersion createManyAndReturn
   */
  export type StoryVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * The data used to create many StoryVersions.
     */
    data: StoryVersionCreateManyInput | StoryVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryVersion update
   */
  export type StoryVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryVersion.
     */
    data: XOR<StoryVersionUpdateInput, StoryVersionUncheckedUpdateInput>
    /**
     * Choose, which StoryVersion to update.
     */
    where: StoryVersionWhereUniqueInput
  }

  /**
   * StoryVersion updateMany
   */
  export type StoryVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryVersions.
     */
    data: XOR<StoryVersionUpdateManyMutationInput, StoryVersionUncheckedUpdateManyInput>
    /**
     * Filter which StoryVersions to update
     */
    where?: StoryVersionWhereInput
    /**
     * Limit how many StoryVersions to update.
     */
    limit?: number
  }

  /**
   * StoryVersion updateManyAndReturn
   */
  export type StoryVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * The data used to update StoryVersions.
     */
    data: XOR<StoryVersionUpdateManyMutationInput, StoryVersionUncheckedUpdateManyInput>
    /**
     * Filter which StoryVersions to update
     */
    where?: StoryVersionWhereInput
    /**
     * Limit how many StoryVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryVersion upsert
   */
  export type StoryVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryVersion to update in case it exists.
     */
    where: StoryVersionWhereUniqueInput
    /**
     * In case the StoryVersion found by the `where` argument doesn't exist, create a new StoryVersion with this data.
     */
    create: XOR<StoryVersionCreateInput, StoryVersionUncheckedCreateInput>
    /**
     * In case the StoryVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryVersionUpdateInput, StoryVersionUncheckedUpdateInput>
  }

  /**
   * StoryVersion delete
   */
  export type StoryVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * Filter which StoryVersion to delete.
     */
    where: StoryVersionWhereUniqueInput
  }

  /**
   * StoryVersion deleteMany
   */
  export type StoryVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryVersions to delete
     */
    where?: StoryVersionWhereInput
    /**
     * Limit how many StoryVersions to delete.
     */
    limit?: number
  }

  /**
   * StoryVersion.featuredIn
   */
  export type StoryVersion$featuredInArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    where?: TwineStoryWhereInput
  }

  /**
   * StoryVersion.author
   */
  export type StoryVersion$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StoryVersion.reviewer
   */
  export type StoryVersion$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StoryVersion.reviews
   */
  export type StoryVersion$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewInclude<ExtArgs> | null
    where?: StoryReviewWhereInput
    orderBy?: StoryReviewOrderByWithRelationInput | StoryReviewOrderByWithRelationInput[]
    cursor?: StoryReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryReviewScalarFieldEnum | StoryReviewScalarFieldEnum[]
  }

  /**
   * StoryVersion.playSessions
   */
  export type StoryVersion$playSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    where?: StoryPlaySessionWhereInput
    orderBy?: StoryPlaySessionOrderByWithRelationInput | StoryPlaySessionOrderByWithRelationInput[]
    cursor?: StoryPlaySessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryPlaySessionScalarFieldEnum | StoryPlaySessionScalarFieldEnum[]
  }

  /**
   * StoryVersion without action
   */
  export type StoryVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
  }


  /**
   * Model StoryAuditLog
   */

  export type AggregateStoryAuditLog = {
    _count: StoryAuditLogCountAggregateOutputType | null
    _min: StoryAuditLogMinAggregateOutputType | null
    _max: StoryAuditLogMaxAggregateOutputType | null
  }

  export type StoryAuditLogMinAggregateOutputType = {
    id: string | null
    storyId: string | null
    actorId: string | null
    action: string | null
    note: string | null
    createdAt: Date | null
  }

  export type StoryAuditLogMaxAggregateOutputType = {
    id: string | null
    storyId: string | null
    actorId: string | null
    action: string | null
    note: string | null
    createdAt: Date | null
  }

  export type StoryAuditLogCountAggregateOutputType = {
    id: number
    storyId: number
    actorId: number
    action: number
    note: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type StoryAuditLogMinAggregateInputType = {
    id?: true
    storyId?: true
    actorId?: true
    action?: true
    note?: true
    createdAt?: true
  }

  export type StoryAuditLogMaxAggregateInputType = {
    id?: true
    storyId?: true
    actorId?: true
    action?: true
    note?: true
    createdAt?: true
  }

  export type StoryAuditLogCountAggregateInputType = {
    id?: true
    storyId?: true
    actorId?: true
    action?: true
    note?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type StoryAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryAuditLog to aggregate.
     */
    where?: StoryAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryAuditLogs to fetch.
     */
    orderBy?: StoryAuditLogOrderByWithRelationInput | StoryAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryAuditLogs
    **/
    _count?: true | StoryAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryAuditLogMaxAggregateInputType
  }

  export type GetStoryAuditLogAggregateType<T extends StoryAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryAuditLog[P]>
      : GetScalarType<T[P], AggregateStoryAuditLog[P]>
  }




  export type StoryAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryAuditLogWhereInput
    orderBy?: StoryAuditLogOrderByWithAggregationInput | StoryAuditLogOrderByWithAggregationInput[]
    by: StoryAuditLogScalarFieldEnum[] | StoryAuditLogScalarFieldEnum
    having?: StoryAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryAuditLogCountAggregateInputType | true
    _min?: StoryAuditLogMinAggregateInputType
    _max?: StoryAuditLogMaxAggregateInputType
  }

  export type StoryAuditLogGroupByOutputType = {
    id: string
    storyId: string
    actorId: string | null
    action: string
    note: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: StoryAuditLogCountAggregateOutputType | null
    _min: StoryAuditLogMinAggregateOutputType | null
    _max: StoryAuditLogMaxAggregateOutputType | null
  }

  type GetStoryAuditLogGroupByPayload<T extends StoryAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], StoryAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type StoryAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    actorId?: boolean
    action?: boolean
    note?: boolean
    metadata?: boolean
    createdAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    actor?: boolean | StoryAuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["storyAuditLog"]>

  export type StoryAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    actorId?: boolean
    action?: boolean
    note?: boolean
    metadata?: boolean
    createdAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    actor?: boolean | StoryAuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["storyAuditLog"]>

  export type StoryAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    actorId?: boolean
    action?: boolean
    note?: boolean
    metadata?: boolean
    createdAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    actor?: boolean | StoryAuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["storyAuditLog"]>

  export type StoryAuditLogSelectScalar = {
    id?: boolean
    storyId?: boolean
    actorId?: boolean
    action?: boolean
    note?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type StoryAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storyId" | "actorId" | "action" | "note" | "metadata" | "createdAt", ExtArgs["result"]["storyAuditLog"]>
  export type StoryAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    actor?: boolean | StoryAuditLog$actorArgs<ExtArgs>
  }
  export type StoryAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    actor?: boolean | StoryAuditLog$actorArgs<ExtArgs>
  }
  export type StoryAuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    actor?: boolean | StoryAuditLog$actorArgs<ExtArgs>
  }

  export type $StoryAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryAuditLog"
    objects: {
      story: Prisma.$TwineStoryPayload<ExtArgs>
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storyId: string
      actorId: string | null
      action: string
      note: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["storyAuditLog"]>
    composites: {}
  }

  type StoryAuditLogGetPayload<S extends boolean | null | undefined | StoryAuditLogDefaultArgs> = $Result.GetResult<Prisma.$StoryAuditLogPayload, S>

  type StoryAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryAuditLogCountAggregateInputType | true
    }

  export interface StoryAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryAuditLog'], meta: { name: 'StoryAuditLog' } }
    /**
     * Find zero or one StoryAuditLog that matches the filter.
     * @param {StoryAuditLogFindUniqueArgs} args - Arguments to find a StoryAuditLog
     * @example
     * // Get one StoryAuditLog
     * const storyAuditLog = await prisma.storyAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryAuditLogFindUniqueArgs>(args: SelectSubset<T, StoryAuditLogFindUniqueArgs<ExtArgs>>): Prisma__StoryAuditLogClient<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoryAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryAuditLogFindUniqueOrThrowArgs} args - Arguments to find a StoryAuditLog
     * @example
     * // Get one StoryAuditLog
     * const storyAuditLog = await prisma.storyAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryAuditLogClient<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAuditLogFindFirstArgs} args - Arguments to find a StoryAuditLog
     * @example
     * // Get one StoryAuditLog
     * const storyAuditLog = await prisma.storyAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryAuditLogFindFirstArgs>(args?: SelectSubset<T, StoryAuditLogFindFirstArgs<ExtArgs>>): Prisma__StoryAuditLogClient<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAuditLogFindFirstOrThrowArgs} args - Arguments to find a StoryAuditLog
     * @example
     * // Get one StoryAuditLog
     * const storyAuditLog = await prisma.storyAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryAuditLogClient<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoryAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryAuditLogs
     * const storyAuditLogs = await prisma.storyAuditLog.findMany()
     * 
     * // Get first 10 StoryAuditLogs
     * const storyAuditLogs = await prisma.storyAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyAuditLogWithIdOnly = await prisma.storyAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryAuditLogFindManyArgs>(args?: SelectSubset<T, StoryAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoryAuditLog.
     * @param {StoryAuditLogCreateArgs} args - Arguments to create a StoryAuditLog.
     * @example
     * // Create one StoryAuditLog
     * const StoryAuditLog = await prisma.storyAuditLog.create({
     *   data: {
     *     // ... data to create a StoryAuditLog
     *   }
     * })
     * 
     */
    create<T extends StoryAuditLogCreateArgs>(args: SelectSubset<T, StoryAuditLogCreateArgs<ExtArgs>>): Prisma__StoryAuditLogClient<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoryAuditLogs.
     * @param {StoryAuditLogCreateManyArgs} args - Arguments to create many StoryAuditLogs.
     * @example
     * // Create many StoryAuditLogs
     * const storyAuditLog = await prisma.storyAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryAuditLogCreateManyArgs>(args?: SelectSubset<T, StoryAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryAuditLogs and returns the data saved in the database.
     * @param {StoryAuditLogCreateManyAndReturnArgs} args - Arguments to create many StoryAuditLogs.
     * @example
     * // Create many StoryAuditLogs
     * const storyAuditLog = await prisma.storyAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryAuditLogs and only return the `id`
     * const storyAuditLogWithIdOnly = await prisma.storyAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoryAuditLog.
     * @param {StoryAuditLogDeleteArgs} args - Arguments to delete one StoryAuditLog.
     * @example
     * // Delete one StoryAuditLog
     * const StoryAuditLog = await prisma.storyAuditLog.delete({
     *   where: {
     *     // ... filter to delete one StoryAuditLog
     *   }
     * })
     * 
     */
    delete<T extends StoryAuditLogDeleteArgs>(args: SelectSubset<T, StoryAuditLogDeleteArgs<ExtArgs>>): Prisma__StoryAuditLogClient<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoryAuditLog.
     * @param {StoryAuditLogUpdateArgs} args - Arguments to update one StoryAuditLog.
     * @example
     * // Update one StoryAuditLog
     * const storyAuditLog = await prisma.storyAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryAuditLogUpdateArgs>(args: SelectSubset<T, StoryAuditLogUpdateArgs<ExtArgs>>): Prisma__StoryAuditLogClient<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoryAuditLogs.
     * @param {StoryAuditLogDeleteManyArgs} args - Arguments to filter StoryAuditLogs to delete.
     * @example
     * // Delete a few StoryAuditLogs
     * const { count } = await prisma.storyAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryAuditLogDeleteManyArgs>(args?: SelectSubset<T, StoryAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryAuditLogs
     * const storyAuditLog = await prisma.storyAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryAuditLogUpdateManyArgs>(args: SelectSubset<T, StoryAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryAuditLogs and returns the data updated in the database.
     * @param {StoryAuditLogUpdateManyAndReturnArgs} args - Arguments to update many StoryAuditLogs.
     * @example
     * // Update many StoryAuditLogs
     * const storyAuditLog = await prisma.storyAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoryAuditLogs and only return the `id`
     * const storyAuditLogWithIdOnly = await prisma.storyAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoryAuditLog.
     * @param {StoryAuditLogUpsertArgs} args - Arguments to update or create a StoryAuditLog.
     * @example
     * // Update or create a StoryAuditLog
     * const storyAuditLog = await prisma.storyAuditLog.upsert({
     *   create: {
     *     // ... data to create a StoryAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends StoryAuditLogUpsertArgs>(args: SelectSubset<T, StoryAuditLogUpsertArgs<ExtArgs>>): Prisma__StoryAuditLogClient<$Result.GetResult<Prisma.$StoryAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoryAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAuditLogCountArgs} args - Arguments to filter StoryAuditLogs to count.
     * @example
     * // Count the number of StoryAuditLogs
     * const count = await prisma.storyAuditLog.count({
     *   where: {
     *     // ... the filter for the StoryAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends StoryAuditLogCountArgs>(
      args?: Subset<T, StoryAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryAuditLogAggregateArgs>(args: Subset<T, StoryAuditLogAggregateArgs>): Prisma.PrismaPromise<GetStoryAuditLogAggregateType<T>>

    /**
     * Group by StoryAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: StoryAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryAuditLog model
   */
  readonly fields: StoryAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends TwineStoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TwineStoryDefaultArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    actor<T extends StoryAuditLog$actorArgs<ExtArgs> = {}>(args?: Subset<T, StoryAuditLog$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryAuditLog model
   */
  interface StoryAuditLogFieldRefs {
    readonly id: FieldRef<"StoryAuditLog", 'String'>
    readonly storyId: FieldRef<"StoryAuditLog", 'String'>
    readonly actorId: FieldRef<"StoryAuditLog", 'String'>
    readonly action: FieldRef<"StoryAuditLog", 'String'>
    readonly note: FieldRef<"StoryAuditLog", 'String'>
    readonly metadata: FieldRef<"StoryAuditLog", 'Json'>
    readonly createdAt: FieldRef<"StoryAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoryAuditLog findUnique
   */
  export type StoryAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which StoryAuditLog to fetch.
     */
    where: StoryAuditLogWhereUniqueInput
  }

  /**
   * StoryAuditLog findUniqueOrThrow
   */
  export type StoryAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which StoryAuditLog to fetch.
     */
    where: StoryAuditLogWhereUniqueInput
  }

  /**
   * StoryAuditLog findFirst
   */
  export type StoryAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which StoryAuditLog to fetch.
     */
    where?: StoryAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryAuditLogs to fetch.
     */
    orderBy?: StoryAuditLogOrderByWithRelationInput | StoryAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryAuditLogs.
     */
    cursor?: StoryAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryAuditLogs.
     */
    distinct?: StoryAuditLogScalarFieldEnum | StoryAuditLogScalarFieldEnum[]
  }

  /**
   * StoryAuditLog findFirstOrThrow
   */
  export type StoryAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which StoryAuditLog to fetch.
     */
    where?: StoryAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryAuditLogs to fetch.
     */
    orderBy?: StoryAuditLogOrderByWithRelationInput | StoryAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryAuditLogs.
     */
    cursor?: StoryAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryAuditLogs.
     */
    distinct?: StoryAuditLogScalarFieldEnum | StoryAuditLogScalarFieldEnum[]
  }

  /**
   * StoryAuditLog findMany
   */
  export type StoryAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which StoryAuditLogs to fetch.
     */
    where?: StoryAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryAuditLogs to fetch.
     */
    orderBy?: StoryAuditLogOrderByWithRelationInput | StoryAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryAuditLogs.
     */
    cursor?: StoryAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryAuditLogs.
     */
    skip?: number
    distinct?: StoryAuditLogScalarFieldEnum | StoryAuditLogScalarFieldEnum[]
  }

  /**
   * StoryAuditLog create
   */
  export type StoryAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryAuditLog.
     */
    data: XOR<StoryAuditLogCreateInput, StoryAuditLogUncheckedCreateInput>
  }

  /**
   * StoryAuditLog createMany
   */
  export type StoryAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryAuditLogs.
     */
    data: StoryAuditLogCreateManyInput | StoryAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryAuditLog createManyAndReturn
   */
  export type StoryAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many StoryAuditLogs.
     */
    data: StoryAuditLogCreateManyInput | StoryAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryAuditLog update
   */
  export type StoryAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryAuditLog.
     */
    data: XOR<StoryAuditLogUpdateInput, StoryAuditLogUncheckedUpdateInput>
    /**
     * Choose, which StoryAuditLog to update.
     */
    where: StoryAuditLogWhereUniqueInput
  }

  /**
   * StoryAuditLog updateMany
   */
  export type StoryAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryAuditLogs.
     */
    data: XOR<StoryAuditLogUpdateManyMutationInput, StoryAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which StoryAuditLogs to update
     */
    where?: StoryAuditLogWhereInput
    /**
     * Limit how many StoryAuditLogs to update.
     */
    limit?: number
  }

  /**
   * StoryAuditLog updateManyAndReturn
   */
  export type StoryAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update StoryAuditLogs.
     */
    data: XOR<StoryAuditLogUpdateManyMutationInput, StoryAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which StoryAuditLogs to update
     */
    where?: StoryAuditLogWhereInput
    /**
     * Limit how many StoryAuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryAuditLog upsert
   */
  export type StoryAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryAuditLog to update in case it exists.
     */
    where: StoryAuditLogWhereUniqueInput
    /**
     * In case the StoryAuditLog found by the `where` argument doesn't exist, create a new StoryAuditLog with this data.
     */
    create: XOR<StoryAuditLogCreateInput, StoryAuditLogUncheckedCreateInput>
    /**
     * In case the StoryAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryAuditLogUpdateInput, StoryAuditLogUncheckedUpdateInput>
  }

  /**
   * StoryAuditLog delete
   */
  export type StoryAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogInclude<ExtArgs> | null
    /**
     * Filter which StoryAuditLog to delete.
     */
    where: StoryAuditLogWhereUniqueInput
  }

  /**
   * StoryAuditLog deleteMany
   */
  export type StoryAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryAuditLogs to delete
     */
    where?: StoryAuditLogWhereInput
    /**
     * Limit how many StoryAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * StoryAuditLog.actor
   */
  export type StoryAuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StoryAuditLog without action
   */
  export type StoryAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryAuditLog
     */
    select?: StoryAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryAuditLog
     */
    omit?: StoryAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model StoryReview
   */

  export type AggregateStoryReview = {
    _count: StoryReviewCountAggregateOutputType | null
    _min: StoryReviewMinAggregateOutputType | null
    _max: StoryReviewMaxAggregateOutputType | null
  }

  export type StoryReviewMinAggregateOutputType = {
    id: string | null
    versionId: string | null
    reviewerId: string | null
    status: $Enums.StoryStatus | null
    feedback: string | null
    createdAt: Date | null
  }

  export type StoryReviewMaxAggregateOutputType = {
    id: string | null
    versionId: string | null
    reviewerId: string | null
    status: $Enums.StoryStatus | null
    feedback: string | null
    createdAt: Date | null
  }

  export type StoryReviewCountAggregateOutputType = {
    id: number
    versionId: number
    reviewerId: number
    status: number
    feedback: number
    createdAt: number
    _all: number
  }


  export type StoryReviewMinAggregateInputType = {
    id?: true
    versionId?: true
    reviewerId?: true
    status?: true
    feedback?: true
    createdAt?: true
  }

  export type StoryReviewMaxAggregateInputType = {
    id?: true
    versionId?: true
    reviewerId?: true
    status?: true
    feedback?: true
    createdAt?: true
  }

  export type StoryReviewCountAggregateInputType = {
    id?: true
    versionId?: true
    reviewerId?: true
    status?: true
    feedback?: true
    createdAt?: true
    _all?: true
  }

  export type StoryReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryReview to aggregate.
     */
    where?: StoryReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryReviews to fetch.
     */
    orderBy?: StoryReviewOrderByWithRelationInput | StoryReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryReviews
    **/
    _count?: true | StoryReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryReviewMaxAggregateInputType
  }

  export type GetStoryReviewAggregateType<T extends StoryReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryReview[P]>
      : GetScalarType<T[P], AggregateStoryReview[P]>
  }




  export type StoryReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryReviewWhereInput
    orderBy?: StoryReviewOrderByWithAggregationInput | StoryReviewOrderByWithAggregationInput[]
    by: StoryReviewScalarFieldEnum[] | StoryReviewScalarFieldEnum
    having?: StoryReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryReviewCountAggregateInputType | true
    _min?: StoryReviewMinAggregateInputType
    _max?: StoryReviewMaxAggregateInputType
  }

  export type StoryReviewGroupByOutputType = {
    id: string
    versionId: string
    reviewerId: string
    status: $Enums.StoryStatus
    feedback: string | null
    createdAt: Date
    _count: StoryReviewCountAggregateOutputType | null
    _min: StoryReviewMinAggregateOutputType | null
    _max: StoryReviewMaxAggregateOutputType | null
  }

  type GetStoryReviewGroupByPayload<T extends StoryReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryReviewGroupByOutputType[P]>
            : GetScalarType<T[P], StoryReviewGroupByOutputType[P]>
        }
      >
    >


  export type StoryReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    versionId?: boolean
    reviewerId?: boolean
    status?: boolean
    feedback?: boolean
    createdAt?: boolean
    version?: boolean | StoryVersionDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyReview"]>

  export type StoryReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    versionId?: boolean
    reviewerId?: boolean
    status?: boolean
    feedback?: boolean
    createdAt?: boolean
    version?: boolean | StoryVersionDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyReview"]>

  export type StoryReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    versionId?: boolean
    reviewerId?: boolean
    status?: boolean
    feedback?: boolean
    createdAt?: boolean
    version?: boolean | StoryVersionDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyReview"]>

  export type StoryReviewSelectScalar = {
    id?: boolean
    versionId?: boolean
    reviewerId?: boolean
    status?: boolean
    feedback?: boolean
    createdAt?: boolean
  }

  export type StoryReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "versionId" | "reviewerId" | "status" | "feedback" | "createdAt", ExtArgs["result"]["storyReview"]>
  export type StoryReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version?: boolean | StoryVersionDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StoryReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version?: boolean | StoryVersionDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StoryReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version?: boolean | StoryVersionDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StoryReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryReview"
    objects: {
      version: Prisma.$StoryVersionPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      versionId: string
      reviewerId: string
      status: $Enums.StoryStatus
      feedback: string | null
      createdAt: Date
    }, ExtArgs["result"]["storyReview"]>
    composites: {}
  }

  type StoryReviewGetPayload<S extends boolean | null | undefined | StoryReviewDefaultArgs> = $Result.GetResult<Prisma.$StoryReviewPayload, S>

  type StoryReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryReviewCountAggregateInputType | true
    }

  export interface StoryReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryReview'], meta: { name: 'StoryReview' } }
    /**
     * Find zero or one StoryReview that matches the filter.
     * @param {StoryReviewFindUniqueArgs} args - Arguments to find a StoryReview
     * @example
     * // Get one StoryReview
     * const storyReview = await prisma.storyReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryReviewFindUniqueArgs>(args: SelectSubset<T, StoryReviewFindUniqueArgs<ExtArgs>>): Prisma__StoryReviewClient<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoryReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryReviewFindUniqueOrThrowArgs} args - Arguments to find a StoryReview
     * @example
     * // Get one StoryReview
     * const storyReview = await prisma.storyReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryReviewClient<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryReviewFindFirstArgs} args - Arguments to find a StoryReview
     * @example
     * // Get one StoryReview
     * const storyReview = await prisma.storyReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryReviewFindFirstArgs>(args?: SelectSubset<T, StoryReviewFindFirstArgs<ExtArgs>>): Prisma__StoryReviewClient<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryReviewFindFirstOrThrowArgs} args - Arguments to find a StoryReview
     * @example
     * // Get one StoryReview
     * const storyReview = await prisma.storyReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryReviewClient<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoryReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryReviews
     * const storyReviews = await prisma.storyReview.findMany()
     * 
     * // Get first 10 StoryReviews
     * const storyReviews = await prisma.storyReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyReviewWithIdOnly = await prisma.storyReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryReviewFindManyArgs>(args?: SelectSubset<T, StoryReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoryReview.
     * @param {StoryReviewCreateArgs} args - Arguments to create a StoryReview.
     * @example
     * // Create one StoryReview
     * const StoryReview = await prisma.storyReview.create({
     *   data: {
     *     // ... data to create a StoryReview
     *   }
     * })
     * 
     */
    create<T extends StoryReviewCreateArgs>(args: SelectSubset<T, StoryReviewCreateArgs<ExtArgs>>): Prisma__StoryReviewClient<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoryReviews.
     * @param {StoryReviewCreateManyArgs} args - Arguments to create many StoryReviews.
     * @example
     * // Create many StoryReviews
     * const storyReview = await prisma.storyReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryReviewCreateManyArgs>(args?: SelectSubset<T, StoryReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryReviews and returns the data saved in the database.
     * @param {StoryReviewCreateManyAndReturnArgs} args - Arguments to create many StoryReviews.
     * @example
     * // Create many StoryReviews
     * const storyReview = await prisma.storyReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryReviews and only return the `id`
     * const storyReviewWithIdOnly = await prisma.storyReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoryReview.
     * @param {StoryReviewDeleteArgs} args - Arguments to delete one StoryReview.
     * @example
     * // Delete one StoryReview
     * const StoryReview = await prisma.storyReview.delete({
     *   where: {
     *     // ... filter to delete one StoryReview
     *   }
     * })
     * 
     */
    delete<T extends StoryReviewDeleteArgs>(args: SelectSubset<T, StoryReviewDeleteArgs<ExtArgs>>): Prisma__StoryReviewClient<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoryReview.
     * @param {StoryReviewUpdateArgs} args - Arguments to update one StoryReview.
     * @example
     * // Update one StoryReview
     * const storyReview = await prisma.storyReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryReviewUpdateArgs>(args: SelectSubset<T, StoryReviewUpdateArgs<ExtArgs>>): Prisma__StoryReviewClient<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoryReviews.
     * @param {StoryReviewDeleteManyArgs} args - Arguments to filter StoryReviews to delete.
     * @example
     * // Delete a few StoryReviews
     * const { count } = await prisma.storyReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryReviewDeleteManyArgs>(args?: SelectSubset<T, StoryReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryReviews
     * const storyReview = await prisma.storyReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryReviewUpdateManyArgs>(args: SelectSubset<T, StoryReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryReviews and returns the data updated in the database.
     * @param {StoryReviewUpdateManyAndReturnArgs} args - Arguments to update many StoryReviews.
     * @example
     * // Update many StoryReviews
     * const storyReview = await prisma.storyReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoryReviews and only return the `id`
     * const storyReviewWithIdOnly = await prisma.storyReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoryReview.
     * @param {StoryReviewUpsertArgs} args - Arguments to update or create a StoryReview.
     * @example
     * // Update or create a StoryReview
     * const storyReview = await prisma.storyReview.upsert({
     *   create: {
     *     // ... data to create a StoryReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryReview we want to update
     *   }
     * })
     */
    upsert<T extends StoryReviewUpsertArgs>(args: SelectSubset<T, StoryReviewUpsertArgs<ExtArgs>>): Prisma__StoryReviewClient<$Result.GetResult<Prisma.$StoryReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoryReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryReviewCountArgs} args - Arguments to filter StoryReviews to count.
     * @example
     * // Count the number of StoryReviews
     * const count = await prisma.storyReview.count({
     *   where: {
     *     // ... the filter for the StoryReviews we want to count
     *   }
     * })
    **/
    count<T extends StoryReviewCountArgs>(
      args?: Subset<T, StoryReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryReviewAggregateArgs>(args: Subset<T, StoryReviewAggregateArgs>): Prisma.PrismaPromise<GetStoryReviewAggregateType<T>>

    /**
     * Group by StoryReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryReviewGroupByArgs['orderBy'] }
        : { orderBy?: StoryReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryReview model
   */
  readonly fields: StoryReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    version<T extends StoryVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoryVersionDefaultArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryReview model
   */
  interface StoryReviewFieldRefs {
    readonly id: FieldRef<"StoryReview", 'String'>
    readonly versionId: FieldRef<"StoryReview", 'String'>
    readonly reviewerId: FieldRef<"StoryReview", 'String'>
    readonly status: FieldRef<"StoryReview", 'StoryStatus'>
    readonly feedback: FieldRef<"StoryReview", 'String'>
    readonly createdAt: FieldRef<"StoryReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoryReview findUnique
   */
  export type StoryReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewInclude<ExtArgs> | null
    /**
     * Filter, which StoryReview to fetch.
     */
    where: StoryReviewWhereUniqueInput
  }

  /**
   * StoryReview findUniqueOrThrow
   */
  export type StoryReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewInclude<ExtArgs> | null
    /**
     * Filter, which StoryReview to fetch.
     */
    where: StoryReviewWhereUniqueInput
  }

  /**
   * StoryReview findFirst
   */
  export type StoryReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewInclude<ExtArgs> | null
    /**
     * Filter, which StoryReview to fetch.
     */
    where?: StoryReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryReviews to fetch.
     */
    orderBy?: StoryReviewOrderByWithRelationInput | StoryReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryReviews.
     */
    cursor?: StoryReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryReviews.
     */
    distinct?: StoryReviewScalarFieldEnum | StoryReviewScalarFieldEnum[]
  }

  /**
   * StoryReview findFirstOrThrow
   */
  export type StoryReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewInclude<ExtArgs> | null
    /**
     * Filter, which StoryReview to fetch.
     */
    where?: StoryReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryReviews to fetch.
     */
    orderBy?: StoryReviewOrderByWithRelationInput | StoryReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryReviews.
     */
    cursor?: StoryReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryReviews.
     */
    distinct?: StoryReviewScalarFieldEnum | StoryReviewScalarFieldEnum[]
  }

  /**
   * StoryReview findMany
   */
  export type StoryReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewInclude<ExtArgs> | null
    /**
     * Filter, which StoryReviews to fetch.
     */
    where?: StoryReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryReviews to fetch.
     */
    orderBy?: StoryReviewOrderByWithRelationInput | StoryReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryReviews.
     */
    cursor?: StoryReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryReviews.
     */
    skip?: number
    distinct?: StoryReviewScalarFieldEnum | StoryReviewScalarFieldEnum[]
  }

  /**
   * StoryReview create
   */
  export type StoryReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryReview.
     */
    data: XOR<StoryReviewCreateInput, StoryReviewUncheckedCreateInput>
  }

  /**
   * StoryReview createMany
   */
  export type StoryReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryReviews.
     */
    data: StoryReviewCreateManyInput | StoryReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryReview createManyAndReturn
   */
  export type StoryReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * The data used to create many StoryReviews.
     */
    data: StoryReviewCreateManyInput | StoryReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryReview update
   */
  export type StoryReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryReview.
     */
    data: XOR<StoryReviewUpdateInput, StoryReviewUncheckedUpdateInput>
    /**
     * Choose, which StoryReview to update.
     */
    where: StoryReviewWhereUniqueInput
  }

  /**
   * StoryReview updateMany
   */
  export type StoryReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryReviews.
     */
    data: XOR<StoryReviewUpdateManyMutationInput, StoryReviewUncheckedUpdateManyInput>
    /**
     * Filter which StoryReviews to update
     */
    where?: StoryReviewWhereInput
    /**
     * Limit how many StoryReviews to update.
     */
    limit?: number
  }

  /**
   * StoryReview updateManyAndReturn
   */
  export type StoryReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * The data used to update StoryReviews.
     */
    data: XOR<StoryReviewUpdateManyMutationInput, StoryReviewUncheckedUpdateManyInput>
    /**
     * Filter which StoryReviews to update
     */
    where?: StoryReviewWhereInput
    /**
     * Limit how many StoryReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryReview upsert
   */
  export type StoryReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryReview to update in case it exists.
     */
    where: StoryReviewWhereUniqueInput
    /**
     * In case the StoryReview found by the `where` argument doesn't exist, create a new StoryReview with this data.
     */
    create: XOR<StoryReviewCreateInput, StoryReviewUncheckedCreateInput>
    /**
     * In case the StoryReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryReviewUpdateInput, StoryReviewUncheckedUpdateInput>
  }

  /**
   * StoryReview delete
   */
  export type StoryReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewInclude<ExtArgs> | null
    /**
     * Filter which StoryReview to delete.
     */
    where: StoryReviewWhereUniqueInput
  }

  /**
   * StoryReview deleteMany
   */
  export type StoryReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryReviews to delete
     */
    where?: StoryReviewWhereInput
    /**
     * Limit how many StoryReviews to delete.
     */
    limit?: number
  }

  /**
   * StoryReview without action
   */
  export type StoryReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryReview
     */
    select?: StoryReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryReview
     */
    omit?: StoryReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryReviewInclude<ExtArgs> | null
  }


  /**
   * Model StoryPlaySession
   */

  export type AggregateStoryPlaySession = {
    _count: StoryPlaySessionCountAggregateOutputType | null
    _avg: StoryPlaySessionAvgAggregateOutputType | null
    _sum: StoryPlaySessionSumAggregateOutputType | null
    _min: StoryPlaySessionMinAggregateOutputType | null
    _max: StoryPlaySessionMaxAggregateOutputType | null
  }

  export type StoryPlaySessionAvgAggregateOutputType = {
    rating: number | null
  }

  export type StoryPlaySessionSumAggregateOutputType = {
    rating: number | null
  }

  export type StoryPlaySessionMinAggregateOutputType = {
    id: string | null
    storyId: string | null
    versionId: string | null
    userId: string | null
    sessionId: string | null
    startedAt: Date | null
    completedAt: Date | null
    rating: number | null
    feedback: string | null
  }

  export type StoryPlaySessionMaxAggregateOutputType = {
    id: string | null
    storyId: string | null
    versionId: string | null
    userId: string | null
    sessionId: string | null
    startedAt: Date | null
    completedAt: Date | null
    rating: number | null
    feedback: string | null
  }

  export type StoryPlaySessionCountAggregateOutputType = {
    id: number
    storyId: number
    versionId: number
    userId: number
    sessionId: number
    startedAt: number
    completedAt: number
    progress: number
    rating: number
    feedback: number
    _all: number
  }


  export type StoryPlaySessionAvgAggregateInputType = {
    rating?: true
  }

  export type StoryPlaySessionSumAggregateInputType = {
    rating?: true
  }

  export type StoryPlaySessionMinAggregateInputType = {
    id?: true
    storyId?: true
    versionId?: true
    userId?: true
    sessionId?: true
    startedAt?: true
    completedAt?: true
    rating?: true
    feedback?: true
  }

  export type StoryPlaySessionMaxAggregateInputType = {
    id?: true
    storyId?: true
    versionId?: true
    userId?: true
    sessionId?: true
    startedAt?: true
    completedAt?: true
    rating?: true
    feedback?: true
  }

  export type StoryPlaySessionCountAggregateInputType = {
    id?: true
    storyId?: true
    versionId?: true
    userId?: true
    sessionId?: true
    startedAt?: true
    completedAt?: true
    progress?: true
    rating?: true
    feedback?: true
    _all?: true
  }

  export type StoryPlaySessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryPlaySession to aggregate.
     */
    where?: StoryPlaySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryPlaySessions to fetch.
     */
    orderBy?: StoryPlaySessionOrderByWithRelationInput | StoryPlaySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryPlaySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryPlaySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryPlaySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryPlaySessions
    **/
    _count?: true | StoryPlaySessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoryPlaySessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoryPlaySessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryPlaySessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryPlaySessionMaxAggregateInputType
  }

  export type GetStoryPlaySessionAggregateType<T extends StoryPlaySessionAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryPlaySession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryPlaySession[P]>
      : GetScalarType<T[P], AggregateStoryPlaySession[P]>
  }




  export type StoryPlaySessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryPlaySessionWhereInput
    orderBy?: StoryPlaySessionOrderByWithAggregationInput | StoryPlaySessionOrderByWithAggregationInput[]
    by: StoryPlaySessionScalarFieldEnum[] | StoryPlaySessionScalarFieldEnum
    having?: StoryPlaySessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryPlaySessionCountAggregateInputType | true
    _avg?: StoryPlaySessionAvgAggregateInputType
    _sum?: StoryPlaySessionSumAggregateInputType
    _min?: StoryPlaySessionMinAggregateInputType
    _max?: StoryPlaySessionMaxAggregateInputType
  }

  export type StoryPlaySessionGroupByOutputType = {
    id: string
    storyId: string
    versionId: string | null
    userId: string | null
    sessionId: string | null
    startedAt: Date
    completedAt: Date | null
    progress: JsonValue | null
    rating: number | null
    feedback: string | null
    _count: StoryPlaySessionCountAggregateOutputType | null
    _avg: StoryPlaySessionAvgAggregateOutputType | null
    _sum: StoryPlaySessionSumAggregateOutputType | null
    _min: StoryPlaySessionMinAggregateOutputType | null
    _max: StoryPlaySessionMaxAggregateOutputType | null
  }

  type GetStoryPlaySessionGroupByPayload<T extends StoryPlaySessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryPlaySessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryPlaySessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryPlaySessionGroupByOutputType[P]>
            : GetScalarType<T[P], StoryPlaySessionGroupByOutputType[P]>
        }
      >
    >


  export type StoryPlaySessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    versionId?: boolean
    userId?: boolean
    sessionId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    progress?: boolean
    rating?: boolean
    feedback?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    version?: boolean | StoryPlaySession$versionArgs<ExtArgs>
    user?: boolean | StoryPlaySession$userArgs<ExtArgs>
    session?: boolean | StoryPlaySession$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["storyPlaySession"]>

  export type StoryPlaySessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    versionId?: boolean
    userId?: boolean
    sessionId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    progress?: boolean
    rating?: boolean
    feedback?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    version?: boolean | StoryPlaySession$versionArgs<ExtArgs>
    user?: boolean | StoryPlaySession$userArgs<ExtArgs>
    session?: boolean | StoryPlaySession$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["storyPlaySession"]>

  export type StoryPlaySessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    versionId?: boolean
    userId?: boolean
    sessionId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    progress?: boolean
    rating?: boolean
    feedback?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    version?: boolean | StoryPlaySession$versionArgs<ExtArgs>
    user?: boolean | StoryPlaySession$userArgs<ExtArgs>
    session?: boolean | StoryPlaySession$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["storyPlaySession"]>

  export type StoryPlaySessionSelectScalar = {
    id?: boolean
    storyId?: boolean
    versionId?: boolean
    userId?: boolean
    sessionId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    progress?: boolean
    rating?: boolean
    feedback?: boolean
  }

  export type StoryPlaySessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storyId" | "versionId" | "userId" | "sessionId" | "startedAt" | "completedAt" | "progress" | "rating" | "feedback", ExtArgs["result"]["storyPlaySession"]>
  export type StoryPlaySessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    version?: boolean | StoryPlaySession$versionArgs<ExtArgs>
    user?: boolean | StoryPlaySession$userArgs<ExtArgs>
    session?: boolean | StoryPlaySession$sessionArgs<ExtArgs>
  }
  export type StoryPlaySessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    version?: boolean | StoryPlaySession$versionArgs<ExtArgs>
    user?: boolean | StoryPlaySession$userArgs<ExtArgs>
    session?: boolean | StoryPlaySession$sessionArgs<ExtArgs>
  }
  export type StoryPlaySessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    version?: boolean | StoryPlaySession$versionArgs<ExtArgs>
    user?: boolean | StoryPlaySession$userArgs<ExtArgs>
    session?: boolean | StoryPlaySession$sessionArgs<ExtArgs>
  }

  export type $StoryPlaySessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryPlaySession"
    objects: {
      story: Prisma.$TwineStoryPayload<ExtArgs>
      version: Prisma.$StoryVersionPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      session: Prisma.$UserSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storyId: string
      versionId: string | null
      userId: string | null
      sessionId: string | null
      startedAt: Date
      completedAt: Date | null
      progress: Prisma.JsonValue | null
      rating: number | null
      feedback: string | null
    }, ExtArgs["result"]["storyPlaySession"]>
    composites: {}
  }

  type StoryPlaySessionGetPayload<S extends boolean | null | undefined | StoryPlaySessionDefaultArgs> = $Result.GetResult<Prisma.$StoryPlaySessionPayload, S>

  type StoryPlaySessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryPlaySessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryPlaySessionCountAggregateInputType | true
    }

  export interface StoryPlaySessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryPlaySession'], meta: { name: 'StoryPlaySession' } }
    /**
     * Find zero or one StoryPlaySession that matches the filter.
     * @param {StoryPlaySessionFindUniqueArgs} args - Arguments to find a StoryPlaySession
     * @example
     * // Get one StoryPlaySession
     * const storyPlaySession = await prisma.storyPlaySession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryPlaySessionFindUniqueArgs>(args: SelectSubset<T, StoryPlaySessionFindUniqueArgs<ExtArgs>>): Prisma__StoryPlaySessionClient<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoryPlaySession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryPlaySessionFindUniqueOrThrowArgs} args - Arguments to find a StoryPlaySession
     * @example
     * // Get one StoryPlaySession
     * const storyPlaySession = await prisma.storyPlaySession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryPlaySessionFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryPlaySessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryPlaySessionClient<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryPlaySession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPlaySessionFindFirstArgs} args - Arguments to find a StoryPlaySession
     * @example
     * // Get one StoryPlaySession
     * const storyPlaySession = await prisma.storyPlaySession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryPlaySessionFindFirstArgs>(args?: SelectSubset<T, StoryPlaySessionFindFirstArgs<ExtArgs>>): Prisma__StoryPlaySessionClient<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryPlaySession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPlaySessionFindFirstOrThrowArgs} args - Arguments to find a StoryPlaySession
     * @example
     * // Get one StoryPlaySession
     * const storyPlaySession = await prisma.storyPlaySession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryPlaySessionFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryPlaySessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryPlaySessionClient<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoryPlaySessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPlaySessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryPlaySessions
     * const storyPlaySessions = await prisma.storyPlaySession.findMany()
     * 
     * // Get first 10 StoryPlaySessions
     * const storyPlaySessions = await prisma.storyPlaySession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyPlaySessionWithIdOnly = await prisma.storyPlaySession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryPlaySessionFindManyArgs>(args?: SelectSubset<T, StoryPlaySessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoryPlaySession.
     * @param {StoryPlaySessionCreateArgs} args - Arguments to create a StoryPlaySession.
     * @example
     * // Create one StoryPlaySession
     * const StoryPlaySession = await prisma.storyPlaySession.create({
     *   data: {
     *     // ... data to create a StoryPlaySession
     *   }
     * })
     * 
     */
    create<T extends StoryPlaySessionCreateArgs>(args: SelectSubset<T, StoryPlaySessionCreateArgs<ExtArgs>>): Prisma__StoryPlaySessionClient<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoryPlaySessions.
     * @param {StoryPlaySessionCreateManyArgs} args - Arguments to create many StoryPlaySessions.
     * @example
     * // Create many StoryPlaySessions
     * const storyPlaySession = await prisma.storyPlaySession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryPlaySessionCreateManyArgs>(args?: SelectSubset<T, StoryPlaySessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryPlaySessions and returns the data saved in the database.
     * @param {StoryPlaySessionCreateManyAndReturnArgs} args - Arguments to create many StoryPlaySessions.
     * @example
     * // Create many StoryPlaySessions
     * const storyPlaySession = await prisma.storyPlaySession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryPlaySessions and only return the `id`
     * const storyPlaySessionWithIdOnly = await prisma.storyPlaySession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryPlaySessionCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryPlaySessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoryPlaySession.
     * @param {StoryPlaySessionDeleteArgs} args - Arguments to delete one StoryPlaySession.
     * @example
     * // Delete one StoryPlaySession
     * const StoryPlaySession = await prisma.storyPlaySession.delete({
     *   where: {
     *     // ... filter to delete one StoryPlaySession
     *   }
     * })
     * 
     */
    delete<T extends StoryPlaySessionDeleteArgs>(args: SelectSubset<T, StoryPlaySessionDeleteArgs<ExtArgs>>): Prisma__StoryPlaySessionClient<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoryPlaySession.
     * @param {StoryPlaySessionUpdateArgs} args - Arguments to update one StoryPlaySession.
     * @example
     * // Update one StoryPlaySession
     * const storyPlaySession = await prisma.storyPlaySession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryPlaySessionUpdateArgs>(args: SelectSubset<T, StoryPlaySessionUpdateArgs<ExtArgs>>): Prisma__StoryPlaySessionClient<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoryPlaySessions.
     * @param {StoryPlaySessionDeleteManyArgs} args - Arguments to filter StoryPlaySessions to delete.
     * @example
     * // Delete a few StoryPlaySessions
     * const { count } = await prisma.storyPlaySession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryPlaySessionDeleteManyArgs>(args?: SelectSubset<T, StoryPlaySessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryPlaySessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPlaySessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryPlaySessions
     * const storyPlaySession = await prisma.storyPlaySession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryPlaySessionUpdateManyArgs>(args: SelectSubset<T, StoryPlaySessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryPlaySessions and returns the data updated in the database.
     * @param {StoryPlaySessionUpdateManyAndReturnArgs} args - Arguments to update many StoryPlaySessions.
     * @example
     * // Update many StoryPlaySessions
     * const storyPlaySession = await prisma.storyPlaySession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoryPlaySessions and only return the `id`
     * const storyPlaySessionWithIdOnly = await prisma.storyPlaySession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryPlaySessionUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryPlaySessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoryPlaySession.
     * @param {StoryPlaySessionUpsertArgs} args - Arguments to update or create a StoryPlaySession.
     * @example
     * // Update or create a StoryPlaySession
     * const storyPlaySession = await prisma.storyPlaySession.upsert({
     *   create: {
     *     // ... data to create a StoryPlaySession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryPlaySession we want to update
     *   }
     * })
     */
    upsert<T extends StoryPlaySessionUpsertArgs>(args: SelectSubset<T, StoryPlaySessionUpsertArgs<ExtArgs>>): Prisma__StoryPlaySessionClient<$Result.GetResult<Prisma.$StoryPlaySessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoryPlaySessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPlaySessionCountArgs} args - Arguments to filter StoryPlaySessions to count.
     * @example
     * // Count the number of StoryPlaySessions
     * const count = await prisma.storyPlaySession.count({
     *   where: {
     *     // ... the filter for the StoryPlaySessions we want to count
     *   }
     * })
    **/
    count<T extends StoryPlaySessionCountArgs>(
      args?: Subset<T, StoryPlaySessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryPlaySessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryPlaySession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPlaySessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryPlaySessionAggregateArgs>(args: Subset<T, StoryPlaySessionAggregateArgs>): Prisma.PrismaPromise<GetStoryPlaySessionAggregateType<T>>

    /**
     * Group by StoryPlaySession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPlaySessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryPlaySessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryPlaySessionGroupByArgs['orderBy'] }
        : { orderBy?: StoryPlaySessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryPlaySessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryPlaySessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryPlaySession model
   */
  readonly fields: StoryPlaySessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryPlaySession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryPlaySessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends TwineStoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TwineStoryDefaultArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    version<T extends StoryPlaySession$versionArgs<ExtArgs> = {}>(args?: Subset<T, StoryPlaySession$versionArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends StoryPlaySession$userArgs<ExtArgs> = {}>(args?: Subset<T, StoryPlaySession$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    session<T extends StoryPlaySession$sessionArgs<ExtArgs> = {}>(args?: Subset<T, StoryPlaySession$sessionArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryPlaySession model
   */
  interface StoryPlaySessionFieldRefs {
    readonly id: FieldRef<"StoryPlaySession", 'String'>
    readonly storyId: FieldRef<"StoryPlaySession", 'String'>
    readonly versionId: FieldRef<"StoryPlaySession", 'String'>
    readonly userId: FieldRef<"StoryPlaySession", 'String'>
    readonly sessionId: FieldRef<"StoryPlaySession", 'String'>
    readonly startedAt: FieldRef<"StoryPlaySession", 'DateTime'>
    readonly completedAt: FieldRef<"StoryPlaySession", 'DateTime'>
    readonly progress: FieldRef<"StoryPlaySession", 'Json'>
    readonly rating: FieldRef<"StoryPlaySession", 'Int'>
    readonly feedback: FieldRef<"StoryPlaySession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StoryPlaySession findUnique
   */
  export type StoryPlaySessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    /**
     * Filter, which StoryPlaySession to fetch.
     */
    where: StoryPlaySessionWhereUniqueInput
  }

  /**
   * StoryPlaySession findUniqueOrThrow
   */
  export type StoryPlaySessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    /**
     * Filter, which StoryPlaySession to fetch.
     */
    where: StoryPlaySessionWhereUniqueInput
  }

  /**
   * StoryPlaySession findFirst
   */
  export type StoryPlaySessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    /**
     * Filter, which StoryPlaySession to fetch.
     */
    where?: StoryPlaySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryPlaySessions to fetch.
     */
    orderBy?: StoryPlaySessionOrderByWithRelationInput | StoryPlaySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryPlaySessions.
     */
    cursor?: StoryPlaySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryPlaySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryPlaySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryPlaySessions.
     */
    distinct?: StoryPlaySessionScalarFieldEnum | StoryPlaySessionScalarFieldEnum[]
  }

  /**
   * StoryPlaySession findFirstOrThrow
   */
  export type StoryPlaySessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    /**
     * Filter, which StoryPlaySession to fetch.
     */
    where?: StoryPlaySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryPlaySessions to fetch.
     */
    orderBy?: StoryPlaySessionOrderByWithRelationInput | StoryPlaySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryPlaySessions.
     */
    cursor?: StoryPlaySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryPlaySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryPlaySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryPlaySessions.
     */
    distinct?: StoryPlaySessionScalarFieldEnum | StoryPlaySessionScalarFieldEnum[]
  }

  /**
   * StoryPlaySession findMany
   */
  export type StoryPlaySessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    /**
     * Filter, which StoryPlaySessions to fetch.
     */
    where?: StoryPlaySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryPlaySessions to fetch.
     */
    orderBy?: StoryPlaySessionOrderByWithRelationInput | StoryPlaySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryPlaySessions.
     */
    cursor?: StoryPlaySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryPlaySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryPlaySessions.
     */
    skip?: number
    distinct?: StoryPlaySessionScalarFieldEnum | StoryPlaySessionScalarFieldEnum[]
  }

  /**
   * StoryPlaySession create
   */
  export type StoryPlaySessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryPlaySession.
     */
    data: XOR<StoryPlaySessionCreateInput, StoryPlaySessionUncheckedCreateInput>
  }

  /**
   * StoryPlaySession createMany
   */
  export type StoryPlaySessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryPlaySessions.
     */
    data: StoryPlaySessionCreateManyInput | StoryPlaySessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryPlaySession createManyAndReturn
   */
  export type StoryPlaySessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * The data used to create many StoryPlaySessions.
     */
    data: StoryPlaySessionCreateManyInput | StoryPlaySessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryPlaySession update
   */
  export type StoryPlaySessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryPlaySession.
     */
    data: XOR<StoryPlaySessionUpdateInput, StoryPlaySessionUncheckedUpdateInput>
    /**
     * Choose, which StoryPlaySession to update.
     */
    where: StoryPlaySessionWhereUniqueInput
  }

  /**
   * StoryPlaySession updateMany
   */
  export type StoryPlaySessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryPlaySessions.
     */
    data: XOR<StoryPlaySessionUpdateManyMutationInput, StoryPlaySessionUncheckedUpdateManyInput>
    /**
     * Filter which StoryPlaySessions to update
     */
    where?: StoryPlaySessionWhereInput
    /**
     * Limit how many StoryPlaySessions to update.
     */
    limit?: number
  }

  /**
   * StoryPlaySession updateManyAndReturn
   */
  export type StoryPlaySessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * The data used to update StoryPlaySessions.
     */
    data: XOR<StoryPlaySessionUpdateManyMutationInput, StoryPlaySessionUncheckedUpdateManyInput>
    /**
     * Filter which StoryPlaySessions to update
     */
    where?: StoryPlaySessionWhereInput
    /**
     * Limit how many StoryPlaySessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryPlaySession upsert
   */
  export type StoryPlaySessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryPlaySession to update in case it exists.
     */
    where: StoryPlaySessionWhereUniqueInput
    /**
     * In case the StoryPlaySession found by the `where` argument doesn't exist, create a new StoryPlaySession with this data.
     */
    create: XOR<StoryPlaySessionCreateInput, StoryPlaySessionUncheckedCreateInput>
    /**
     * In case the StoryPlaySession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryPlaySessionUpdateInput, StoryPlaySessionUncheckedUpdateInput>
  }

  /**
   * StoryPlaySession delete
   */
  export type StoryPlaySessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
    /**
     * Filter which StoryPlaySession to delete.
     */
    where: StoryPlaySessionWhereUniqueInput
  }

  /**
   * StoryPlaySession deleteMany
   */
  export type StoryPlaySessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryPlaySessions to delete
     */
    where?: StoryPlaySessionWhereInput
    /**
     * Limit how many StoryPlaySessions to delete.
     */
    limit?: number
  }

  /**
   * StoryPlaySession.version
   */
  export type StoryPlaySession$versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    where?: StoryVersionWhereInput
  }

  /**
   * StoryPlaySession.user
   */
  export type StoryPlaySession$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StoryPlaySession.session
   */
  export type StoryPlaySession$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
  }

  /**
   * StoryPlaySession without action
   */
  export type StoryPlaySessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPlaySession
     */
    select?: StoryPlaySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPlaySession
     */
    omit?: StoryPlaySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPlaySessionInclude<ExtArgs> | null
  }


  /**
   * Model StoryNode
   */

  export type AggregateStoryNode = {
    _count: StoryNodeCountAggregateOutputType | null
    _min: StoryNodeMinAggregateOutputType | null
    _max: StoryNodeMaxAggregateOutputType | null
  }

  export type StoryNodeMinAggregateOutputType = {
    id: string | null
    storyId: string | null
    key: string | null
    title: string | null
    synopsis: string | null
    type: $Enums.StoryNodeType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryNodeMaxAggregateOutputType = {
    id: string | null
    storyId: string | null
    key: string | null
    title: string | null
    synopsis: string | null
    type: $Enums.StoryNodeType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryNodeCountAggregateOutputType = {
    id: number
    storyId: number
    key: number
    title: number
    synopsis: number
    type: number
    content: number
    media: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoryNodeMinAggregateInputType = {
    id?: true
    storyId?: true
    key?: true
    title?: true
    synopsis?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryNodeMaxAggregateInputType = {
    id?: true
    storyId?: true
    key?: true
    title?: true
    synopsis?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryNodeCountAggregateInputType = {
    id?: true
    storyId?: true
    key?: true
    title?: true
    synopsis?: true
    type?: true
    content?: true
    media?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoryNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryNode to aggregate.
     */
    where?: StoryNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryNodes to fetch.
     */
    orderBy?: StoryNodeOrderByWithRelationInput | StoryNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryNodes
    **/
    _count?: true | StoryNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryNodeMaxAggregateInputType
  }

  export type GetStoryNodeAggregateType<T extends StoryNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryNode[P]>
      : GetScalarType<T[P], AggregateStoryNode[P]>
  }




  export type StoryNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryNodeWhereInput
    orderBy?: StoryNodeOrderByWithAggregationInput | StoryNodeOrderByWithAggregationInput[]
    by: StoryNodeScalarFieldEnum[] | StoryNodeScalarFieldEnum
    having?: StoryNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryNodeCountAggregateInputType | true
    _min?: StoryNodeMinAggregateInputType
    _max?: StoryNodeMaxAggregateInputType
  }

  export type StoryNodeGroupByOutputType = {
    id: string
    storyId: string
    key: string
    title: string | null
    synopsis: string | null
    type: $Enums.StoryNodeType
    content: JsonValue | null
    media: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: StoryNodeCountAggregateOutputType | null
    _min: StoryNodeMinAggregateOutputType | null
    _max: StoryNodeMaxAggregateOutputType | null
  }

  type GetStoryNodeGroupByPayload<T extends StoryNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryNodeGroupByOutputType[P]>
            : GetScalarType<T[P], StoryNodeGroupByOutputType[P]>
        }
      >
    >


  export type StoryNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    key?: boolean
    title?: boolean
    synopsis?: boolean
    type?: boolean
    content?: boolean
    media?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    outgoing?: boolean | StoryNode$outgoingArgs<ExtArgs>
    incoming?: boolean | StoryNode$incomingArgs<ExtArgs>
    _count?: boolean | StoryNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyNode"]>

  export type StoryNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    key?: boolean
    title?: boolean
    synopsis?: boolean
    type?: boolean
    content?: boolean
    media?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyNode"]>

  export type StoryNodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    key?: boolean
    title?: boolean
    synopsis?: boolean
    type?: boolean
    content?: boolean
    media?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyNode"]>

  export type StoryNodeSelectScalar = {
    id?: boolean
    storyId?: boolean
    key?: boolean
    title?: boolean
    synopsis?: boolean
    type?: boolean
    content?: boolean
    media?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoryNodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storyId" | "key" | "title" | "synopsis" | "type" | "content" | "media" | "createdAt" | "updatedAt", ExtArgs["result"]["storyNode"]>
  export type StoryNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    outgoing?: boolean | StoryNode$outgoingArgs<ExtArgs>
    incoming?: boolean | StoryNode$incomingArgs<ExtArgs>
    _count?: boolean | StoryNodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoryNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
  }
  export type StoryNodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
  }

  export type $StoryNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryNode"
    objects: {
      story: Prisma.$TwineStoryPayload<ExtArgs>
      outgoing: Prisma.$StoryTransitionPayload<ExtArgs>[]
      incoming: Prisma.$StoryTransitionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storyId: string
      key: string
      title: string | null
      synopsis: string | null
      type: $Enums.StoryNodeType
      content: Prisma.JsonValue | null
      media: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storyNode"]>
    composites: {}
  }

  type StoryNodeGetPayload<S extends boolean | null | undefined | StoryNodeDefaultArgs> = $Result.GetResult<Prisma.$StoryNodePayload, S>

  type StoryNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryNodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryNodeCountAggregateInputType | true
    }

  export interface StoryNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryNode'], meta: { name: 'StoryNode' } }
    /**
     * Find zero or one StoryNode that matches the filter.
     * @param {StoryNodeFindUniqueArgs} args - Arguments to find a StoryNode
     * @example
     * // Get one StoryNode
     * const storyNode = await prisma.storyNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryNodeFindUniqueArgs>(args: SelectSubset<T, StoryNodeFindUniqueArgs<ExtArgs>>): Prisma__StoryNodeClient<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoryNode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryNodeFindUniqueOrThrowArgs} args - Arguments to find a StoryNode
     * @example
     * // Get one StoryNode
     * const storyNode = await prisma.storyNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryNodeFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryNodeClient<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryNodeFindFirstArgs} args - Arguments to find a StoryNode
     * @example
     * // Get one StoryNode
     * const storyNode = await prisma.storyNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryNodeFindFirstArgs>(args?: SelectSubset<T, StoryNodeFindFirstArgs<ExtArgs>>): Prisma__StoryNodeClient<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryNodeFindFirstOrThrowArgs} args - Arguments to find a StoryNode
     * @example
     * // Get one StoryNode
     * const storyNode = await prisma.storyNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryNodeFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryNodeClient<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoryNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryNodes
     * const storyNodes = await prisma.storyNode.findMany()
     * 
     * // Get first 10 StoryNodes
     * const storyNodes = await prisma.storyNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyNodeWithIdOnly = await prisma.storyNode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryNodeFindManyArgs>(args?: SelectSubset<T, StoryNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoryNode.
     * @param {StoryNodeCreateArgs} args - Arguments to create a StoryNode.
     * @example
     * // Create one StoryNode
     * const StoryNode = await prisma.storyNode.create({
     *   data: {
     *     // ... data to create a StoryNode
     *   }
     * })
     * 
     */
    create<T extends StoryNodeCreateArgs>(args: SelectSubset<T, StoryNodeCreateArgs<ExtArgs>>): Prisma__StoryNodeClient<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoryNodes.
     * @param {StoryNodeCreateManyArgs} args - Arguments to create many StoryNodes.
     * @example
     * // Create many StoryNodes
     * const storyNode = await prisma.storyNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryNodeCreateManyArgs>(args?: SelectSubset<T, StoryNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryNodes and returns the data saved in the database.
     * @param {StoryNodeCreateManyAndReturnArgs} args - Arguments to create many StoryNodes.
     * @example
     * // Create many StoryNodes
     * const storyNode = await prisma.storyNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryNodes and only return the `id`
     * const storyNodeWithIdOnly = await prisma.storyNode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryNodeCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoryNode.
     * @param {StoryNodeDeleteArgs} args - Arguments to delete one StoryNode.
     * @example
     * // Delete one StoryNode
     * const StoryNode = await prisma.storyNode.delete({
     *   where: {
     *     // ... filter to delete one StoryNode
     *   }
     * })
     * 
     */
    delete<T extends StoryNodeDeleteArgs>(args: SelectSubset<T, StoryNodeDeleteArgs<ExtArgs>>): Prisma__StoryNodeClient<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoryNode.
     * @param {StoryNodeUpdateArgs} args - Arguments to update one StoryNode.
     * @example
     * // Update one StoryNode
     * const storyNode = await prisma.storyNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryNodeUpdateArgs>(args: SelectSubset<T, StoryNodeUpdateArgs<ExtArgs>>): Prisma__StoryNodeClient<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoryNodes.
     * @param {StoryNodeDeleteManyArgs} args - Arguments to filter StoryNodes to delete.
     * @example
     * // Delete a few StoryNodes
     * const { count } = await prisma.storyNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryNodeDeleteManyArgs>(args?: SelectSubset<T, StoryNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryNodes
     * const storyNode = await prisma.storyNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryNodeUpdateManyArgs>(args: SelectSubset<T, StoryNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryNodes and returns the data updated in the database.
     * @param {StoryNodeUpdateManyAndReturnArgs} args - Arguments to update many StoryNodes.
     * @example
     * // Update many StoryNodes
     * const storyNode = await prisma.storyNode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoryNodes and only return the `id`
     * const storyNodeWithIdOnly = await prisma.storyNode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryNodeUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryNodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoryNode.
     * @param {StoryNodeUpsertArgs} args - Arguments to update or create a StoryNode.
     * @example
     * // Update or create a StoryNode
     * const storyNode = await prisma.storyNode.upsert({
     *   create: {
     *     // ... data to create a StoryNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryNode we want to update
     *   }
     * })
     */
    upsert<T extends StoryNodeUpsertArgs>(args: SelectSubset<T, StoryNodeUpsertArgs<ExtArgs>>): Prisma__StoryNodeClient<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoryNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryNodeCountArgs} args - Arguments to filter StoryNodes to count.
     * @example
     * // Count the number of StoryNodes
     * const count = await prisma.storyNode.count({
     *   where: {
     *     // ... the filter for the StoryNodes we want to count
     *   }
     * })
    **/
    count<T extends StoryNodeCountArgs>(
      args?: Subset<T, StoryNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryNodeAggregateArgs>(args: Subset<T, StoryNodeAggregateArgs>): Prisma.PrismaPromise<GetStoryNodeAggregateType<T>>

    /**
     * Group by StoryNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryNodeGroupByArgs['orderBy'] }
        : { orderBy?: StoryNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryNode model
   */
  readonly fields: StoryNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends TwineStoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TwineStoryDefaultArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outgoing<T extends StoryNode$outgoingArgs<ExtArgs> = {}>(args?: Subset<T, StoryNode$outgoingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incoming<T extends StoryNode$incomingArgs<ExtArgs> = {}>(args?: Subset<T, StoryNode$incomingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryNode model
   */
  interface StoryNodeFieldRefs {
    readonly id: FieldRef<"StoryNode", 'String'>
    readonly storyId: FieldRef<"StoryNode", 'String'>
    readonly key: FieldRef<"StoryNode", 'String'>
    readonly title: FieldRef<"StoryNode", 'String'>
    readonly synopsis: FieldRef<"StoryNode", 'String'>
    readonly type: FieldRef<"StoryNode", 'StoryNodeType'>
    readonly content: FieldRef<"StoryNode", 'Json'>
    readonly media: FieldRef<"StoryNode", 'Json'>
    readonly createdAt: FieldRef<"StoryNode", 'DateTime'>
    readonly updatedAt: FieldRef<"StoryNode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoryNode findUnique
   */
  export type StoryNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeInclude<ExtArgs> | null
    /**
     * Filter, which StoryNode to fetch.
     */
    where: StoryNodeWhereUniqueInput
  }

  /**
   * StoryNode findUniqueOrThrow
   */
  export type StoryNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeInclude<ExtArgs> | null
    /**
     * Filter, which StoryNode to fetch.
     */
    where: StoryNodeWhereUniqueInput
  }

  /**
   * StoryNode findFirst
   */
  export type StoryNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeInclude<ExtArgs> | null
    /**
     * Filter, which StoryNode to fetch.
     */
    where?: StoryNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryNodes to fetch.
     */
    orderBy?: StoryNodeOrderByWithRelationInput | StoryNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryNodes.
     */
    cursor?: StoryNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryNodes.
     */
    distinct?: StoryNodeScalarFieldEnum | StoryNodeScalarFieldEnum[]
  }

  /**
   * StoryNode findFirstOrThrow
   */
  export type StoryNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeInclude<ExtArgs> | null
    /**
     * Filter, which StoryNode to fetch.
     */
    where?: StoryNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryNodes to fetch.
     */
    orderBy?: StoryNodeOrderByWithRelationInput | StoryNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryNodes.
     */
    cursor?: StoryNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryNodes.
     */
    distinct?: StoryNodeScalarFieldEnum | StoryNodeScalarFieldEnum[]
  }

  /**
   * StoryNode findMany
   */
  export type StoryNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeInclude<ExtArgs> | null
    /**
     * Filter, which StoryNodes to fetch.
     */
    where?: StoryNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryNodes to fetch.
     */
    orderBy?: StoryNodeOrderByWithRelationInput | StoryNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryNodes.
     */
    cursor?: StoryNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryNodes.
     */
    skip?: number
    distinct?: StoryNodeScalarFieldEnum | StoryNodeScalarFieldEnum[]
  }

  /**
   * StoryNode create
   */
  export type StoryNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryNode.
     */
    data: XOR<StoryNodeCreateInput, StoryNodeUncheckedCreateInput>
  }

  /**
   * StoryNode createMany
   */
  export type StoryNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryNodes.
     */
    data: StoryNodeCreateManyInput | StoryNodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryNode createManyAndReturn
   */
  export type StoryNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * The data used to create many StoryNodes.
     */
    data: StoryNodeCreateManyInput | StoryNodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryNode update
   */
  export type StoryNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryNode.
     */
    data: XOR<StoryNodeUpdateInput, StoryNodeUncheckedUpdateInput>
    /**
     * Choose, which StoryNode to update.
     */
    where: StoryNodeWhereUniqueInput
  }

  /**
   * StoryNode updateMany
   */
  export type StoryNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryNodes.
     */
    data: XOR<StoryNodeUpdateManyMutationInput, StoryNodeUncheckedUpdateManyInput>
    /**
     * Filter which StoryNodes to update
     */
    where?: StoryNodeWhereInput
    /**
     * Limit how many StoryNodes to update.
     */
    limit?: number
  }

  /**
   * StoryNode updateManyAndReturn
   */
  export type StoryNodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * The data used to update StoryNodes.
     */
    data: XOR<StoryNodeUpdateManyMutationInput, StoryNodeUncheckedUpdateManyInput>
    /**
     * Filter which StoryNodes to update
     */
    where?: StoryNodeWhereInput
    /**
     * Limit how many StoryNodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryNode upsert
   */
  export type StoryNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryNode to update in case it exists.
     */
    where: StoryNodeWhereUniqueInput
    /**
     * In case the StoryNode found by the `where` argument doesn't exist, create a new StoryNode with this data.
     */
    create: XOR<StoryNodeCreateInput, StoryNodeUncheckedCreateInput>
    /**
     * In case the StoryNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryNodeUpdateInput, StoryNodeUncheckedUpdateInput>
  }

  /**
   * StoryNode delete
   */
  export type StoryNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeInclude<ExtArgs> | null
    /**
     * Filter which StoryNode to delete.
     */
    where: StoryNodeWhereUniqueInput
  }

  /**
   * StoryNode deleteMany
   */
  export type StoryNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryNodes to delete
     */
    where?: StoryNodeWhereInput
    /**
     * Limit how many StoryNodes to delete.
     */
    limit?: number
  }

  /**
   * StoryNode.outgoing
   */
  export type StoryNode$outgoingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    where?: StoryTransitionWhereInput
    orderBy?: StoryTransitionOrderByWithRelationInput | StoryTransitionOrderByWithRelationInput[]
    cursor?: StoryTransitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryTransitionScalarFieldEnum | StoryTransitionScalarFieldEnum[]
  }

  /**
   * StoryNode.incoming
   */
  export type StoryNode$incomingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    where?: StoryTransitionWhereInput
    orderBy?: StoryTransitionOrderByWithRelationInput | StoryTransitionOrderByWithRelationInput[]
    cursor?: StoryTransitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryTransitionScalarFieldEnum | StoryTransitionScalarFieldEnum[]
  }

  /**
   * StoryNode without action
   */
  export type StoryNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeInclude<ExtArgs> | null
  }


  /**
   * Model StoryPath
   */

  export type AggregateStoryPath = {
    _count: StoryPathCountAggregateOutputType | null
    _min: StoryPathMinAggregateOutputType | null
    _max: StoryPathMaxAggregateOutputType | null
  }

  export type StoryPathMinAggregateOutputType = {
    id: string | null
    storyId: string | null
    key: string | null
    label: string | null
    summary: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryPathMaxAggregateOutputType = {
    id: string | null
    storyId: string | null
    key: string | null
    label: string | null
    summary: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryPathCountAggregateOutputType = {
    id: number
    storyId: number
    key: number
    label: number
    summary: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoryPathMinAggregateInputType = {
    id?: true
    storyId?: true
    key?: true
    label?: true
    summary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryPathMaxAggregateInputType = {
    id?: true
    storyId?: true
    key?: true
    label?: true
    summary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryPathCountAggregateInputType = {
    id?: true
    storyId?: true
    key?: true
    label?: true
    summary?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoryPathAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryPath to aggregate.
     */
    where?: StoryPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryPaths to fetch.
     */
    orderBy?: StoryPathOrderByWithRelationInput | StoryPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryPaths
    **/
    _count?: true | StoryPathCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryPathMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryPathMaxAggregateInputType
  }

  export type GetStoryPathAggregateType<T extends StoryPathAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryPath]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryPath[P]>
      : GetScalarType<T[P], AggregateStoryPath[P]>
  }




  export type StoryPathGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryPathWhereInput
    orderBy?: StoryPathOrderByWithAggregationInput | StoryPathOrderByWithAggregationInput[]
    by: StoryPathScalarFieldEnum[] | StoryPathScalarFieldEnum
    having?: StoryPathScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryPathCountAggregateInputType | true
    _min?: StoryPathMinAggregateInputType
    _max?: StoryPathMaxAggregateInputType
  }

  export type StoryPathGroupByOutputType = {
    id: string
    storyId: string
    key: string
    label: string
    summary: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: StoryPathCountAggregateOutputType | null
    _min: StoryPathMinAggregateOutputType | null
    _max: StoryPathMaxAggregateOutputType | null
  }

  type GetStoryPathGroupByPayload<T extends StoryPathGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryPathGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryPathGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryPathGroupByOutputType[P]>
            : GetScalarType<T[P], StoryPathGroupByOutputType[P]>
        }
      >
    >


  export type StoryPathSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    key?: boolean
    label?: boolean
    summary?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    transitions?: boolean | StoryPath$transitionsArgs<ExtArgs>
    _count?: boolean | StoryPathCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyPath"]>

  export type StoryPathSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    key?: boolean
    label?: boolean
    summary?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyPath"]>

  export type StoryPathSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    key?: boolean
    label?: boolean
    summary?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyPath"]>

  export type StoryPathSelectScalar = {
    id?: boolean
    storyId?: boolean
    key?: boolean
    label?: boolean
    summary?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoryPathOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storyId" | "key" | "label" | "summary" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["storyPath"]>
  export type StoryPathInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    transitions?: boolean | StoryPath$transitionsArgs<ExtArgs>
    _count?: boolean | StoryPathCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoryPathIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
  }
  export type StoryPathIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
  }

  export type $StoryPathPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryPath"
    objects: {
      story: Prisma.$TwineStoryPayload<ExtArgs>
      transitions: Prisma.$StoryTransitionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storyId: string
      key: string
      label: string
      summary: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storyPath"]>
    composites: {}
  }

  type StoryPathGetPayload<S extends boolean | null | undefined | StoryPathDefaultArgs> = $Result.GetResult<Prisma.$StoryPathPayload, S>

  type StoryPathCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryPathFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryPathCountAggregateInputType | true
    }

  export interface StoryPathDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryPath'], meta: { name: 'StoryPath' } }
    /**
     * Find zero or one StoryPath that matches the filter.
     * @param {StoryPathFindUniqueArgs} args - Arguments to find a StoryPath
     * @example
     * // Get one StoryPath
     * const storyPath = await prisma.storyPath.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryPathFindUniqueArgs>(args: SelectSubset<T, StoryPathFindUniqueArgs<ExtArgs>>): Prisma__StoryPathClient<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoryPath that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryPathFindUniqueOrThrowArgs} args - Arguments to find a StoryPath
     * @example
     * // Get one StoryPath
     * const storyPath = await prisma.storyPath.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryPathFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryPathFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryPathClient<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryPath that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPathFindFirstArgs} args - Arguments to find a StoryPath
     * @example
     * // Get one StoryPath
     * const storyPath = await prisma.storyPath.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryPathFindFirstArgs>(args?: SelectSubset<T, StoryPathFindFirstArgs<ExtArgs>>): Prisma__StoryPathClient<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryPath that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPathFindFirstOrThrowArgs} args - Arguments to find a StoryPath
     * @example
     * // Get one StoryPath
     * const storyPath = await prisma.storyPath.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryPathFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryPathFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryPathClient<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoryPaths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPathFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryPaths
     * const storyPaths = await prisma.storyPath.findMany()
     * 
     * // Get first 10 StoryPaths
     * const storyPaths = await prisma.storyPath.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyPathWithIdOnly = await prisma.storyPath.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryPathFindManyArgs>(args?: SelectSubset<T, StoryPathFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoryPath.
     * @param {StoryPathCreateArgs} args - Arguments to create a StoryPath.
     * @example
     * // Create one StoryPath
     * const StoryPath = await prisma.storyPath.create({
     *   data: {
     *     // ... data to create a StoryPath
     *   }
     * })
     * 
     */
    create<T extends StoryPathCreateArgs>(args: SelectSubset<T, StoryPathCreateArgs<ExtArgs>>): Prisma__StoryPathClient<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoryPaths.
     * @param {StoryPathCreateManyArgs} args - Arguments to create many StoryPaths.
     * @example
     * // Create many StoryPaths
     * const storyPath = await prisma.storyPath.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryPathCreateManyArgs>(args?: SelectSubset<T, StoryPathCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryPaths and returns the data saved in the database.
     * @param {StoryPathCreateManyAndReturnArgs} args - Arguments to create many StoryPaths.
     * @example
     * // Create many StoryPaths
     * const storyPath = await prisma.storyPath.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryPaths and only return the `id`
     * const storyPathWithIdOnly = await prisma.storyPath.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryPathCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryPathCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoryPath.
     * @param {StoryPathDeleteArgs} args - Arguments to delete one StoryPath.
     * @example
     * // Delete one StoryPath
     * const StoryPath = await prisma.storyPath.delete({
     *   where: {
     *     // ... filter to delete one StoryPath
     *   }
     * })
     * 
     */
    delete<T extends StoryPathDeleteArgs>(args: SelectSubset<T, StoryPathDeleteArgs<ExtArgs>>): Prisma__StoryPathClient<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoryPath.
     * @param {StoryPathUpdateArgs} args - Arguments to update one StoryPath.
     * @example
     * // Update one StoryPath
     * const storyPath = await prisma.storyPath.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryPathUpdateArgs>(args: SelectSubset<T, StoryPathUpdateArgs<ExtArgs>>): Prisma__StoryPathClient<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoryPaths.
     * @param {StoryPathDeleteManyArgs} args - Arguments to filter StoryPaths to delete.
     * @example
     * // Delete a few StoryPaths
     * const { count } = await prisma.storyPath.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryPathDeleteManyArgs>(args?: SelectSubset<T, StoryPathDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryPaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPathUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryPaths
     * const storyPath = await prisma.storyPath.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryPathUpdateManyArgs>(args: SelectSubset<T, StoryPathUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryPaths and returns the data updated in the database.
     * @param {StoryPathUpdateManyAndReturnArgs} args - Arguments to update many StoryPaths.
     * @example
     * // Update many StoryPaths
     * const storyPath = await prisma.storyPath.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoryPaths and only return the `id`
     * const storyPathWithIdOnly = await prisma.storyPath.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryPathUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryPathUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoryPath.
     * @param {StoryPathUpsertArgs} args - Arguments to update or create a StoryPath.
     * @example
     * // Update or create a StoryPath
     * const storyPath = await prisma.storyPath.upsert({
     *   create: {
     *     // ... data to create a StoryPath
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryPath we want to update
     *   }
     * })
     */
    upsert<T extends StoryPathUpsertArgs>(args: SelectSubset<T, StoryPathUpsertArgs<ExtArgs>>): Prisma__StoryPathClient<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoryPaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPathCountArgs} args - Arguments to filter StoryPaths to count.
     * @example
     * // Count the number of StoryPaths
     * const count = await prisma.storyPath.count({
     *   where: {
     *     // ... the filter for the StoryPaths we want to count
     *   }
     * })
    **/
    count<T extends StoryPathCountArgs>(
      args?: Subset<T, StoryPathCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryPathCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryPath.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPathAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryPathAggregateArgs>(args: Subset<T, StoryPathAggregateArgs>): Prisma.PrismaPromise<GetStoryPathAggregateType<T>>

    /**
     * Group by StoryPath.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryPathGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryPathGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryPathGroupByArgs['orderBy'] }
        : { orderBy?: StoryPathGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryPathGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryPathGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryPath model
   */
  readonly fields: StoryPathFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryPath.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryPathClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends TwineStoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TwineStoryDefaultArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transitions<T extends StoryPath$transitionsArgs<ExtArgs> = {}>(args?: Subset<T, StoryPath$transitionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryPath model
   */
  interface StoryPathFieldRefs {
    readonly id: FieldRef<"StoryPath", 'String'>
    readonly storyId: FieldRef<"StoryPath", 'String'>
    readonly key: FieldRef<"StoryPath", 'String'>
    readonly label: FieldRef<"StoryPath", 'String'>
    readonly summary: FieldRef<"StoryPath", 'String'>
    readonly metadata: FieldRef<"StoryPath", 'Json'>
    readonly createdAt: FieldRef<"StoryPath", 'DateTime'>
    readonly updatedAt: FieldRef<"StoryPath", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoryPath findUnique
   */
  export type StoryPathFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathInclude<ExtArgs> | null
    /**
     * Filter, which StoryPath to fetch.
     */
    where: StoryPathWhereUniqueInput
  }

  /**
   * StoryPath findUniqueOrThrow
   */
  export type StoryPathFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathInclude<ExtArgs> | null
    /**
     * Filter, which StoryPath to fetch.
     */
    where: StoryPathWhereUniqueInput
  }

  /**
   * StoryPath findFirst
   */
  export type StoryPathFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathInclude<ExtArgs> | null
    /**
     * Filter, which StoryPath to fetch.
     */
    where?: StoryPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryPaths to fetch.
     */
    orderBy?: StoryPathOrderByWithRelationInput | StoryPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryPaths.
     */
    cursor?: StoryPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryPaths.
     */
    distinct?: StoryPathScalarFieldEnum | StoryPathScalarFieldEnum[]
  }

  /**
   * StoryPath findFirstOrThrow
   */
  export type StoryPathFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathInclude<ExtArgs> | null
    /**
     * Filter, which StoryPath to fetch.
     */
    where?: StoryPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryPaths to fetch.
     */
    orderBy?: StoryPathOrderByWithRelationInput | StoryPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryPaths.
     */
    cursor?: StoryPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryPaths.
     */
    distinct?: StoryPathScalarFieldEnum | StoryPathScalarFieldEnum[]
  }

  /**
   * StoryPath findMany
   */
  export type StoryPathFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathInclude<ExtArgs> | null
    /**
     * Filter, which StoryPaths to fetch.
     */
    where?: StoryPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryPaths to fetch.
     */
    orderBy?: StoryPathOrderByWithRelationInput | StoryPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryPaths.
     */
    cursor?: StoryPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryPaths.
     */
    skip?: number
    distinct?: StoryPathScalarFieldEnum | StoryPathScalarFieldEnum[]
  }

  /**
   * StoryPath create
   */
  export type StoryPathCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryPath.
     */
    data: XOR<StoryPathCreateInput, StoryPathUncheckedCreateInput>
  }

  /**
   * StoryPath createMany
   */
  export type StoryPathCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryPaths.
     */
    data: StoryPathCreateManyInput | StoryPathCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryPath createManyAndReturn
   */
  export type StoryPathCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * The data used to create many StoryPaths.
     */
    data: StoryPathCreateManyInput | StoryPathCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryPath update
   */
  export type StoryPathUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryPath.
     */
    data: XOR<StoryPathUpdateInput, StoryPathUncheckedUpdateInput>
    /**
     * Choose, which StoryPath to update.
     */
    where: StoryPathWhereUniqueInput
  }

  /**
   * StoryPath updateMany
   */
  export type StoryPathUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryPaths.
     */
    data: XOR<StoryPathUpdateManyMutationInput, StoryPathUncheckedUpdateManyInput>
    /**
     * Filter which StoryPaths to update
     */
    where?: StoryPathWhereInput
    /**
     * Limit how many StoryPaths to update.
     */
    limit?: number
  }

  /**
   * StoryPath updateManyAndReturn
   */
  export type StoryPathUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * The data used to update StoryPaths.
     */
    data: XOR<StoryPathUpdateManyMutationInput, StoryPathUncheckedUpdateManyInput>
    /**
     * Filter which StoryPaths to update
     */
    where?: StoryPathWhereInput
    /**
     * Limit how many StoryPaths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryPath upsert
   */
  export type StoryPathUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryPath to update in case it exists.
     */
    where: StoryPathWhereUniqueInput
    /**
     * In case the StoryPath found by the `where` argument doesn't exist, create a new StoryPath with this data.
     */
    create: XOR<StoryPathCreateInput, StoryPathUncheckedCreateInput>
    /**
     * In case the StoryPath was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryPathUpdateInput, StoryPathUncheckedUpdateInput>
  }

  /**
   * StoryPath delete
   */
  export type StoryPathDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathInclude<ExtArgs> | null
    /**
     * Filter which StoryPath to delete.
     */
    where: StoryPathWhereUniqueInput
  }

  /**
   * StoryPath deleteMany
   */
  export type StoryPathDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryPaths to delete
     */
    where?: StoryPathWhereInput
    /**
     * Limit how many StoryPaths to delete.
     */
    limit?: number
  }

  /**
   * StoryPath.transitions
   */
  export type StoryPath$transitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    where?: StoryTransitionWhereInput
    orderBy?: StoryTransitionOrderByWithRelationInput | StoryTransitionOrderByWithRelationInput[]
    cursor?: StoryTransitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryTransitionScalarFieldEnum | StoryTransitionScalarFieldEnum[]
  }

  /**
   * StoryPath without action
   */
  export type StoryPathDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryPath
     */
    select?: StoryPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryPath
     */
    omit?: StoryPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryPathInclude<ExtArgs> | null
  }


  /**
   * Model StoryTransition
   */

  export type AggregateStoryTransition = {
    _count: StoryTransitionCountAggregateOutputType | null
    _avg: StoryTransitionAvgAggregateOutputType | null
    _sum: StoryTransitionSumAggregateOutputType | null
    _min: StoryTransitionMinAggregateOutputType | null
    _max: StoryTransitionMaxAggregateOutputType | null
  }

  export type StoryTransitionAvgAggregateOutputType = {
    ordering: number | null
  }

  export type StoryTransitionSumAggregateOutputType = {
    ordering: number | null
  }

  export type StoryTransitionMinAggregateOutputType = {
    id: string | null
    storyId: string | null
    fromNodeId: string | null
    pathId: string | null
    toNodeId: string | null
    ordering: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryTransitionMaxAggregateOutputType = {
    id: string | null
    storyId: string | null
    fromNodeId: string | null
    pathId: string | null
    toNodeId: string | null
    ordering: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryTransitionCountAggregateOutputType = {
    id: number
    storyId: number
    fromNodeId: number
    pathId: number
    toNodeId: number
    ordering: number
    condition: number
    effect: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoryTransitionAvgAggregateInputType = {
    ordering?: true
  }

  export type StoryTransitionSumAggregateInputType = {
    ordering?: true
  }

  export type StoryTransitionMinAggregateInputType = {
    id?: true
    storyId?: true
    fromNodeId?: true
    pathId?: true
    toNodeId?: true
    ordering?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryTransitionMaxAggregateInputType = {
    id?: true
    storyId?: true
    fromNodeId?: true
    pathId?: true
    toNodeId?: true
    ordering?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryTransitionCountAggregateInputType = {
    id?: true
    storyId?: true
    fromNodeId?: true
    pathId?: true
    toNodeId?: true
    ordering?: true
    condition?: true
    effect?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoryTransitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryTransition to aggregate.
     */
    where?: StoryTransitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryTransitions to fetch.
     */
    orderBy?: StoryTransitionOrderByWithRelationInput | StoryTransitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryTransitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryTransitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryTransitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryTransitions
    **/
    _count?: true | StoryTransitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoryTransitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoryTransitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryTransitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryTransitionMaxAggregateInputType
  }

  export type GetStoryTransitionAggregateType<T extends StoryTransitionAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryTransition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryTransition[P]>
      : GetScalarType<T[P], AggregateStoryTransition[P]>
  }




  export type StoryTransitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryTransitionWhereInput
    orderBy?: StoryTransitionOrderByWithAggregationInput | StoryTransitionOrderByWithAggregationInput[]
    by: StoryTransitionScalarFieldEnum[] | StoryTransitionScalarFieldEnum
    having?: StoryTransitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryTransitionCountAggregateInputType | true
    _avg?: StoryTransitionAvgAggregateInputType
    _sum?: StoryTransitionSumAggregateInputType
    _min?: StoryTransitionMinAggregateInputType
    _max?: StoryTransitionMaxAggregateInputType
  }

  export type StoryTransitionGroupByOutputType = {
    id: string
    storyId: string
    fromNodeId: string
    pathId: string
    toNodeId: string | null
    ordering: number | null
    condition: JsonValue | null
    effect: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: StoryTransitionCountAggregateOutputType | null
    _avg: StoryTransitionAvgAggregateOutputType | null
    _sum: StoryTransitionSumAggregateOutputType | null
    _min: StoryTransitionMinAggregateOutputType | null
    _max: StoryTransitionMaxAggregateOutputType | null
  }

  type GetStoryTransitionGroupByPayload<T extends StoryTransitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryTransitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryTransitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryTransitionGroupByOutputType[P]>
            : GetScalarType<T[P], StoryTransitionGroupByOutputType[P]>
        }
      >
    >


  export type StoryTransitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    fromNodeId?: boolean
    pathId?: boolean
    toNodeId?: boolean
    ordering?: boolean
    condition?: boolean
    effect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    fromNode?: boolean | StoryNodeDefaultArgs<ExtArgs>
    toNode?: boolean | StoryTransition$toNodeArgs<ExtArgs>
    path?: boolean | StoryPathDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyTransition"]>

  export type StoryTransitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    fromNodeId?: boolean
    pathId?: boolean
    toNodeId?: boolean
    ordering?: boolean
    condition?: boolean
    effect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    fromNode?: boolean | StoryNodeDefaultArgs<ExtArgs>
    toNode?: boolean | StoryTransition$toNodeArgs<ExtArgs>
    path?: boolean | StoryPathDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyTransition"]>

  export type StoryTransitionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    fromNodeId?: boolean
    pathId?: boolean
    toNodeId?: boolean
    ordering?: boolean
    condition?: boolean
    effect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    fromNode?: boolean | StoryNodeDefaultArgs<ExtArgs>
    toNode?: boolean | StoryTransition$toNodeArgs<ExtArgs>
    path?: boolean | StoryPathDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyTransition"]>

  export type StoryTransitionSelectScalar = {
    id?: boolean
    storyId?: boolean
    fromNodeId?: boolean
    pathId?: boolean
    toNodeId?: boolean
    ordering?: boolean
    condition?: boolean
    effect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoryTransitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storyId" | "fromNodeId" | "pathId" | "toNodeId" | "ordering" | "condition" | "effect" | "createdAt" | "updatedAt", ExtArgs["result"]["storyTransition"]>
  export type StoryTransitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    fromNode?: boolean | StoryNodeDefaultArgs<ExtArgs>
    toNode?: boolean | StoryTransition$toNodeArgs<ExtArgs>
    path?: boolean | StoryPathDefaultArgs<ExtArgs>
  }
  export type StoryTransitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    fromNode?: boolean | StoryNodeDefaultArgs<ExtArgs>
    toNode?: boolean | StoryTransition$toNodeArgs<ExtArgs>
    path?: boolean | StoryPathDefaultArgs<ExtArgs>
  }
  export type StoryTransitionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | TwineStoryDefaultArgs<ExtArgs>
    fromNode?: boolean | StoryNodeDefaultArgs<ExtArgs>
    toNode?: boolean | StoryTransition$toNodeArgs<ExtArgs>
    path?: boolean | StoryPathDefaultArgs<ExtArgs>
  }

  export type $StoryTransitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryTransition"
    objects: {
      story: Prisma.$TwineStoryPayload<ExtArgs>
      fromNode: Prisma.$StoryNodePayload<ExtArgs>
      toNode: Prisma.$StoryNodePayload<ExtArgs> | null
      path: Prisma.$StoryPathPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storyId: string
      fromNodeId: string
      pathId: string
      toNodeId: string | null
      ordering: number | null
      condition: Prisma.JsonValue | null
      effect: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storyTransition"]>
    composites: {}
  }

  type StoryTransitionGetPayload<S extends boolean | null | undefined | StoryTransitionDefaultArgs> = $Result.GetResult<Prisma.$StoryTransitionPayload, S>

  type StoryTransitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryTransitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryTransitionCountAggregateInputType | true
    }

  export interface StoryTransitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryTransition'], meta: { name: 'StoryTransition' } }
    /**
     * Find zero or one StoryTransition that matches the filter.
     * @param {StoryTransitionFindUniqueArgs} args - Arguments to find a StoryTransition
     * @example
     * // Get one StoryTransition
     * const storyTransition = await prisma.storyTransition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryTransitionFindUniqueArgs>(args: SelectSubset<T, StoryTransitionFindUniqueArgs<ExtArgs>>): Prisma__StoryTransitionClient<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoryTransition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryTransitionFindUniqueOrThrowArgs} args - Arguments to find a StoryTransition
     * @example
     * // Get one StoryTransition
     * const storyTransition = await prisma.storyTransition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryTransitionFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryTransitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryTransitionClient<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryTransition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryTransitionFindFirstArgs} args - Arguments to find a StoryTransition
     * @example
     * // Get one StoryTransition
     * const storyTransition = await prisma.storyTransition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryTransitionFindFirstArgs>(args?: SelectSubset<T, StoryTransitionFindFirstArgs<ExtArgs>>): Prisma__StoryTransitionClient<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryTransition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryTransitionFindFirstOrThrowArgs} args - Arguments to find a StoryTransition
     * @example
     * // Get one StoryTransition
     * const storyTransition = await prisma.storyTransition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryTransitionFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryTransitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryTransitionClient<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoryTransitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryTransitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryTransitions
     * const storyTransitions = await prisma.storyTransition.findMany()
     * 
     * // Get first 10 StoryTransitions
     * const storyTransitions = await prisma.storyTransition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyTransitionWithIdOnly = await prisma.storyTransition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryTransitionFindManyArgs>(args?: SelectSubset<T, StoryTransitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoryTransition.
     * @param {StoryTransitionCreateArgs} args - Arguments to create a StoryTransition.
     * @example
     * // Create one StoryTransition
     * const StoryTransition = await prisma.storyTransition.create({
     *   data: {
     *     // ... data to create a StoryTransition
     *   }
     * })
     * 
     */
    create<T extends StoryTransitionCreateArgs>(args: SelectSubset<T, StoryTransitionCreateArgs<ExtArgs>>): Prisma__StoryTransitionClient<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoryTransitions.
     * @param {StoryTransitionCreateManyArgs} args - Arguments to create many StoryTransitions.
     * @example
     * // Create many StoryTransitions
     * const storyTransition = await prisma.storyTransition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryTransitionCreateManyArgs>(args?: SelectSubset<T, StoryTransitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryTransitions and returns the data saved in the database.
     * @param {StoryTransitionCreateManyAndReturnArgs} args - Arguments to create many StoryTransitions.
     * @example
     * // Create many StoryTransitions
     * const storyTransition = await prisma.storyTransition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryTransitions and only return the `id`
     * const storyTransitionWithIdOnly = await prisma.storyTransition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryTransitionCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryTransitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoryTransition.
     * @param {StoryTransitionDeleteArgs} args - Arguments to delete one StoryTransition.
     * @example
     * // Delete one StoryTransition
     * const StoryTransition = await prisma.storyTransition.delete({
     *   where: {
     *     // ... filter to delete one StoryTransition
     *   }
     * })
     * 
     */
    delete<T extends StoryTransitionDeleteArgs>(args: SelectSubset<T, StoryTransitionDeleteArgs<ExtArgs>>): Prisma__StoryTransitionClient<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoryTransition.
     * @param {StoryTransitionUpdateArgs} args - Arguments to update one StoryTransition.
     * @example
     * // Update one StoryTransition
     * const storyTransition = await prisma.storyTransition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryTransitionUpdateArgs>(args: SelectSubset<T, StoryTransitionUpdateArgs<ExtArgs>>): Prisma__StoryTransitionClient<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoryTransitions.
     * @param {StoryTransitionDeleteManyArgs} args - Arguments to filter StoryTransitions to delete.
     * @example
     * // Delete a few StoryTransitions
     * const { count } = await prisma.storyTransition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryTransitionDeleteManyArgs>(args?: SelectSubset<T, StoryTransitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryTransitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryTransitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryTransitions
     * const storyTransition = await prisma.storyTransition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryTransitionUpdateManyArgs>(args: SelectSubset<T, StoryTransitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryTransitions and returns the data updated in the database.
     * @param {StoryTransitionUpdateManyAndReturnArgs} args - Arguments to update many StoryTransitions.
     * @example
     * // Update many StoryTransitions
     * const storyTransition = await prisma.storyTransition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoryTransitions and only return the `id`
     * const storyTransitionWithIdOnly = await prisma.storyTransition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryTransitionUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryTransitionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoryTransition.
     * @param {StoryTransitionUpsertArgs} args - Arguments to update or create a StoryTransition.
     * @example
     * // Update or create a StoryTransition
     * const storyTransition = await prisma.storyTransition.upsert({
     *   create: {
     *     // ... data to create a StoryTransition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryTransition we want to update
     *   }
     * })
     */
    upsert<T extends StoryTransitionUpsertArgs>(args: SelectSubset<T, StoryTransitionUpsertArgs<ExtArgs>>): Prisma__StoryTransitionClient<$Result.GetResult<Prisma.$StoryTransitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoryTransitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryTransitionCountArgs} args - Arguments to filter StoryTransitions to count.
     * @example
     * // Count the number of StoryTransitions
     * const count = await prisma.storyTransition.count({
     *   where: {
     *     // ... the filter for the StoryTransitions we want to count
     *   }
     * })
    **/
    count<T extends StoryTransitionCountArgs>(
      args?: Subset<T, StoryTransitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryTransitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryTransition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryTransitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryTransitionAggregateArgs>(args: Subset<T, StoryTransitionAggregateArgs>): Prisma.PrismaPromise<GetStoryTransitionAggregateType<T>>

    /**
     * Group by StoryTransition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryTransitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryTransitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryTransitionGroupByArgs['orderBy'] }
        : { orderBy?: StoryTransitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryTransitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryTransitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryTransition model
   */
  readonly fields: StoryTransitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryTransition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryTransitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends TwineStoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TwineStoryDefaultArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fromNode<T extends StoryNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoryNodeDefaultArgs<ExtArgs>>): Prisma__StoryNodeClient<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toNode<T extends StoryTransition$toNodeArgs<ExtArgs> = {}>(args?: Subset<T, StoryTransition$toNodeArgs<ExtArgs>>): Prisma__StoryNodeClient<$Result.GetResult<Prisma.$StoryNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    path<T extends StoryPathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoryPathDefaultArgs<ExtArgs>>): Prisma__StoryPathClient<$Result.GetResult<Prisma.$StoryPathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryTransition model
   */
  interface StoryTransitionFieldRefs {
    readonly id: FieldRef<"StoryTransition", 'String'>
    readonly storyId: FieldRef<"StoryTransition", 'String'>
    readonly fromNodeId: FieldRef<"StoryTransition", 'String'>
    readonly pathId: FieldRef<"StoryTransition", 'String'>
    readonly toNodeId: FieldRef<"StoryTransition", 'String'>
    readonly ordering: FieldRef<"StoryTransition", 'Int'>
    readonly condition: FieldRef<"StoryTransition", 'Json'>
    readonly effect: FieldRef<"StoryTransition", 'Json'>
    readonly createdAt: FieldRef<"StoryTransition", 'DateTime'>
    readonly updatedAt: FieldRef<"StoryTransition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoryTransition findUnique
   */
  export type StoryTransitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    /**
     * Filter, which StoryTransition to fetch.
     */
    where: StoryTransitionWhereUniqueInput
  }

  /**
   * StoryTransition findUniqueOrThrow
   */
  export type StoryTransitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    /**
     * Filter, which StoryTransition to fetch.
     */
    where: StoryTransitionWhereUniqueInput
  }

  /**
   * StoryTransition findFirst
   */
  export type StoryTransitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    /**
     * Filter, which StoryTransition to fetch.
     */
    where?: StoryTransitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryTransitions to fetch.
     */
    orderBy?: StoryTransitionOrderByWithRelationInput | StoryTransitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryTransitions.
     */
    cursor?: StoryTransitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryTransitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryTransitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryTransitions.
     */
    distinct?: StoryTransitionScalarFieldEnum | StoryTransitionScalarFieldEnum[]
  }

  /**
   * StoryTransition findFirstOrThrow
   */
  export type StoryTransitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    /**
     * Filter, which StoryTransition to fetch.
     */
    where?: StoryTransitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryTransitions to fetch.
     */
    orderBy?: StoryTransitionOrderByWithRelationInput | StoryTransitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryTransitions.
     */
    cursor?: StoryTransitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryTransitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryTransitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryTransitions.
     */
    distinct?: StoryTransitionScalarFieldEnum | StoryTransitionScalarFieldEnum[]
  }

  /**
   * StoryTransition findMany
   */
  export type StoryTransitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    /**
     * Filter, which StoryTransitions to fetch.
     */
    where?: StoryTransitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryTransitions to fetch.
     */
    orderBy?: StoryTransitionOrderByWithRelationInput | StoryTransitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryTransitions.
     */
    cursor?: StoryTransitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryTransitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryTransitions.
     */
    skip?: number
    distinct?: StoryTransitionScalarFieldEnum | StoryTransitionScalarFieldEnum[]
  }

  /**
   * StoryTransition create
   */
  export type StoryTransitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryTransition.
     */
    data: XOR<StoryTransitionCreateInput, StoryTransitionUncheckedCreateInput>
  }

  /**
   * StoryTransition createMany
   */
  export type StoryTransitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryTransitions.
     */
    data: StoryTransitionCreateManyInput | StoryTransitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryTransition createManyAndReturn
   */
  export type StoryTransitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * The data used to create many StoryTransitions.
     */
    data: StoryTransitionCreateManyInput | StoryTransitionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryTransition update
   */
  export type StoryTransitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryTransition.
     */
    data: XOR<StoryTransitionUpdateInput, StoryTransitionUncheckedUpdateInput>
    /**
     * Choose, which StoryTransition to update.
     */
    where: StoryTransitionWhereUniqueInput
  }

  /**
   * StoryTransition updateMany
   */
  export type StoryTransitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryTransitions.
     */
    data: XOR<StoryTransitionUpdateManyMutationInput, StoryTransitionUncheckedUpdateManyInput>
    /**
     * Filter which StoryTransitions to update
     */
    where?: StoryTransitionWhereInput
    /**
     * Limit how many StoryTransitions to update.
     */
    limit?: number
  }

  /**
   * StoryTransition updateManyAndReturn
   */
  export type StoryTransitionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * The data used to update StoryTransitions.
     */
    data: XOR<StoryTransitionUpdateManyMutationInput, StoryTransitionUncheckedUpdateManyInput>
    /**
     * Filter which StoryTransitions to update
     */
    where?: StoryTransitionWhereInput
    /**
     * Limit how many StoryTransitions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryTransition upsert
   */
  export type StoryTransitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryTransition to update in case it exists.
     */
    where: StoryTransitionWhereUniqueInput
    /**
     * In case the StoryTransition found by the `where` argument doesn't exist, create a new StoryTransition with this data.
     */
    create: XOR<StoryTransitionCreateInput, StoryTransitionUncheckedCreateInput>
    /**
     * In case the StoryTransition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryTransitionUpdateInput, StoryTransitionUncheckedUpdateInput>
  }

  /**
   * StoryTransition delete
   */
  export type StoryTransitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
    /**
     * Filter which StoryTransition to delete.
     */
    where: StoryTransitionWhereUniqueInput
  }

  /**
   * StoryTransition deleteMany
   */
  export type StoryTransitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryTransitions to delete
     */
    where?: StoryTransitionWhereInput
    /**
     * Limit how many StoryTransitions to delete.
     */
    limit?: number
  }

  /**
   * StoryTransition.toNode
   */
  export type StoryTransition$toNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryNode
     */
    select?: StoryNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryNode
     */
    omit?: StoryNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryNodeInclude<ExtArgs> | null
    where?: StoryNodeWhereInput
  }

  /**
   * StoryTransition without action
   */
  export type StoryTransitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryTransition
     */
    select?: StoryTransitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryTransition
     */
    omit?: StoryTransitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryTransitionInclude<ExtArgs> | null
  }


  /**
   * Model AvatarProfile
   */

  export type AggregateAvatarProfile = {
    _count: AvatarProfileCountAggregateOutputType | null
    _avg: AvatarProfileAvgAggregateOutputType | null
    _sum: AvatarProfileSumAggregateOutputType | null
    _min: AvatarProfileMinAggregateOutputType | null
    _max: AvatarProfileMaxAggregateOutputType | null
  }

  export type AvatarProfileAvgAggregateOutputType = {
    age: number | null
    experienceClicks: number | null
    experienceStarts: number | null
  }

  export type AvatarProfileSumAggregateOutputType = {
    age: number | null
    experienceClicks: number | null
    experienceStarts: number | null
  }

  export type AvatarProfileMinAggregateOutputType = {
    id: string | null
    name: string | null
    age: number | null
    background: string | null
    isPlayable: boolean | null
    storyId: string | null
    experienceClicks: number | null
    experienceStarts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvatarProfileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    age: number | null
    background: string | null
    isPlayable: boolean | null
    storyId: string | null
    experienceClicks: number | null
    experienceStarts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvatarProfileCountAggregateOutputType = {
    id: number
    name: number
    age: number
    background: number
    appearance: number
    initialResources: number
    socialContext: number
    isPlayable: number
    storyId: number
    experienceClicks: number
    experienceStarts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AvatarProfileAvgAggregateInputType = {
    age?: true
    experienceClicks?: true
    experienceStarts?: true
  }

  export type AvatarProfileSumAggregateInputType = {
    age?: true
    experienceClicks?: true
    experienceStarts?: true
  }

  export type AvatarProfileMinAggregateInputType = {
    id?: true
    name?: true
    age?: true
    background?: true
    isPlayable?: true
    storyId?: true
    experienceClicks?: true
    experienceStarts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvatarProfileMaxAggregateInputType = {
    id?: true
    name?: true
    age?: true
    background?: true
    isPlayable?: true
    storyId?: true
    experienceClicks?: true
    experienceStarts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvatarProfileCountAggregateInputType = {
    id?: true
    name?: true
    age?: true
    background?: true
    appearance?: true
    initialResources?: true
    socialContext?: true
    isPlayable?: true
    storyId?: true
    experienceClicks?: true
    experienceStarts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AvatarProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvatarProfile to aggregate.
     */
    where?: AvatarProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarProfiles to fetch.
     */
    orderBy?: AvatarProfileOrderByWithRelationInput | AvatarProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvatarProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AvatarProfiles
    **/
    _count?: true | AvatarProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvatarProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvatarProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvatarProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvatarProfileMaxAggregateInputType
  }

  export type GetAvatarProfileAggregateType<T extends AvatarProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateAvatarProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvatarProfile[P]>
      : GetScalarType<T[P], AggregateAvatarProfile[P]>
  }




  export type AvatarProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvatarProfileWhereInput
    orderBy?: AvatarProfileOrderByWithAggregationInput | AvatarProfileOrderByWithAggregationInput[]
    by: AvatarProfileScalarFieldEnum[] | AvatarProfileScalarFieldEnum
    having?: AvatarProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvatarProfileCountAggregateInputType | true
    _avg?: AvatarProfileAvgAggregateInputType
    _sum?: AvatarProfileSumAggregateInputType
    _min?: AvatarProfileMinAggregateInputType
    _max?: AvatarProfileMaxAggregateInputType
  }

  export type AvatarProfileGroupByOutputType = {
    id: string
    name: string
    age: number | null
    background: string | null
    appearance: JsonValue | null
    initialResources: JsonValue
    socialContext: JsonValue | null
    isPlayable: boolean
    storyId: string | null
    experienceClicks: number
    experienceStarts: number
    createdAt: Date
    updatedAt: Date
    _count: AvatarProfileCountAggregateOutputType | null
    _avg: AvatarProfileAvgAggregateOutputType | null
    _sum: AvatarProfileSumAggregateOutputType | null
    _min: AvatarProfileMinAggregateOutputType | null
    _max: AvatarProfileMaxAggregateOutputType | null
  }

  type GetAvatarProfileGroupByPayload<T extends AvatarProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvatarProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvatarProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvatarProfileGroupByOutputType[P]>
            : GetScalarType<T[P], AvatarProfileGroupByOutputType[P]>
        }
      >
    >


  export type AvatarProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    age?: boolean
    background?: boolean
    appearance?: boolean
    initialResources?: boolean
    socialContext?: boolean
    isPlayable?: boolean
    storyId?: boolean
    experienceClicks?: boolean
    experienceStarts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | AvatarProfile$storyArgs<ExtArgs>
    interactions?: boolean | AvatarProfile$interactionsArgs<ExtArgs>
    _count?: boolean | AvatarProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avatarProfile"]>

  export type AvatarProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    age?: boolean
    background?: boolean
    appearance?: boolean
    initialResources?: boolean
    socialContext?: boolean
    isPlayable?: boolean
    storyId?: boolean
    experienceClicks?: boolean
    experienceStarts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | AvatarProfile$storyArgs<ExtArgs>
  }, ExtArgs["result"]["avatarProfile"]>

  export type AvatarProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    age?: boolean
    background?: boolean
    appearance?: boolean
    initialResources?: boolean
    socialContext?: boolean
    isPlayable?: boolean
    storyId?: boolean
    experienceClicks?: boolean
    experienceStarts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | AvatarProfile$storyArgs<ExtArgs>
  }, ExtArgs["result"]["avatarProfile"]>

  export type AvatarProfileSelectScalar = {
    id?: boolean
    name?: boolean
    age?: boolean
    background?: boolean
    appearance?: boolean
    initialResources?: boolean
    socialContext?: boolean
    isPlayable?: boolean
    storyId?: boolean
    experienceClicks?: boolean
    experienceStarts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AvatarProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "age" | "background" | "appearance" | "initialResources" | "socialContext" | "isPlayable" | "storyId" | "experienceClicks" | "experienceStarts" | "createdAt" | "updatedAt", ExtArgs["result"]["avatarProfile"]>
  export type AvatarProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | AvatarProfile$storyArgs<ExtArgs>
    interactions?: boolean | AvatarProfile$interactionsArgs<ExtArgs>
    _count?: boolean | AvatarProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AvatarProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | AvatarProfile$storyArgs<ExtArgs>
  }
  export type AvatarProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | AvatarProfile$storyArgs<ExtArgs>
  }

  export type $AvatarProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AvatarProfile"
    objects: {
      story: Prisma.$TwineStoryPayload<ExtArgs> | null
      interactions: Prisma.$StoryInteractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      age: number | null
      background: string | null
      appearance: Prisma.JsonValue | null
      initialResources: Prisma.JsonValue
      socialContext: Prisma.JsonValue | null
      isPlayable: boolean
      storyId: string | null
      experienceClicks: number
      experienceStarts: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["avatarProfile"]>
    composites: {}
  }

  type AvatarProfileGetPayload<S extends boolean | null | undefined | AvatarProfileDefaultArgs> = $Result.GetResult<Prisma.$AvatarProfilePayload, S>

  type AvatarProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvatarProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvatarProfileCountAggregateInputType | true
    }

  export interface AvatarProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AvatarProfile'], meta: { name: 'AvatarProfile' } }
    /**
     * Find zero or one AvatarProfile that matches the filter.
     * @param {AvatarProfileFindUniqueArgs} args - Arguments to find a AvatarProfile
     * @example
     * // Get one AvatarProfile
     * const avatarProfile = await prisma.avatarProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvatarProfileFindUniqueArgs>(args: SelectSubset<T, AvatarProfileFindUniqueArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AvatarProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvatarProfileFindUniqueOrThrowArgs} args - Arguments to find a AvatarProfile
     * @example
     * // Get one AvatarProfile
     * const avatarProfile = await prisma.avatarProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvatarProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, AvatarProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvatarProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileFindFirstArgs} args - Arguments to find a AvatarProfile
     * @example
     * // Get one AvatarProfile
     * const avatarProfile = await prisma.avatarProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvatarProfileFindFirstArgs>(args?: SelectSubset<T, AvatarProfileFindFirstArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvatarProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileFindFirstOrThrowArgs} args - Arguments to find a AvatarProfile
     * @example
     * // Get one AvatarProfile
     * const avatarProfile = await prisma.avatarProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvatarProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, AvatarProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AvatarProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AvatarProfiles
     * const avatarProfiles = await prisma.avatarProfile.findMany()
     * 
     * // Get first 10 AvatarProfiles
     * const avatarProfiles = await prisma.avatarProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avatarProfileWithIdOnly = await prisma.avatarProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvatarProfileFindManyArgs>(args?: SelectSubset<T, AvatarProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AvatarProfile.
     * @param {AvatarProfileCreateArgs} args - Arguments to create a AvatarProfile.
     * @example
     * // Create one AvatarProfile
     * const AvatarProfile = await prisma.avatarProfile.create({
     *   data: {
     *     // ... data to create a AvatarProfile
     *   }
     * })
     * 
     */
    create<T extends AvatarProfileCreateArgs>(args: SelectSubset<T, AvatarProfileCreateArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AvatarProfiles.
     * @param {AvatarProfileCreateManyArgs} args - Arguments to create many AvatarProfiles.
     * @example
     * // Create many AvatarProfiles
     * const avatarProfile = await prisma.avatarProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvatarProfileCreateManyArgs>(args?: SelectSubset<T, AvatarProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AvatarProfiles and returns the data saved in the database.
     * @param {AvatarProfileCreateManyAndReturnArgs} args - Arguments to create many AvatarProfiles.
     * @example
     * // Create many AvatarProfiles
     * const avatarProfile = await prisma.avatarProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AvatarProfiles and only return the `id`
     * const avatarProfileWithIdOnly = await prisma.avatarProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvatarProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, AvatarProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AvatarProfile.
     * @param {AvatarProfileDeleteArgs} args - Arguments to delete one AvatarProfile.
     * @example
     * // Delete one AvatarProfile
     * const AvatarProfile = await prisma.avatarProfile.delete({
     *   where: {
     *     // ... filter to delete one AvatarProfile
     *   }
     * })
     * 
     */
    delete<T extends AvatarProfileDeleteArgs>(args: SelectSubset<T, AvatarProfileDeleteArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AvatarProfile.
     * @param {AvatarProfileUpdateArgs} args - Arguments to update one AvatarProfile.
     * @example
     * // Update one AvatarProfile
     * const avatarProfile = await prisma.avatarProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvatarProfileUpdateArgs>(args: SelectSubset<T, AvatarProfileUpdateArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AvatarProfiles.
     * @param {AvatarProfileDeleteManyArgs} args - Arguments to filter AvatarProfiles to delete.
     * @example
     * // Delete a few AvatarProfiles
     * const { count } = await prisma.avatarProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvatarProfileDeleteManyArgs>(args?: SelectSubset<T, AvatarProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvatarProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AvatarProfiles
     * const avatarProfile = await prisma.avatarProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvatarProfileUpdateManyArgs>(args: SelectSubset<T, AvatarProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvatarProfiles and returns the data updated in the database.
     * @param {AvatarProfileUpdateManyAndReturnArgs} args - Arguments to update many AvatarProfiles.
     * @example
     * // Update many AvatarProfiles
     * const avatarProfile = await prisma.avatarProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AvatarProfiles and only return the `id`
     * const avatarProfileWithIdOnly = await prisma.avatarProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvatarProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, AvatarProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AvatarProfile.
     * @param {AvatarProfileUpsertArgs} args - Arguments to update or create a AvatarProfile.
     * @example
     * // Update or create a AvatarProfile
     * const avatarProfile = await prisma.avatarProfile.upsert({
     *   create: {
     *     // ... data to create a AvatarProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AvatarProfile we want to update
     *   }
     * })
     */
    upsert<T extends AvatarProfileUpsertArgs>(args: SelectSubset<T, AvatarProfileUpsertArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AvatarProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileCountArgs} args - Arguments to filter AvatarProfiles to count.
     * @example
     * // Count the number of AvatarProfiles
     * const count = await prisma.avatarProfile.count({
     *   where: {
     *     // ... the filter for the AvatarProfiles we want to count
     *   }
     * })
    **/
    count<T extends AvatarProfileCountArgs>(
      args?: Subset<T, AvatarProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvatarProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AvatarProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvatarProfileAggregateArgs>(args: Subset<T, AvatarProfileAggregateArgs>): Prisma.PrismaPromise<GetAvatarProfileAggregateType<T>>

    /**
     * Group by AvatarProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvatarProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvatarProfileGroupByArgs['orderBy'] }
        : { orderBy?: AvatarProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvatarProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvatarProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AvatarProfile model
   */
  readonly fields: AvatarProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AvatarProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvatarProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends AvatarProfile$storyArgs<ExtArgs> = {}>(args?: Subset<T, AvatarProfile$storyArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    interactions<T extends AvatarProfile$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, AvatarProfile$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AvatarProfile model
   */
  interface AvatarProfileFieldRefs {
    readonly id: FieldRef<"AvatarProfile", 'String'>
    readonly name: FieldRef<"AvatarProfile", 'String'>
    readonly age: FieldRef<"AvatarProfile", 'Int'>
    readonly background: FieldRef<"AvatarProfile", 'String'>
    readonly appearance: FieldRef<"AvatarProfile", 'Json'>
    readonly initialResources: FieldRef<"AvatarProfile", 'Json'>
    readonly socialContext: FieldRef<"AvatarProfile", 'Json'>
    readonly isPlayable: FieldRef<"AvatarProfile", 'Boolean'>
    readonly storyId: FieldRef<"AvatarProfile", 'String'>
    readonly experienceClicks: FieldRef<"AvatarProfile", 'Int'>
    readonly experienceStarts: FieldRef<"AvatarProfile", 'Int'>
    readonly createdAt: FieldRef<"AvatarProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"AvatarProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AvatarProfile findUnique
   */
  export type AvatarProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * Filter, which AvatarProfile to fetch.
     */
    where: AvatarProfileWhereUniqueInput
  }

  /**
   * AvatarProfile findUniqueOrThrow
   */
  export type AvatarProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * Filter, which AvatarProfile to fetch.
     */
    where: AvatarProfileWhereUniqueInput
  }

  /**
   * AvatarProfile findFirst
   */
  export type AvatarProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * Filter, which AvatarProfile to fetch.
     */
    where?: AvatarProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarProfiles to fetch.
     */
    orderBy?: AvatarProfileOrderByWithRelationInput | AvatarProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvatarProfiles.
     */
    cursor?: AvatarProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvatarProfiles.
     */
    distinct?: AvatarProfileScalarFieldEnum | AvatarProfileScalarFieldEnum[]
  }

  /**
   * AvatarProfile findFirstOrThrow
   */
  export type AvatarProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * Filter, which AvatarProfile to fetch.
     */
    where?: AvatarProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarProfiles to fetch.
     */
    orderBy?: AvatarProfileOrderByWithRelationInput | AvatarProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvatarProfiles.
     */
    cursor?: AvatarProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvatarProfiles.
     */
    distinct?: AvatarProfileScalarFieldEnum | AvatarProfileScalarFieldEnum[]
  }

  /**
   * AvatarProfile findMany
   */
  export type AvatarProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * Filter, which AvatarProfiles to fetch.
     */
    where?: AvatarProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarProfiles to fetch.
     */
    orderBy?: AvatarProfileOrderByWithRelationInput | AvatarProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AvatarProfiles.
     */
    cursor?: AvatarProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarProfiles.
     */
    skip?: number
    distinct?: AvatarProfileScalarFieldEnum | AvatarProfileScalarFieldEnum[]
  }

  /**
   * AvatarProfile create
   */
  export type AvatarProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a AvatarProfile.
     */
    data: XOR<AvatarProfileCreateInput, AvatarProfileUncheckedCreateInput>
  }

  /**
   * AvatarProfile createMany
   */
  export type AvatarProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AvatarProfiles.
     */
    data: AvatarProfileCreateManyInput | AvatarProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AvatarProfile createManyAndReturn
   */
  export type AvatarProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * The data used to create many AvatarProfiles.
     */
    data: AvatarProfileCreateManyInput | AvatarProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AvatarProfile update
   */
  export type AvatarProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a AvatarProfile.
     */
    data: XOR<AvatarProfileUpdateInput, AvatarProfileUncheckedUpdateInput>
    /**
     * Choose, which AvatarProfile to update.
     */
    where: AvatarProfileWhereUniqueInput
  }

  /**
   * AvatarProfile updateMany
   */
  export type AvatarProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AvatarProfiles.
     */
    data: XOR<AvatarProfileUpdateManyMutationInput, AvatarProfileUncheckedUpdateManyInput>
    /**
     * Filter which AvatarProfiles to update
     */
    where?: AvatarProfileWhereInput
    /**
     * Limit how many AvatarProfiles to update.
     */
    limit?: number
  }

  /**
   * AvatarProfile updateManyAndReturn
   */
  export type AvatarProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * The data used to update AvatarProfiles.
     */
    data: XOR<AvatarProfileUpdateManyMutationInput, AvatarProfileUncheckedUpdateManyInput>
    /**
     * Filter which AvatarProfiles to update
     */
    where?: AvatarProfileWhereInput
    /**
     * Limit how many AvatarProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AvatarProfile upsert
   */
  export type AvatarProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the AvatarProfile to update in case it exists.
     */
    where: AvatarProfileWhereUniqueInput
    /**
     * In case the AvatarProfile found by the `where` argument doesn't exist, create a new AvatarProfile with this data.
     */
    create: XOR<AvatarProfileCreateInput, AvatarProfileUncheckedCreateInput>
    /**
     * In case the AvatarProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvatarProfileUpdateInput, AvatarProfileUncheckedUpdateInput>
  }

  /**
   * AvatarProfile delete
   */
  export type AvatarProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * Filter which AvatarProfile to delete.
     */
    where: AvatarProfileWhereUniqueInput
  }

  /**
   * AvatarProfile deleteMany
   */
  export type AvatarProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvatarProfiles to delete
     */
    where?: AvatarProfileWhereInput
    /**
     * Limit how many AvatarProfiles to delete.
     */
    limit?: number
  }

  /**
   * AvatarProfile.story
   */
  export type AvatarProfile$storyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    where?: TwineStoryWhereInput
  }

  /**
   * AvatarProfile.interactions
   */
  export type AvatarProfile$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    where?: StoryInteractionWhereInput
    orderBy?: StoryInteractionOrderByWithRelationInput | StoryInteractionOrderByWithRelationInput[]
    cursor?: StoryInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryInteractionScalarFieldEnum | StoryInteractionScalarFieldEnum[]
  }

  /**
   * AvatarProfile without action
   */
  export type AvatarProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
  }


  /**
   * Model StoryInteraction
   */

  export type AggregateStoryInteraction = {
    _count: StoryInteractionCountAggregateOutputType | null
    _min: StoryInteractionMinAggregateOutputType | null
    _max: StoryInteractionMaxAggregateOutputType | null
  }

  export type StoryInteractionMinAggregateOutputType = {
    id: string | null
    avatarId: string | null
    storyId: string | null
    sessionId: string | null
    userId: string | null
    kind: $Enums.StoryInteractionKind | null
    createdAt: Date | null
  }

  export type StoryInteractionMaxAggregateOutputType = {
    id: string | null
    avatarId: string | null
    storyId: string | null
    sessionId: string | null
    userId: string | null
    kind: $Enums.StoryInteractionKind | null
    createdAt: Date | null
  }

  export type StoryInteractionCountAggregateOutputType = {
    id: number
    avatarId: number
    storyId: number
    sessionId: number
    userId: number
    kind: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type StoryInteractionMinAggregateInputType = {
    id?: true
    avatarId?: true
    storyId?: true
    sessionId?: true
    userId?: true
    kind?: true
    createdAt?: true
  }

  export type StoryInteractionMaxAggregateInputType = {
    id?: true
    avatarId?: true
    storyId?: true
    sessionId?: true
    userId?: true
    kind?: true
    createdAt?: true
  }

  export type StoryInteractionCountAggregateInputType = {
    id?: true
    avatarId?: true
    storyId?: true
    sessionId?: true
    userId?: true
    kind?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type StoryInteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryInteraction to aggregate.
     */
    where?: StoryInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryInteractions to fetch.
     */
    orderBy?: StoryInteractionOrderByWithRelationInput | StoryInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryInteractions
    **/
    _count?: true | StoryInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryInteractionMaxAggregateInputType
  }

  export type GetStoryInteractionAggregateType<T extends StoryInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryInteraction[P]>
      : GetScalarType<T[P], AggregateStoryInteraction[P]>
  }




  export type StoryInteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryInteractionWhereInput
    orderBy?: StoryInteractionOrderByWithAggregationInput | StoryInteractionOrderByWithAggregationInput[]
    by: StoryInteractionScalarFieldEnum[] | StoryInteractionScalarFieldEnum
    having?: StoryInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryInteractionCountAggregateInputType | true
    _min?: StoryInteractionMinAggregateInputType
    _max?: StoryInteractionMaxAggregateInputType
  }

  export type StoryInteractionGroupByOutputType = {
    id: string
    avatarId: string
    storyId: string | null
    sessionId: string | null
    userId: string | null
    kind: $Enums.StoryInteractionKind
    metadata: JsonValue | null
    createdAt: Date
    _count: StoryInteractionCountAggregateOutputType | null
    _min: StoryInteractionMinAggregateOutputType | null
    _max: StoryInteractionMaxAggregateOutputType | null
  }

  type GetStoryInteractionGroupByPayload<T extends StoryInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], StoryInteractionGroupByOutputType[P]>
        }
      >
    >


  export type StoryInteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avatarId?: boolean
    storyId?: boolean
    sessionId?: boolean
    userId?: boolean
    kind?: boolean
    metadata?: boolean
    createdAt?: boolean
    avatar?: boolean | AvatarProfileDefaultArgs<ExtArgs>
    story?: boolean | StoryInteraction$storyArgs<ExtArgs>
    session?: boolean | StoryInteraction$sessionArgs<ExtArgs>
    user?: boolean | StoryInteraction$userArgs<ExtArgs>
  }, ExtArgs["result"]["storyInteraction"]>

  export type StoryInteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avatarId?: boolean
    storyId?: boolean
    sessionId?: boolean
    userId?: boolean
    kind?: boolean
    metadata?: boolean
    createdAt?: boolean
    avatar?: boolean | AvatarProfileDefaultArgs<ExtArgs>
    story?: boolean | StoryInteraction$storyArgs<ExtArgs>
    session?: boolean | StoryInteraction$sessionArgs<ExtArgs>
    user?: boolean | StoryInteraction$userArgs<ExtArgs>
  }, ExtArgs["result"]["storyInteraction"]>

  export type StoryInteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avatarId?: boolean
    storyId?: boolean
    sessionId?: boolean
    userId?: boolean
    kind?: boolean
    metadata?: boolean
    createdAt?: boolean
    avatar?: boolean | AvatarProfileDefaultArgs<ExtArgs>
    story?: boolean | StoryInteraction$storyArgs<ExtArgs>
    session?: boolean | StoryInteraction$sessionArgs<ExtArgs>
    user?: boolean | StoryInteraction$userArgs<ExtArgs>
  }, ExtArgs["result"]["storyInteraction"]>

  export type StoryInteractionSelectScalar = {
    id?: boolean
    avatarId?: boolean
    storyId?: boolean
    sessionId?: boolean
    userId?: boolean
    kind?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type StoryInteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "avatarId" | "storyId" | "sessionId" | "userId" | "kind" | "metadata" | "createdAt", ExtArgs["result"]["storyInteraction"]>
  export type StoryInteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatar?: boolean | AvatarProfileDefaultArgs<ExtArgs>
    story?: boolean | StoryInteraction$storyArgs<ExtArgs>
    session?: boolean | StoryInteraction$sessionArgs<ExtArgs>
    user?: boolean | StoryInteraction$userArgs<ExtArgs>
  }
  export type StoryInteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatar?: boolean | AvatarProfileDefaultArgs<ExtArgs>
    story?: boolean | StoryInteraction$storyArgs<ExtArgs>
    session?: boolean | StoryInteraction$sessionArgs<ExtArgs>
    user?: boolean | StoryInteraction$userArgs<ExtArgs>
  }
  export type StoryInteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatar?: boolean | AvatarProfileDefaultArgs<ExtArgs>
    story?: boolean | StoryInteraction$storyArgs<ExtArgs>
    session?: boolean | StoryInteraction$sessionArgs<ExtArgs>
    user?: boolean | StoryInteraction$userArgs<ExtArgs>
  }

  export type $StoryInteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryInteraction"
    objects: {
      avatar: Prisma.$AvatarProfilePayload<ExtArgs>
      story: Prisma.$TwineStoryPayload<ExtArgs> | null
      session: Prisma.$UserSessionPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      avatarId: string
      storyId: string | null
      sessionId: string | null
      userId: string | null
      kind: $Enums.StoryInteractionKind
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["storyInteraction"]>
    composites: {}
  }

  type StoryInteractionGetPayload<S extends boolean | null | undefined | StoryInteractionDefaultArgs> = $Result.GetResult<Prisma.$StoryInteractionPayload, S>

  type StoryInteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryInteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryInteractionCountAggregateInputType | true
    }

  export interface StoryInteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryInteraction'], meta: { name: 'StoryInteraction' } }
    /**
     * Find zero or one StoryInteraction that matches the filter.
     * @param {StoryInteractionFindUniqueArgs} args - Arguments to find a StoryInteraction
     * @example
     * // Get one StoryInteraction
     * const storyInteraction = await prisma.storyInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryInteractionFindUniqueArgs>(args: SelectSubset<T, StoryInteractionFindUniqueArgs<ExtArgs>>): Prisma__StoryInteractionClient<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoryInteraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryInteractionFindUniqueOrThrowArgs} args - Arguments to find a StoryInteraction
     * @example
     * // Get one StoryInteraction
     * const storyInteraction = await prisma.storyInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryInteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryInteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryInteractionClient<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryInteractionFindFirstArgs} args - Arguments to find a StoryInteraction
     * @example
     * // Get one StoryInteraction
     * const storyInteraction = await prisma.storyInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryInteractionFindFirstArgs>(args?: SelectSubset<T, StoryInteractionFindFirstArgs<ExtArgs>>): Prisma__StoryInteractionClient<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryInteractionFindFirstOrThrowArgs} args - Arguments to find a StoryInteraction
     * @example
     * // Get one StoryInteraction
     * const storyInteraction = await prisma.storyInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryInteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryInteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryInteractionClient<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoryInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryInteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryInteractions
     * const storyInteractions = await prisma.storyInteraction.findMany()
     * 
     * // Get first 10 StoryInteractions
     * const storyInteractions = await prisma.storyInteraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyInteractionWithIdOnly = await prisma.storyInteraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryInteractionFindManyArgs>(args?: SelectSubset<T, StoryInteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoryInteraction.
     * @param {StoryInteractionCreateArgs} args - Arguments to create a StoryInteraction.
     * @example
     * // Create one StoryInteraction
     * const StoryInteraction = await prisma.storyInteraction.create({
     *   data: {
     *     // ... data to create a StoryInteraction
     *   }
     * })
     * 
     */
    create<T extends StoryInteractionCreateArgs>(args: SelectSubset<T, StoryInteractionCreateArgs<ExtArgs>>): Prisma__StoryInteractionClient<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoryInteractions.
     * @param {StoryInteractionCreateManyArgs} args - Arguments to create many StoryInteractions.
     * @example
     * // Create many StoryInteractions
     * const storyInteraction = await prisma.storyInteraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryInteractionCreateManyArgs>(args?: SelectSubset<T, StoryInteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryInteractions and returns the data saved in the database.
     * @param {StoryInteractionCreateManyAndReturnArgs} args - Arguments to create many StoryInteractions.
     * @example
     * // Create many StoryInteractions
     * const storyInteraction = await prisma.storyInteraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryInteractions and only return the `id`
     * const storyInteractionWithIdOnly = await prisma.storyInteraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryInteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryInteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoryInteraction.
     * @param {StoryInteractionDeleteArgs} args - Arguments to delete one StoryInteraction.
     * @example
     * // Delete one StoryInteraction
     * const StoryInteraction = await prisma.storyInteraction.delete({
     *   where: {
     *     // ... filter to delete one StoryInteraction
     *   }
     * })
     * 
     */
    delete<T extends StoryInteractionDeleteArgs>(args: SelectSubset<T, StoryInteractionDeleteArgs<ExtArgs>>): Prisma__StoryInteractionClient<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoryInteraction.
     * @param {StoryInteractionUpdateArgs} args - Arguments to update one StoryInteraction.
     * @example
     * // Update one StoryInteraction
     * const storyInteraction = await prisma.storyInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryInteractionUpdateArgs>(args: SelectSubset<T, StoryInteractionUpdateArgs<ExtArgs>>): Prisma__StoryInteractionClient<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoryInteractions.
     * @param {StoryInteractionDeleteManyArgs} args - Arguments to filter StoryInteractions to delete.
     * @example
     * // Delete a few StoryInteractions
     * const { count } = await prisma.storyInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryInteractionDeleteManyArgs>(args?: SelectSubset<T, StoryInteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryInteractions
     * const storyInteraction = await prisma.storyInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryInteractionUpdateManyArgs>(args: SelectSubset<T, StoryInteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryInteractions and returns the data updated in the database.
     * @param {StoryInteractionUpdateManyAndReturnArgs} args - Arguments to update many StoryInteractions.
     * @example
     * // Update many StoryInteractions
     * const storyInteraction = await prisma.storyInteraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoryInteractions and only return the `id`
     * const storyInteractionWithIdOnly = await prisma.storyInteraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryInteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryInteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoryInteraction.
     * @param {StoryInteractionUpsertArgs} args - Arguments to update or create a StoryInteraction.
     * @example
     * // Update or create a StoryInteraction
     * const storyInteraction = await prisma.storyInteraction.upsert({
     *   create: {
     *     // ... data to create a StoryInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryInteraction we want to update
     *   }
     * })
     */
    upsert<T extends StoryInteractionUpsertArgs>(args: SelectSubset<T, StoryInteractionUpsertArgs<ExtArgs>>): Prisma__StoryInteractionClient<$Result.GetResult<Prisma.$StoryInteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoryInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryInteractionCountArgs} args - Arguments to filter StoryInteractions to count.
     * @example
     * // Count the number of StoryInteractions
     * const count = await prisma.storyInteraction.count({
     *   where: {
     *     // ... the filter for the StoryInteractions we want to count
     *   }
     * })
    **/
    count<T extends StoryInteractionCountArgs>(
      args?: Subset<T, StoryInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryInteractionAggregateArgs>(args: Subset<T, StoryInteractionAggregateArgs>): Prisma.PrismaPromise<GetStoryInteractionAggregateType<T>>

    /**
     * Group by StoryInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryInteractionGroupByArgs['orderBy'] }
        : { orderBy?: StoryInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryInteraction model
   */
  readonly fields: StoryInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryInteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avatar<T extends AvatarProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AvatarProfileDefaultArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    story<T extends StoryInteraction$storyArgs<ExtArgs> = {}>(args?: Subset<T, StoryInteraction$storyArgs<ExtArgs>>): Prisma__TwineStoryClient<$Result.GetResult<Prisma.$TwineStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    session<T extends StoryInteraction$sessionArgs<ExtArgs> = {}>(args?: Subset<T, StoryInteraction$sessionArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends StoryInteraction$userArgs<ExtArgs> = {}>(args?: Subset<T, StoryInteraction$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryInteraction model
   */
  interface StoryInteractionFieldRefs {
    readonly id: FieldRef<"StoryInteraction", 'String'>
    readonly avatarId: FieldRef<"StoryInteraction", 'String'>
    readonly storyId: FieldRef<"StoryInteraction", 'String'>
    readonly sessionId: FieldRef<"StoryInteraction", 'String'>
    readonly userId: FieldRef<"StoryInteraction", 'String'>
    readonly kind: FieldRef<"StoryInteraction", 'StoryInteractionKind'>
    readonly metadata: FieldRef<"StoryInteraction", 'Json'>
    readonly createdAt: FieldRef<"StoryInteraction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoryInteraction findUnique
   */
  export type StoryInteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    /**
     * Filter, which StoryInteraction to fetch.
     */
    where: StoryInteractionWhereUniqueInput
  }

  /**
   * StoryInteraction findUniqueOrThrow
   */
  export type StoryInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    /**
     * Filter, which StoryInteraction to fetch.
     */
    where: StoryInteractionWhereUniqueInput
  }

  /**
   * StoryInteraction findFirst
   */
  export type StoryInteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    /**
     * Filter, which StoryInteraction to fetch.
     */
    where?: StoryInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryInteractions to fetch.
     */
    orderBy?: StoryInteractionOrderByWithRelationInput | StoryInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryInteractions.
     */
    cursor?: StoryInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryInteractions.
     */
    distinct?: StoryInteractionScalarFieldEnum | StoryInteractionScalarFieldEnum[]
  }

  /**
   * StoryInteraction findFirstOrThrow
   */
  export type StoryInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    /**
     * Filter, which StoryInteraction to fetch.
     */
    where?: StoryInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryInteractions to fetch.
     */
    orderBy?: StoryInteractionOrderByWithRelationInput | StoryInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryInteractions.
     */
    cursor?: StoryInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryInteractions.
     */
    distinct?: StoryInteractionScalarFieldEnum | StoryInteractionScalarFieldEnum[]
  }

  /**
   * StoryInteraction findMany
   */
  export type StoryInteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    /**
     * Filter, which StoryInteractions to fetch.
     */
    where?: StoryInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryInteractions to fetch.
     */
    orderBy?: StoryInteractionOrderByWithRelationInput | StoryInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryInteractions.
     */
    cursor?: StoryInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryInteractions.
     */
    skip?: number
    distinct?: StoryInteractionScalarFieldEnum | StoryInteractionScalarFieldEnum[]
  }

  /**
   * StoryInteraction create
   */
  export type StoryInteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryInteraction.
     */
    data: XOR<StoryInteractionCreateInput, StoryInteractionUncheckedCreateInput>
  }

  /**
   * StoryInteraction createMany
   */
  export type StoryInteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryInteractions.
     */
    data: StoryInteractionCreateManyInput | StoryInteractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryInteraction createManyAndReturn
   */
  export type StoryInteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * The data used to create many StoryInteractions.
     */
    data: StoryInteractionCreateManyInput | StoryInteractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryInteraction update
   */
  export type StoryInteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryInteraction.
     */
    data: XOR<StoryInteractionUpdateInput, StoryInteractionUncheckedUpdateInput>
    /**
     * Choose, which StoryInteraction to update.
     */
    where: StoryInteractionWhereUniqueInput
  }

  /**
   * StoryInteraction updateMany
   */
  export type StoryInteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryInteractions.
     */
    data: XOR<StoryInteractionUpdateManyMutationInput, StoryInteractionUncheckedUpdateManyInput>
    /**
     * Filter which StoryInteractions to update
     */
    where?: StoryInteractionWhereInput
    /**
     * Limit how many StoryInteractions to update.
     */
    limit?: number
  }

  /**
   * StoryInteraction updateManyAndReturn
   */
  export type StoryInteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * The data used to update StoryInteractions.
     */
    data: XOR<StoryInteractionUpdateManyMutationInput, StoryInteractionUncheckedUpdateManyInput>
    /**
     * Filter which StoryInteractions to update
     */
    where?: StoryInteractionWhereInput
    /**
     * Limit how many StoryInteractions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryInteraction upsert
   */
  export type StoryInteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryInteraction to update in case it exists.
     */
    where: StoryInteractionWhereUniqueInput
    /**
     * In case the StoryInteraction found by the `where` argument doesn't exist, create a new StoryInteraction with this data.
     */
    create: XOR<StoryInteractionCreateInput, StoryInteractionUncheckedCreateInput>
    /**
     * In case the StoryInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryInteractionUpdateInput, StoryInteractionUncheckedUpdateInput>
  }

  /**
   * StoryInteraction delete
   */
  export type StoryInteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
    /**
     * Filter which StoryInteraction to delete.
     */
    where: StoryInteractionWhereUniqueInput
  }

  /**
   * StoryInteraction deleteMany
   */
  export type StoryInteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryInteractions to delete
     */
    where?: StoryInteractionWhereInput
    /**
     * Limit how many StoryInteractions to delete.
     */
    limit?: number
  }

  /**
   * StoryInteraction.story
   */
  export type StoryInteraction$storyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwineStory
     */
    select?: TwineStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwineStory
     */
    omit?: TwineStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwineStoryInclude<ExtArgs> | null
    where?: TwineStoryWhereInput
  }

  /**
   * StoryInteraction.session
   */
  export type StoryInteraction$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
  }

  /**
   * StoryInteraction.user
   */
  export type StoryInteraction$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StoryInteraction without action
   */
  export type StoryInteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryInteraction
     */
    select?: StoryInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryInteraction
     */
    omit?: StoryInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInteractionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    hashedPassword: 'hashedPassword',
    role: 'role',
    onboardedAt: 'onboardedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isAdmin: 'isAdmin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    displayName: 'displayName',
    avatarUrl: 'avatarUrl',
    bio: 'bio',
    timezone: 'timezone',
    pronouns: 'pronouns',
    location: 'location',
    publicEmail: 'publicEmail',
    websiteUrl: 'websiteUrl',
    linkedinUrl: 'linkedinUrl',
    twitterHandle: 'twitterHandle',
    instagramHandle: 'instagramHandle',
    tiktokHandle: 'tiktokHandle',
    expertiseTags: 'expertiseTags',
    customLinks: 'customLinks',
    consentAcceptedAt: 'consentAcceptedAt',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const CreatorProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    penName: 'penName',
    headline: 'headline',
    expertiseTags: 'expertiseTags',
    focusAreas: 'focusAreas',
    languages: 'languages',
    tagline: 'tagline',
    biography: 'biography',
    websiteUrl: 'websiteUrl',
    portfolioUrl: 'portfolioUrl',
    contactEmail: 'contactEmail',
    socialLinks: 'socialLinks',
    payoutDetails: 'payoutDetails',
    guidelinesAcceptedAt: 'guidelinesAcceptedAt',
    termsAcceptedAt: 'termsAcceptedAt',
    consentAcceptedAt: 'consentAcceptedAt',
    consentStatement: 'consentStatement',
    status: 'status',
    completedAt: 'completedAt',
    lastReviewedAt: 'lastReviewedAt',
    lastReviewerId: 'lastReviewerId',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CreatorProfileScalarFieldEnum = (typeof CreatorProfileScalarFieldEnum)[keyof typeof CreatorProfileScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    token: 'token',
    kind: 'kind',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const ScenarioScalarFieldEnum: {
    id: 'id',
    title: 'title',
    summary: 'summary',
    issueTag: 'issueTag',
    difficulty: 'difficulty',
    estimatedMinutes: 'estimatedMinutes',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScenarioScalarFieldEnum = (typeof ScenarioScalarFieldEnum)[keyof typeof ScenarioScalarFieldEnum]


  export const JourneyProgressScalarFieldEnum: {
    id: 'id',
    scenarioId: 'scenarioId',
    userId: 'userId',
    sessionId: 'sessionId',
    status: 'status',
    currentNode: 'currentNode',
    checkpoints: 'checkpoints',
    resources: 'resources',
    notes: 'notes',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type JourneyProgressScalarFieldEnum = (typeof JourneyProgressScalarFieldEnum)[keyof typeof JourneyProgressScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    code: 'code',
    title: 'title',
    description: 'description',
    points: 'points',
    icon: 'icon',
    unlockHint: 'unlockHint',
    unlockLogic: 'unlockLogic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    achievementId: 'achievementId',
    userId: 'userId',
    sessionId: 'sessionId',
    journeyId: 'journeyId',
    unlockedAt: 'unlockedAt',
    metadata: 'metadata'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const TwineStoryScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    summary: 'summary',
    tags: 'tags',
    visibility: 'visibility',
    ownerId: 'ownerId',
    originalCreatorId: 'originalCreatorId',
    originalCreatorProfileId: 'originalCreatorProfileId',
    approvedById: 'approvedById',
    ownershipStatus: 'ownershipStatus',
    submittedAt: 'submittedAt',
    transferConsentAt: 'transferConsentAt',
    transferConsentIp: 'transferConsentIp',
    transferConsentUserAgent: 'transferConsentUserAgent',
    approvalToken: 'approvalToken',
    approvalTokenExpiresAt: 'approvalTokenExpiresAt',
    approvedAt: 'approvedAt',
    reviewComment: 'reviewComment',
    creditText: 'creditText',
    latestVersionId: 'latestVersionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwineStoryScalarFieldEnum = (typeof TwineStoryScalarFieldEnum)[keyof typeof TwineStoryScalarFieldEnum]


  export const StoryVersionScalarFieldEnum: {
    id: 'id',
    storyId: 'storyId',
    authorId: 'authorId',
    reviewerId: 'reviewerId',
    versionNumber: 'versionNumber',
    status: 'status',
    changelog: 'changelog',
    content: 'content',
    sourceUrl: 'sourceUrl',
    assetPath: 'assetPath',
    metadata: 'metadata',
    submittedAt: 'submittedAt',
    reviewedAt: 'reviewedAt',
    ownershipStatus: 'ownershipStatus',
    consentSnapshot: 'consentSnapshot',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoryVersionScalarFieldEnum = (typeof StoryVersionScalarFieldEnum)[keyof typeof StoryVersionScalarFieldEnum]


  export const StoryAuditLogScalarFieldEnum: {
    id: 'id',
    storyId: 'storyId',
    actorId: 'actorId',
    action: 'action',
    note: 'note',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type StoryAuditLogScalarFieldEnum = (typeof StoryAuditLogScalarFieldEnum)[keyof typeof StoryAuditLogScalarFieldEnum]


  export const StoryReviewScalarFieldEnum: {
    id: 'id',
    versionId: 'versionId',
    reviewerId: 'reviewerId',
    status: 'status',
    feedback: 'feedback',
    createdAt: 'createdAt'
  };

  export type StoryReviewScalarFieldEnum = (typeof StoryReviewScalarFieldEnum)[keyof typeof StoryReviewScalarFieldEnum]


  export const StoryPlaySessionScalarFieldEnum: {
    id: 'id',
    storyId: 'storyId',
    versionId: 'versionId',
    userId: 'userId',
    sessionId: 'sessionId',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    progress: 'progress',
    rating: 'rating',
    feedback: 'feedback'
  };

  export type StoryPlaySessionScalarFieldEnum = (typeof StoryPlaySessionScalarFieldEnum)[keyof typeof StoryPlaySessionScalarFieldEnum]


  export const StoryNodeScalarFieldEnum: {
    id: 'id',
    storyId: 'storyId',
    key: 'key',
    title: 'title',
    synopsis: 'synopsis',
    type: 'type',
    content: 'content',
    media: 'media',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoryNodeScalarFieldEnum = (typeof StoryNodeScalarFieldEnum)[keyof typeof StoryNodeScalarFieldEnum]


  export const StoryPathScalarFieldEnum: {
    id: 'id',
    storyId: 'storyId',
    key: 'key',
    label: 'label',
    summary: 'summary',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoryPathScalarFieldEnum = (typeof StoryPathScalarFieldEnum)[keyof typeof StoryPathScalarFieldEnum]


  export const StoryTransitionScalarFieldEnum: {
    id: 'id',
    storyId: 'storyId',
    fromNodeId: 'fromNodeId',
    pathId: 'pathId',
    toNodeId: 'toNodeId',
    ordering: 'ordering',
    condition: 'condition',
    effect: 'effect',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoryTransitionScalarFieldEnum = (typeof StoryTransitionScalarFieldEnum)[keyof typeof StoryTransitionScalarFieldEnum]


  export const AvatarProfileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    age: 'age',
    background: 'background',
    appearance: 'appearance',
    initialResources: 'initialResources',
    socialContext: 'socialContext',
    isPlayable: 'isPlayable',
    storyId: 'storyId',
    experienceClicks: 'experienceClicks',
    experienceStarts: 'experienceStarts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AvatarProfileScalarFieldEnum = (typeof AvatarProfileScalarFieldEnum)[keyof typeof AvatarProfileScalarFieldEnum]


  export const StoryInteractionScalarFieldEnum: {
    id: 'id',
    avatarId: 'avatarId',
    storyId: 'storyId',
    sessionId: 'sessionId',
    userId: 'userId',
    kind: 'kind',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type StoryInteractionScalarFieldEnum = (typeof StoryInteractionScalarFieldEnum)[keyof typeof StoryInteractionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'CreatorProfileStatus'
   */
  export type EnumCreatorProfileStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreatorProfileStatus'>
    


  /**
   * Reference to a field of type 'CreatorProfileStatus[]'
   */
  export type ListEnumCreatorProfileStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreatorProfileStatus[]'>
    


  /**
   * Reference to a field of type 'SessionKind'
   */
  export type EnumSessionKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionKind'>
    


  /**
   * Reference to a field of type 'SessionKind[]'
   */
  export type ListEnumSessionKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionKind[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'JourneyStatus'
   */
  export type EnumJourneyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JourneyStatus'>
    


  /**
   * Reference to a field of type 'JourneyStatus[]'
   */
  export type ListEnumJourneyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JourneyStatus[]'>
    


  /**
   * Reference to a field of type 'StoryVisibility'
   */
  export type EnumStoryVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryVisibility'>
    


  /**
   * Reference to a field of type 'StoryVisibility[]'
   */
  export type ListEnumStoryVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryVisibility[]'>
    


  /**
   * Reference to a field of type 'StoryOwnershipStatus'
   */
  export type EnumStoryOwnershipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryOwnershipStatus'>
    


  /**
   * Reference to a field of type 'StoryOwnershipStatus[]'
   */
  export type ListEnumStoryOwnershipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryOwnershipStatus[]'>
    


  /**
   * Reference to a field of type 'StoryStatus'
   */
  export type EnumStoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryStatus'>
    


  /**
   * Reference to a field of type 'StoryStatus[]'
   */
  export type ListEnumStoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryStatus[]'>
    


  /**
   * Reference to a field of type 'StoryNodeType'
   */
  export type EnumStoryNodeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryNodeType'>
    


  /**
   * Reference to a field of type 'StoryNodeType[]'
   */
  export type ListEnumStoryNodeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryNodeType[]'>
    


  /**
   * Reference to a field of type 'StoryInteractionKind'
   */
  export type EnumStoryInteractionKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryInteractionKind'>
    


  /**
   * Reference to a field of type 'StoryInteractionKind[]'
   */
  export type ListEnumStoryInteractionKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryInteractionKind[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    onboardedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isAdmin?: BoolFilter<"User"> | boolean
    profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    sessions?: UserSessionListRelationFilter
    journeys?: JourneyProgressListRelationFilter
    achievements?: UserAchievementListRelationFilter
    storyPlays?: StoryPlaySessionListRelationFilter
    stories?: TwineStoryListRelationFilter
    authoredVersions?: StoryVersionListRelationFilter
    reviewedVersions?: StoryVersionListRelationFilter
    reviews?: StoryReviewListRelationFilter
    creatorProfile?: XOR<CreatorProfileNullableScalarRelationFilter, CreatorProfileWhereInput> | null
    approvedStories?: TwineStoryListRelationFilter
    originalStories?: TwineStoryListRelationFilter
    reviewedCreatorProfiles?: CreatorProfileListRelationFilter
    storyAuditLogs?: StoryAuditLogListRelationFilter
    storyInteractions?: StoryInteractionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    hashedPassword?: SortOrderInput | SortOrder
    role?: SortOrder
    onboardedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAdmin?: SortOrder
    profile?: UserProfileOrderByWithRelationInput
    sessions?: UserSessionOrderByRelationAggregateInput
    journeys?: JourneyProgressOrderByRelationAggregateInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    storyPlays?: StoryPlaySessionOrderByRelationAggregateInput
    stories?: TwineStoryOrderByRelationAggregateInput
    authoredVersions?: StoryVersionOrderByRelationAggregateInput
    reviewedVersions?: StoryVersionOrderByRelationAggregateInput
    reviews?: StoryReviewOrderByRelationAggregateInput
    creatorProfile?: CreatorProfileOrderByWithRelationInput
    approvedStories?: TwineStoryOrderByRelationAggregateInput
    originalStories?: TwineStoryOrderByRelationAggregateInput
    reviewedCreatorProfiles?: CreatorProfileOrderByRelationAggregateInput
    storyAuditLogs?: StoryAuditLogOrderByRelationAggregateInput
    storyInteractions?: StoryInteractionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    hashedPassword?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    onboardedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isAdmin?: BoolFilter<"User"> | boolean
    profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    sessions?: UserSessionListRelationFilter
    journeys?: JourneyProgressListRelationFilter
    achievements?: UserAchievementListRelationFilter
    storyPlays?: StoryPlaySessionListRelationFilter
    stories?: TwineStoryListRelationFilter
    authoredVersions?: StoryVersionListRelationFilter
    reviewedVersions?: StoryVersionListRelationFilter
    reviews?: StoryReviewListRelationFilter
    creatorProfile?: XOR<CreatorProfileNullableScalarRelationFilter, CreatorProfileWhereInput> | null
    approvedStories?: TwineStoryListRelationFilter
    originalStories?: TwineStoryListRelationFilter
    reviewedCreatorProfiles?: CreatorProfileListRelationFilter
    storyAuditLogs?: StoryAuditLogListRelationFilter
    storyInteractions?: StoryInteractionListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    hashedPassword?: SortOrderInput | SortOrder
    role?: SortOrder
    onboardedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAdmin?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    hashedPassword?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    onboardedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    displayName?: StringNullableFilter<"UserProfile"> | string | null
    avatarUrl?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    timezone?: StringNullableFilter<"UserProfile"> | string | null
    pronouns?: StringNullableFilter<"UserProfile"> | string | null
    location?: StringNullableFilter<"UserProfile"> | string | null
    publicEmail?: StringNullableFilter<"UserProfile"> | string | null
    websiteUrl?: StringNullableFilter<"UserProfile"> | string | null
    linkedinUrl?: StringNullableFilter<"UserProfile"> | string | null
    twitterHandle?: StringNullableFilter<"UserProfile"> | string | null
    instagramHandle?: StringNullableFilter<"UserProfile"> | string | null
    tiktokHandle?: StringNullableFilter<"UserProfile"> | string | null
    expertiseTags?: StringNullableListFilter<"UserProfile">
    customLinks?: JsonNullableFilter<"UserProfile">
    consentAcceptedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    preferences?: JsonNullableFilter<"UserProfile">
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    pronouns?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    publicEmail?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    twitterHandle?: SortOrderInput | SortOrder
    instagramHandle?: SortOrderInput | SortOrder
    tiktokHandle?: SortOrderInput | SortOrder
    expertiseTags?: SortOrder
    customLinks?: SortOrderInput | SortOrder
    consentAcceptedAt?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    displayName?: StringNullableFilter<"UserProfile"> | string | null
    avatarUrl?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    timezone?: StringNullableFilter<"UserProfile"> | string | null
    pronouns?: StringNullableFilter<"UserProfile"> | string | null
    location?: StringNullableFilter<"UserProfile"> | string | null
    publicEmail?: StringNullableFilter<"UserProfile"> | string | null
    websiteUrl?: StringNullableFilter<"UserProfile"> | string | null
    linkedinUrl?: StringNullableFilter<"UserProfile"> | string | null
    twitterHandle?: StringNullableFilter<"UserProfile"> | string | null
    instagramHandle?: StringNullableFilter<"UserProfile"> | string | null
    tiktokHandle?: StringNullableFilter<"UserProfile"> | string | null
    expertiseTags?: StringNullableListFilter<"UserProfile">
    customLinks?: JsonNullableFilter<"UserProfile">
    consentAcceptedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    preferences?: JsonNullableFilter<"UserProfile">
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    pronouns?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    publicEmail?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    twitterHandle?: SortOrderInput | SortOrder
    instagramHandle?: SortOrderInput | SortOrder
    tiktokHandle?: SortOrderInput | SortOrder
    expertiseTags?: SortOrder
    customLinks?: SortOrderInput | SortOrder
    consentAcceptedAt?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    displayName?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    pronouns?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    location?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    publicEmail?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    websiteUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    linkedinUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    twitterHandle?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    instagramHandle?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    tiktokHandle?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    expertiseTags?: StringNullableListFilter<"UserProfile">
    customLinks?: JsonNullableWithAggregatesFilter<"UserProfile">
    consentAcceptedAt?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
    preferences?: JsonNullableWithAggregatesFilter<"UserProfile">
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type CreatorProfileWhereInput = {
    AND?: CreatorProfileWhereInput | CreatorProfileWhereInput[]
    OR?: CreatorProfileWhereInput[]
    NOT?: CreatorProfileWhereInput | CreatorProfileWhereInput[]
    id?: StringFilter<"CreatorProfile"> | string
    userId?: StringFilter<"CreatorProfile"> | string
    penName?: StringNullableFilter<"CreatorProfile"> | string | null
    headline?: StringNullableFilter<"CreatorProfile"> | string | null
    expertiseTags?: StringNullableListFilter<"CreatorProfile">
    focusAreas?: StringNullableListFilter<"CreatorProfile">
    languages?: StringNullableListFilter<"CreatorProfile">
    tagline?: StringNullableFilter<"CreatorProfile"> | string | null
    biography?: StringNullableFilter<"CreatorProfile"> | string | null
    websiteUrl?: StringNullableFilter<"CreatorProfile"> | string | null
    portfolioUrl?: StringNullableFilter<"CreatorProfile"> | string | null
    contactEmail?: StringNullableFilter<"CreatorProfile"> | string | null
    socialLinks?: JsonNullableFilter<"CreatorProfile">
    payoutDetails?: JsonNullableFilter<"CreatorProfile">
    guidelinesAcceptedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    termsAcceptedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    consentAcceptedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    consentStatement?: StringNullableFilter<"CreatorProfile"> | string | null
    status?: EnumCreatorProfileStatusFilter<"CreatorProfile"> | $Enums.CreatorProfileStatus
    completedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    lastReviewedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    lastReviewerId?: StringNullableFilter<"CreatorProfile"> | string | null
    rejectionReason?: StringNullableFilter<"CreatorProfile"> | string | null
    createdAt?: DateTimeFilter<"CreatorProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CreatorProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lastReviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    storiesSubmitted?: TwineStoryListRelationFilter
  }

  export type CreatorProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    penName?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    expertiseTags?: SortOrder
    focusAreas?: SortOrder
    languages?: SortOrder
    tagline?: SortOrderInput | SortOrder
    biography?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    portfolioUrl?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    payoutDetails?: SortOrderInput | SortOrder
    guidelinesAcceptedAt?: SortOrderInput | SortOrder
    termsAcceptedAt?: SortOrderInput | SortOrder
    consentAcceptedAt?: SortOrderInput | SortOrder
    consentStatement?: SortOrderInput | SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastReviewedAt?: SortOrderInput | SortOrder
    lastReviewerId?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    lastReviewer?: UserOrderByWithRelationInput
    storiesSubmitted?: TwineStoryOrderByRelationAggregateInput
  }

  export type CreatorProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CreatorProfileWhereInput | CreatorProfileWhereInput[]
    OR?: CreatorProfileWhereInput[]
    NOT?: CreatorProfileWhereInput | CreatorProfileWhereInput[]
    penName?: StringNullableFilter<"CreatorProfile"> | string | null
    headline?: StringNullableFilter<"CreatorProfile"> | string | null
    expertiseTags?: StringNullableListFilter<"CreatorProfile">
    focusAreas?: StringNullableListFilter<"CreatorProfile">
    languages?: StringNullableListFilter<"CreatorProfile">
    tagline?: StringNullableFilter<"CreatorProfile"> | string | null
    biography?: StringNullableFilter<"CreatorProfile"> | string | null
    websiteUrl?: StringNullableFilter<"CreatorProfile"> | string | null
    portfolioUrl?: StringNullableFilter<"CreatorProfile"> | string | null
    contactEmail?: StringNullableFilter<"CreatorProfile"> | string | null
    socialLinks?: JsonNullableFilter<"CreatorProfile">
    payoutDetails?: JsonNullableFilter<"CreatorProfile">
    guidelinesAcceptedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    termsAcceptedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    consentAcceptedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    consentStatement?: StringNullableFilter<"CreatorProfile"> | string | null
    status?: EnumCreatorProfileStatusFilter<"CreatorProfile"> | $Enums.CreatorProfileStatus
    completedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    lastReviewedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    lastReviewerId?: StringNullableFilter<"CreatorProfile"> | string | null
    rejectionReason?: StringNullableFilter<"CreatorProfile"> | string | null
    createdAt?: DateTimeFilter<"CreatorProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CreatorProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lastReviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    storiesSubmitted?: TwineStoryListRelationFilter
  }, "id" | "userId">

  export type CreatorProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    penName?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    expertiseTags?: SortOrder
    focusAreas?: SortOrder
    languages?: SortOrder
    tagline?: SortOrderInput | SortOrder
    biography?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    portfolioUrl?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    payoutDetails?: SortOrderInput | SortOrder
    guidelinesAcceptedAt?: SortOrderInput | SortOrder
    termsAcceptedAt?: SortOrderInput | SortOrder
    consentAcceptedAt?: SortOrderInput | SortOrder
    consentStatement?: SortOrderInput | SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastReviewedAt?: SortOrderInput | SortOrder
    lastReviewerId?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CreatorProfileCountOrderByAggregateInput
    _max?: CreatorProfileMaxOrderByAggregateInput
    _min?: CreatorProfileMinOrderByAggregateInput
  }

  export type CreatorProfileScalarWhereWithAggregatesInput = {
    AND?: CreatorProfileScalarWhereWithAggregatesInput | CreatorProfileScalarWhereWithAggregatesInput[]
    OR?: CreatorProfileScalarWhereWithAggregatesInput[]
    NOT?: CreatorProfileScalarWhereWithAggregatesInput | CreatorProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreatorProfile"> | string
    userId?: StringWithAggregatesFilter<"CreatorProfile"> | string
    penName?: StringNullableWithAggregatesFilter<"CreatorProfile"> | string | null
    headline?: StringNullableWithAggregatesFilter<"CreatorProfile"> | string | null
    expertiseTags?: StringNullableListFilter<"CreatorProfile">
    focusAreas?: StringNullableListFilter<"CreatorProfile">
    languages?: StringNullableListFilter<"CreatorProfile">
    tagline?: StringNullableWithAggregatesFilter<"CreatorProfile"> | string | null
    biography?: StringNullableWithAggregatesFilter<"CreatorProfile"> | string | null
    websiteUrl?: StringNullableWithAggregatesFilter<"CreatorProfile"> | string | null
    portfolioUrl?: StringNullableWithAggregatesFilter<"CreatorProfile"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"CreatorProfile"> | string | null
    socialLinks?: JsonNullableWithAggregatesFilter<"CreatorProfile">
    payoutDetails?: JsonNullableWithAggregatesFilter<"CreatorProfile">
    guidelinesAcceptedAt?: DateTimeNullableWithAggregatesFilter<"CreatorProfile"> | Date | string | null
    termsAcceptedAt?: DateTimeNullableWithAggregatesFilter<"CreatorProfile"> | Date | string | null
    consentAcceptedAt?: DateTimeNullableWithAggregatesFilter<"CreatorProfile"> | Date | string | null
    consentStatement?: StringNullableWithAggregatesFilter<"CreatorProfile"> | string | null
    status?: EnumCreatorProfileStatusWithAggregatesFilter<"CreatorProfile"> | $Enums.CreatorProfileStatus
    completedAt?: DateTimeNullableWithAggregatesFilter<"CreatorProfile"> | Date | string | null
    lastReviewedAt?: DateTimeNullableWithAggregatesFilter<"CreatorProfile"> | Date | string | null
    lastReviewerId?: StringNullableWithAggregatesFilter<"CreatorProfile"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"CreatorProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CreatorProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CreatorProfile"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    kind?: EnumSessionKindFilter<"UserSession"> | $Enums.SessionKind
    userId?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    journeys?: JourneyProgressListRelationFilter
    storyPlays?: StoryPlaySessionListRelationFilter
    achievements?: UserAchievementListRelationFilter
    storyInteractions?: StoryInteractionListRelationFilter
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    kind?: SortOrder
    userId?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    journeys?: JourneyProgressOrderByRelationAggregateInput
    storyPlays?: StoryPlaySessionOrderByRelationAggregateInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    storyInteractions?: StoryInteractionOrderByRelationAggregateInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    kind?: EnumSessionKindFilter<"UserSession"> | $Enums.SessionKind
    userId?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    journeys?: JourneyProgressListRelationFilter
    storyPlays?: StoryPlaySessionListRelationFilter
    achievements?: UserAchievementListRelationFilter
    storyInteractions?: StoryInteractionListRelationFilter
  }, "id" | "token">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    kind?: SortOrder
    userId?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    token?: StringWithAggregatesFilter<"UserSession"> | string
    kind?: EnumSessionKindWithAggregatesFilter<"UserSession"> | $Enums.SessionKind
    userId?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"UserSession"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type ScenarioWhereInput = {
    AND?: ScenarioWhereInput | ScenarioWhereInput[]
    OR?: ScenarioWhereInput[]
    NOT?: ScenarioWhereInput | ScenarioWhereInput[]
    id?: StringFilter<"Scenario"> | string
    title?: StringFilter<"Scenario"> | string
    summary?: StringNullableFilter<"Scenario"> | string | null
    issueTag?: StringNullableFilter<"Scenario"> | string | null
    difficulty?: StringNullableFilter<"Scenario"> | string | null
    estimatedMinutes?: IntNullableFilter<"Scenario"> | number | null
    metadata?: JsonNullableFilter<"Scenario">
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
    journeys?: JourneyProgressListRelationFilter
  }

  export type ScenarioOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    issueTag?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    estimatedMinutes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    journeys?: JourneyProgressOrderByRelationAggregateInput
  }

  export type ScenarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScenarioWhereInput | ScenarioWhereInput[]
    OR?: ScenarioWhereInput[]
    NOT?: ScenarioWhereInput | ScenarioWhereInput[]
    title?: StringFilter<"Scenario"> | string
    summary?: StringNullableFilter<"Scenario"> | string | null
    issueTag?: StringNullableFilter<"Scenario"> | string | null
    difficulty?: StringNullableFilter<"Scenario"> | string | null
    estimatedMinutes?: IntNullableFilter<"Scenario"> | number | null
    metadata?: JsonNullableFilter<"Scenario">
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
    journeys?: JourneyProgressListRelationFilter
  }, "id">

  export type ScenarioOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    issueTag?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    estimatedMinutes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScenarioCountOrderByAggregateInput
    _avg?: ScenarioAvgOrderByAggregateInput
    _max?: ScenarioMaxOrderByAggregateInput
    _min?: ScenarioMinOrderByAggregateInput
    _sum?: ScenarioSumOrderByAggregateInput
  }

  export type ScenarioScalarWhereWithAggregatesInput = {
    AND?: ScenarioScalarWhereWithAggregatesInput | ScenarioScalarWhereWithAggregatesInput[]
    OR?: ScenarioScalarWhereWithAggregatesInput[]
    NOT?: ScenarioScalarWhereWithAggregatesInput | ScenarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Scenario"> | string
    title?: StringWithAggregatesFilter<"Scenario"> | string
    summary?: StringNullableWithAggregatesFilter<"Scenario"> | string | null
    issueTag?: StringNullableWithAggregatesFilter<"Scenario"> | string | null
    difficulty?: StringNullableWithAggregatesFilter<"Scenario"> | string | null
    estimatedMinutes?: IntNullableWithAggregatesFilter<"Scenario"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"Scenario">
    createdAt?: DateTimeWithAggregatesFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Scenario"> | Date | string
  }

  export type JourneyProgressWhereInput = {
    AND?: JourneyProgressWhereInput | JourneyProgressWhereInput[]
    OR?: JourneyProgressWhereInput[]
    NOT?: JourneyProgressWhereInput | JourneyProgressWhereInput[]
    id?: StringFilter<"JourneyProgress"> | string
    scenarioId?: StringFilter<"JourneyProgress"> | string
    userId?: StringNullableFilter<"JourneyProgress"> | string | null
    sessionId?: StringNullableFilter<"JourneyProgress"> | string | null
    status?: EnumJourneyStatusFilter<"JourneyProgress"> | $Enums.JourneyStatus
    currentNode?: StringNullableFilter<"JourneyProgress"> | string | null
    checkpoints?: JsonNullableFilter<"JourneyProgress">
    resources?: JsonNullableFilter<"JourneyProgress">
    notes?: StringNullableFilter<"JourneyProgress"> | string | null
    startedAt?: DateTimeFilter<"JourneyProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"JourneyProgress"> | Date | string | null
    scenario?: XOR<ScenarioScalarRelationFilter, ScenarioWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    session?: XOR<UserSessionNullableScalarRelationFilter, UserSessionWhereInput> | null
    achievements?: UserAchievementListRelationFilter
  }

  export type JourneyProgressOrderByWithRelationInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    status?: SortOrder
    currentNode?: SortOrderInput | SortOrder
    checkpoints?: SortOrderInput | SortOrder
    resources?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    scenario?: ScenarioOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    session?: UserSessionOrderByWithRelationInput
    achievements?: UserAchievementOrderByRelationAggregateInput
  }

  export type JourneyProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_scenarioId?: JourneyProgressUserIdScenarioIdCompoundUniqueInput
    AND?: JourneyProgressWhereInput | JourneyProgressWhereInput[]
    OR?: JourneyProgressWhereInput[]
    NOT?: JourneyProgressWhereInput | JourneyProgressWhereInput[]
    scenarioId?: StringFilter<"JourneyProgress"> | string
    userId?: StringNullableFilter<"JourneyProgress"> | string | null
    sessionId?: StringNullableFilter<"JourneyProgress"> | string | null
    status?: EnumJourneyStatusFilter<"JourneyProgress"> | $Enums.JourneyStatus
    currentNode?: StringNullableFilter<"JourneyProgress"> | string | null
    checkpoints?: JsonNullableFilter<"JourneyProgress">
    resources?: JsonNullableFilter<"JourneyProgress">
    notes?: StringNullableFilter<"JourneyProgress"> | string | null
    startedAt?: DateTimeFilter<"JourneyProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"JourneyProgress"> | Date | string | null
    scenario?: XOR<ScenarioScalarRelationFilter, ScenarioWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    session?: XOR<UserSessionNullableScalarRelationFilter, UserSessionWhereInput> | null
    achievements?: UserAchievementListRelationFilter
  }, "id" | "userId_scenarioId">

  export type JourneyProgressOrderByWithAggregationInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    status?: SortOrder
    currentNode?: SortOrderInput | SortOrder
    checkpoints?: SortOrderInput | SortOrder
    resources?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: JourneyProgressCountOrderByAggregateInput
    _max?: JourneyProgressMaxOrderByAggregateInput
    _min?: JourneyProgressMinOrderByAggregateInput
  }

  export type JourneyProgressScalarWhereWithAggregatesInput = {
    AND?: JourneyProgressScalarWhereWithAggregatesInput | JourneyProgressScalarWhereWithAggregatesInput[]
    OR?: JourneyProgressScalarWhereWithAggregatesInput[]
    NOT?: JourneyProgressScalarWhereWithAggregatesInput | JourneyProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JourneyProgress"> | string
    scenarioId?: StringWithAggregatesFilter<"JourneyProgress"> | string
    userId?: StringNullableWithAggregatesFilter<"JourneyProgress"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"JourneyProgress"> | string | null
    status?: EnumJourneyStatusWithAggregatesFilter<"JourneyProgress"> | $Enums.JourneyStatus
    currentNode?: StringNullableWithAggregatesFilter<"JourneyProgress"> | string | null
    checkpoints?: JsonNullableWithAggregatesFilter<"JourneyProgress">
    resources?: JsonNullableWithAggregatesFilter<"JourneyProgress">
    notes?: StringNullableWithAggregatesFilter<"JourneyProgress"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"JourneyProgress"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"JourneyProgress"> | Date | string | null
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    code?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    points?: IntFilter<"Achievement"> | number
    icon?: StringNullableFilter<"Achievement"> | string | null
    unlockHint?: StringNullableFilter<"Achievement"> | string | null
    unlockLogic?: JsonNullableFilter<"Achievement">
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    userAwards?: UserAchievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    icon?: SortOrderInput | SortOrder
    unlockHint?: SortOrderInput | SortOrder
    unlockLogic?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userAwards?: UserAchievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    points?: IntFilter<"Achievement"> | number
    icon?: StringNullableFilter<"Achievement"> | string | null
    unlockHint?: StringNullableFilter<"Achievement"> | string | null
    unlockLogic?: JsonNullableFilter<"Achievement">
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    userAwards?: UserAchievementListRelationFilter
  }, "id" | "code">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    icon?: SortOrderInput | SortOrder
    unlockHint?: SortOrderInput | SortOrder
    unlockLogic?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    code?: StringWithAggregatesFilter<"Achievement"> | string
    title?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    points?: IntWithAggregatesFilter<"Achievement"> | number
    icon?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    unlockHint?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    unlockLogic?: JsonNullableWithAggregatesFilter<"Achievement">
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    userId?: StringNullableFilter<"UserAchievement"> | string | null
    sessionId?: StringNullableFilter<"UserAchievement"> | string | null
    journeyId?: StringNullableFilter<"UserAchievement"> | string | null
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    metadata?: JsonNullableFilter<"UserAchievement">
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    session?: XOR<UserSessionNullableScalarRelationFilter, UserSessionWhereInput> | null
    journey?: XOR<JourneyProgressNullableScalarRelationFilter, JourneyProgressWhereInput> | null
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    achievementId?: SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    journeyId?: SortOrderInput | SortOrder
    unlockedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    achievement?: AchievementOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    session?: UserSessionOrderByWithRelationInput
    journey?: JourneyProgressOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    achievementId?: StringFilter<"UserAchievement"> | string
    userId?: StringNullableFilter<"UserAchievement"> | string | null
    sessionId?: StringNullableFilter<"UserAchievement"> | string | null
    journeyId?: StringNullableFilter<"UserAchievement"> | string | null
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    metadata?: JsonNullableFilter<"UserAchievement">
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    session?: XOR<UserSessionNullableScalarRelationFilter, UserSessionWhereInput> | null
    journey?: XOR<JourneyProgressNullableScalarRelationFilter, JourneyProgressWhereInput> | null
  }, "id">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    achievementId?: SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    journeyId?: SortOrderInput | SortOrder
    unlockedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"UserAchievement"> | string
    userId?: StringNullableWithAggregatesFilter<"UserAchievement"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"UserAchievement"> | string | null
    journeyId?: StringNullableWithAggregatesFilter<"UserAchievement"> | string | null
    unlockedAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"UserAchievement">
  }

  export type TwineStoryWhereInput = {
    AND?: TwineStoryWhereInput | TwineStoryWhereInput[]
    OR?: TwineStoryWhereInput[]
    NOT?: TwineStoryWhereInput | TwineStoryWhereInput[]
    id?: StringFilter<"TwineStory"> | string
    slug?: StringFilter<"TwineStory"> | string
    title?: StringFilter<"TwineStory"> | string
    summary?: StringNullableFilter<"TwineStory"> | string | null
    tags?: StringNullableListFilter<"TwineStory">
    visibility?: EnumStoryVisibilityFilter<"TwineStory"> | $Enums.StoryVisibility
    ownerId?: StringNullableFilter<"TwineStory"> | string | null
    originalCreatorId?: StringNullableFilter<"TwineStory"> | string | null
    originalCreatorProfileId?: StringNullableFilter<"TwineStory"> | string | null
    approvedById?: StringNullableFilter<"TwineStory"> | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFilter<"TwineStory"> | $Enums.StoryOwnershipStatus
    submittedAt?: DateTimeNullableFilter<"TwineStory"> | Date | string | null
    transferConsentAt?: DateTimeNullableFilter<"TwineStory"> | Date | string | null
    transferConsentIp?: StringNullableFilter<"TwineStory"> | string | null
    transferConsentUserAgent?: StringNullableFilter<"TwineStory"> | string | null
    approvalToken?: StringNullableFilter<"TwineStory"> | string | null
    approvalTokenExpiresAt?: DateTimeNullableFilter<"TwineStory"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"TwineStory"> | Date | string | null
    reviewComment?: StringNullableFilter<"TwineStory"> | string | null
    creditText?: StringNullableFilter<"TwineStory"> | string | null
    latestVersionId?: StringNullableFilter<"TwineStory"> | string | null
    createdAt?: DateTimeFilter<"TwineStory"> | Date | string
    updatedAt?: DateTimeFilter<"TwineStory"> | Date | string
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    originalCreator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    originalCreatorProfile?: XOR<CreatorProfileNullableScalarRelationFilter, CreatorProfileWhereInput> | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    versions?: StoryVersionListRelationFilter
    latestVersion?: XOR<StoryVersionNullableScalarRelationFilter, StoryVersionWhereInput> | null
    playSessions?: StoryPlaySessionListRelationFilter
    nodes?: StoryNodeListRelationFilter
    paths?: StoryPathListRelationFilter
    transitions?: StoryTransitionListRelationFilter
    avatars?: AvatarProfileListRelationFilter
    auditLogs?: StoryAuditLogListRelationFilter
    interactions?: StoryInteractionListRelationFilter
  }

  export type TwineStoryOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    tags?: SortOrder
    visibility?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    originalCreatorId?: SortOrderInput | SortOrder
    originalCreatorProfileId?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    ownershipStatus?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    transferConsentAt?: SortOrderInput | SortOrder
    transferConsentIp?: SortOrderInput | SortOrder
    transferConsentUserAgent?: SortOrderInput | SortOrder
    approvalToken?: SortOrderInput | SortOrder
    approvalTokenExpiresAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    reviewComment?: SortOrderInput | SortOrder
    creditText?: SortOrderInput | SortOrder
    latestVersionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    originalCreator?: UserOrderByWithRelationInput
    originalCreatorProfile?: CreatorProfileOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
    versions?: StoryVersionOrderByRelationAggregateInput
    latestVersion?: StoryVersionOrderByWithRelationInput
    playSessions?: StoryPlaySessionOrderByRelationAggregateInput
    nodes?: StoryNodeOrderByRelationAggregateInput
    paths?: StoryPathOrderByRelationAggregateInput
    transitions?: StoryTransitionOrderByRelationAggregateInput
    avatars?: AvatarProfileOrderByRelationAggregateInput
    auditLogs?: StoryAuditLogOrderByRelationAggregateInput
    interactions?: StoryInteractionOrderByRelationAggregateInput
  }

  export type TwineStoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    latestVersionId?: string
    AND?: TwineStoryWhereInput | TwineStoryWhereInput[]
    OR?: TwineStoryWhereInput[]
    NOT?: TwineStoryWhereInput | TwineStoryWhereInput[]
    title?: StringFilter<"TwineStory"> | string
    summary?: StringNullableFilter<"TwineStory"> | string | null
    tags?: StringNullableListFilter<"TwineStory">
    visibility?: EnumStoryVisibilityFilter<"TwineStory"> | $Enums.StoryVisibility
    ownerId?: StringNullableFilter<"TwineStory"> | string | null
    originalCreatorId?: StringNullableFilter<"TwineStory"> | string | null
    originalCreatorProfileId?: StringNullableFilter<"TwineStory"> | string | null
    approvedById?: StringNullableFilter<"TwineStory"> | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFilter<"TwineStory"> | $Enums.StoryOwnershipStatus
    submittedAt?: DateTimeNullableFilter<"TwineStory"> | Date | string | null
    transferConsentAt?: DateTimeNullableFilter<"TwineStory"> | Date | string | null
    transferConsentIp?: StringNullableFilter<"TwineStory"> | string | null
    transferConsentUserAgent?: StringNullableFilter<"TwineStory"> | string | null
    approvalToken?: StringNullableFilter<"TwineStory"> | string | null
    approvalTokenExpiresAt?: DateTimeNullableFilter<"TwineStory"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"TwineStory"> | Date | string | null
    reviewComment?: StringNullableFilter<"TwineStory"> | string | null
    creditText?: StringNullableFilter<"TwineStory"> | string | null
    createdAt?: DateTimeFilter<"TwineStory"> | Date | string
    updatedAt?: DateTimeFilter<"TwineStory"> | Date | string
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    originalCreator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    originalCreatorProfile?: XOR<CreatorProfileNullableScalarRelationFilter, CreatorProfileWhereInput> | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    versions?: StoryVersionListRelationFilter
    latestVersion?: XOR<StoryVersionNullableScalarRelationFilter, StoryVersionWhereInput> | null
    playSessions?: StoryPlaySessionListRelationFilter
    nodes?: StoryNodeListRelationFilter
    paths?: StoryPathListRelationFilter
    transitions?: StoryTransitionListRelationFilter
    avatars?: AvatarProfileListRelationFilter
    auditLogs?: StoryAuditLogListRelationFilter
    interactions?: StoryInteractionListRelationFilter
  }, "id" | "slug" | "latestVersionId">

  export type TwineStoryOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    tags?: SortOrder
    visibility?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    originalCreatorId?: SortOrderInput | SortOrder
    originalCreatorProfileId?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    ownershipStatus?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    transferConsentAt?: SortOrderInput | SortOrder
    transferConsentIp?: SortOrderInput | SortOrder
    transferConsentUserAgent?: SortOrderInput | SortOrder
    approvalToken?: SortOrderInput | SortOrder
    approvalTokenExpiresAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    reviewComment?: SortOrderInput | SortOrder
    creditText?: SortOrderInput | SortOrder
    latestVersionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwineStoryCountOrderByAggregateInput
    _max?: TwineStoryMaxOrderByAggregateInput
    _min?: TwineStoryMinOrderByAggregateInput
  }

  export type TwineStoryScalarWhereWithAggregatesInput = {
    AND?: TwineStoryScalarWhereWithAggregatesInput | TwineStoryScalarWhereWithAggregatesInput[]
    OR?: TwineStoryScalarWhereWithAggregatesInput[]
    NOT?: TwineStoryScalarWhereWithAggregatesInput | TwineStoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwineStory"> | string
    slug?: StringWithAggregatesFilter<"TwineStory"> | string
    title?: StringWithAggregatesFilter<"TwineStory"> | string
    summary?: StringNullableWithAggregatesFilter<"TwineStory"> | string | null
    tags?: StringNullableListFilter<"TwineStory">
    visibility?: EnumStoryVisibilityWithAggregatesFilter<"TwineStory"> | $Enums.StoryVisibility
    ownerId?: StringNullableWithAggregatesFilter<"TwineStory"> | string | null
    originalCreatorId?: StringNullableWithAggregatesFilter<"TwineStory"> | string | null
    originalCreatorProfileId?: StringNullableWithAggregatesFilter<"TwineStory"> | string | null
    approvedById?: StringNullableWithAggregatesFilter<"TwineStory"> | string | null
    ownershipStatus?: EnumStoryOwnershipStatusWithAggregatesFilter<"TwineStory"> | $Enums.StoryOwnershipStatus
    submittedAt?: DateTimeNullableWithAggregatesFilter<"TwineStory"> | Date | string | null
    transferConsentAt?: DateTimeNullableWithAggregatesFilter<"TwineStory"> | Date | string | null
    transferConsentIp?: StringNullableWithAggregatesFilter<"TwineStory"> | string | null
    transferConsentUserAgent?: StringNullableWithAggregatesFilter<"TwineStory"> | string | null
    approvalToken?: StringNullableWithAggregatesFilter<"TwineStory"> | string | null
    approvalTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"TwineStory"> | Date | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"TwineStory"> | Date | string | null
    reviewComment?: StringNullableWithAggregatesFilter<"TwineStory"> | string | null
    creditText?: StringNullableWithAggregatesFilter<"TwineStory"> | string | null
    latestVersionId?: StringNullableWithAggregatesFilter<"TwineStory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TwineStory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TwineStory"> | Date | string
  }

  export type StoryVersionWhereInput = {
    AND?: StoryVersionWhereInput | StoryVersionWhereInput[]
    OR?: StoryVersionWhereInput[]
    NOT?: StoryVersionWhereInput | StoryVersionWhereInput[]
    id?: StringFilter<"StoryVersion"> | string
    storyId?: StringFilter<"StoryVersion"> | string
    authorId?: StringNullableFilter<"StoryVersion"> | string | null
    reviewerId?: StringNullableFilter<"StoryVersion"> | string | null
    versionNumber?: IntFilter<"StoryVersion"> | number
    status?: EnumStoryStatusFilter<"StoryVersion"> | $Enums.StoryStatus
    changelog?: StringNullableFilter<"StoryVersion"> | string | null
    content?: JsonNullableFilter<"StoryVersion">
    sourceUrl?: StringNullableFilter<"StoryVersion"> | string | null
    assetPath?: StringNullableFilter<"StoryVersion"> | string | null
    metadata?: JsonNullableFilter<"StoryVersion">
    submittedAt?: DateTimeNullableFilter<"StoryVersion"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"StoryVersion"> | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFilter<"StoryVersion"> | $Enums.StoryOwnershipStatus
    consentSnapshot?: JsonNullableFilter<"StoryVersion">
    createdAt?: DateTimeFilter<"StoryVersion"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StoryVersion"> | Date | string | null
    story?: XOR<TwineStoryScalarRelationFilter, TwineStoryWhereInput>
    featuredIn?: XOR<TwineStoryNullableScalarRelationFilter, TwineStoryWhereInput> | null
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reviews?: StoryReviewListRelationFilter
    playSessions?: StoryPlaySessionListRelationFilter
  }

  export type StoryVersionOrderByWithRelationInput = {
    id?: SortOrder
    storyId?: SortOrder
    authorId?: SortOrderInput | SortOrder
    reviewerId?: SortOrderInput | SortOrder
    versionNumber?: SortOrder
    status?: SortOrder
    changelog?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    assetPath?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    ownershipStatus?: SortOrder
    consentSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    story?: TwineStoryOrderByWithRelationInput
    featuredIn?: TwineStoryOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
    reviews?: StoryReviewOrderByRelationAggregateInput
    playSessions?: StoryPlaySessionOrderByRelationAggregateInput
  }

  export type StoryVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryVersionWhereInput | StoryVersionWhereInput[]
    OR?: StoryVersionWhereInput[]
    NOT?: StoryVersionWhereInput | StoryVersionWhereInput[]
    storyId?: StringFilter<"StoryVersion"> | string
    authorId?: StringNullableFilter<"StoryVersion"> | string | null
    reviewerId?: StringNullableFilter<"StoryVersion"> | string | null
    versionNumber?: IntFilter<"StoryVersion"> | number
    status?: EnumStoryStatusFilter<"StoryVersion"> | $Enums.StoryStatus
    changelog?: StringNullableFilter<"StoryVersion"> | string | null
    content?: JsonNullableFilter<"StoryVersion">
    sourceUrl?: StringNullableFilter<"StoryVersion"> | string | null
    assetPath?: StringNullableFilter<"StoryVersion"> | string | null
    metadata?: JsonNullableFilter<"StoryVersion">
    submittedAt?: DateTimeNullableFilter<"StoryVersion"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"StoryVersion"> | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFilter<"StoryVersion"> | $Enums.StoryOwnershipStatus
    consentSnapshot?: JsonNullableFilter<"StoryVersion">
    createdAt?: DateTimeFilter<"StoryVersion"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StoryVersion"> | Date | string | null
    story?: XOR<TwineStoryScalarRelationFilter, TwineStoryWhereInput>
    featuredIn?: XOR<TwineStoryNullableScalarRelationFilter, TwineStoryWhereInput> | null
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reviews?: StoryReviewListRelationFilter
    playSessions?: StoryPlaySessionListRelationFilter
  }, "id">

  export type StoryVersionOrderByWithAggregationInput = {
    id?: SortOrder
    storyId?: SortOrder
    authorId?: SortOrderInput | SortOrder
    reviewerId?: SortOrderInput | SortOrder
    versionNumber?: SortOrder
    status?: SortOrder
    changelog?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    assetPath?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    ownershipStatus?: SortOrder
    consentSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: StoryVersionCountOrderByAggregateInput
    _avg?: StoryVersionAvgOrderByAggregateInput
    _max?: StoryVersionMaxOrderByAggregateInput
    _min?: StoryVersionMinOrderByAggregateInput
    _sum?: StoryVersionSumOrderByAggregateInput
  }

  export type StoryVersionScalarWhereWithAggregatesInput = {
    AND?: StoryVersionScalarWhereWithAggregatesInput | StoryVersionScalarWhereWithAggregatesInput[]
    OR?: StoryVersionScalarWhereWithAggregatesInput[]
    NOT?: StoryVersionScalarWhereWithAggregatesInput | StoryVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryVersion"> | string
    storyId?: StringWithAggregatesFilter<"StoryVersion"> | string
    authorId?: StringNullableWithAggregatesFilter<"StoryVersion"> | string | null
    reviewerId?: StringNullableWithAggregatesFilter<"StoryVersion"> | string | null
    versionNumber?: IntWithAggregatesFilter<"StoryVersion"> | number
    status?: EnumStoryStatusWithAggregatesFilter<"StoryVersion"> | $Enums.StoryStatus
    changelog?: StringNullableWithAggregatesFilter<"StoryVersion"> | string | null
    content?: JsonNullableWithAggregatesFilter<"StoryVersion">
    sourceUrl?: StringNullableWithAggregatesFilter<"StoryVersion"> | string | null
    assetPath?: StringNullableWithAggregatesFilter<"StoryVersion"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"StoryVersion">
    submittedAt?: DateTimeNullableWithAggregatesFilter<"StoryVersion"> | Date | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"StoryVersion"> | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusWithAggregatesFilter<"StoryVersion"> | $Enums.StoryOwnershipStatus
    consentSnapshot?: JsonNullableWithAggregatesFilter<"StoryVersion">
    createdAt?: DateTimeWithAggregatesFilter<"StoryVersion"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"StoryVersion"> | Date | string | null
  }

  export type StoryAuditLogWhereInput = {
    AND?: StoryAuditLogWhereInput | StoryAuditLogWhereInput[]
    OR?: StoryAuditLogWhereInput[]
    NOT?: StoryAuditLogWhereInput | StoryAuditLogWhereInput[]
    id?: StringFilter<"StoryAuditLog"> | string
    storyId?: StringFilter<"StoryAuditLog"> | string
    actorId?: StringNullableFilter<"StoryAuditLog"> | string | null
    action?: StringFilter<"StoryAuditLog"> | string
    note?: StringNullableFilter<"StoryAuditLog"> | string | null
    metadata?: JsonNullableFilter<"StoryAuditLog">
    createdAt?: DateTimeFilter<"StoryAuditLog"> | Date | string
    story?: XOR<TwineStoryScalarRelationFilter, TwineStoryWhereInput>
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type StoryAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    storyId?: SortOrder
    actorId?: SortOrderInput | SortOrder
    action?: SortOrder
    note?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    story?: TwineStoryOrderByWithRelationInput
    actor?: UserOrderByWithRelationInput
  }

  export type StoryAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryAuditLogWhereInput | StoryAuditLogWhereInput[]
    OR?: StoryAuditLogWhereInput[]
    NOT?: StoryAuditLogWhereInput | StoryAuditLogWhereInput[]
    storyId?: StringFilter<"StoryAuditLog"> | string
    actorId?: StringNullableFilter<"StoryAuditLog"> | string | null
    action?: StringFilter<"StoryAuditLog"> | string
    note?: StringNullableFilter<"StoryAuditLog"> | string | null
    metadata?: JsonNullableFilter<"StoryAuditLog">
    createdAt?: DateTimeFilter<"StoryAuditLog"> | Date | string
    story?: XOR<TwineStoryScalarRelationFilter, TwineStoryWhereInput>
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type StoryAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    storyId?: SortOrder
    actorId?: SortOrderInput | SortOrder
    action?: SortOrder
    note?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StoryAuditLogCountOrderByAggregateInput
    _max?: StoryAuditLogMaxOrderByAggregateInput
    _min?: StoryAuditLogMinOrderByAggregateInput
  }

  export type StoryAuditLogScalarWhereWithAggregatesInput = {
    AND?: StoryAuditLogScalarWhereWithAggregatesInput | StoryAuditLogScalarWhereWithAggregatesInput[]
    OR?: StoryAuditLogScalarWhereWithAggregatesInput[]
    NOT?: StoryAuditLogScalarWhereWithAggregatesInput | StoryAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryAuditLog"> | string
    storyId?: StringWithAggregatesFilter<"StoryAuditLog"> | string
    actorId?: StringNullableWithAggregatesFilter<"StoryAuditLog"> | string | null
    action?: StringWithAggregatesFilter<"StoryAuditLog"> | string
    note?: StringNullableWithAggregatesFilter<"StoryAuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"StoryAuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"StoryAuditLog"> | Date | string
  }

  export type StoryReviewWhereInput = {
    AND?: StoryReviewWhereInput | StoryReviewWhereInput[]
    OR?: StoryReviewWhereInput[]
    NOT?: StoryReviewWhereInput | StoryReviewWhereInput[]
    id?: StringFilter<"StoryReview"> | string
    versionId?: StringFilter<"StoryReview"> | string
    reviewerId?: StringFilter<"StoryReview"> | string
    status?: EnumStoryStatusFilter<"StoryReview"> | $Enums.StoryStatus
    feedback?: StringNullableFilter<"StoryReview"> | string | null
    createdAt?: DateTimeFilter<"StoryReview"> | Date | string
    version?: XOR<StoryVersionScalarRelationFilter, StoryVersionWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StoryReviewOrderByWithRelationInput = {
    id?: SortOrder
    versionId?: SortOrder
    reviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    version?: StoryVersionOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type StoryReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryReviewWhereInput | StoryReviewWhereInput[]
    OR?: StoryReviewWhereInput[]
    NOT?: StoryReviewWhereInput | StoryReviewWhereInput[]
    versionId?: StringFilter<"StoryReview"> | string
    reviewerId?: StringFilter<"StoryReview"> | string
    status?: EnumStoryStatusFilter<"StoryReview"> | $Enums.StoryStatus
    feedback?: StringNullableFilter<"StoryReview"> | string | null
    createdAt?: DateTimeFilter<"StoryReview"> | Date | string
    version?: XOR<StoryVersionScalarRelationFilter, StoryVersionWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type StoryReviewOrderByWithAggregationInput = {
    id?: SortOrder
    versionId?: SortOrder
    reviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StoryReviewCountOrderByAggregateInput
    _max?: StoryReviewMaxOrderByAggregateInput
    _min?: StoryReviewMinOrderByAggregateInput
  }

  export type StoryReviewScalarWhereWithAggregatesInput = {
    AND?: StoryReviewScalarWhereWithAggregatesInput | StoryReviewScalarWhereWithAggregatesInput[]
    OR?: StoryReviewScalarWhereWithAggregatesInput[]
    NOT?: StoryReviewScalarWhereWithAggregatesInput | StoryReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryReview"> | string
    versionId?: StringWithAggregatesFilter<"StoryReview"> | string
    reviewerId?: StringWithAggregatesFilter<"StoryReview"> | string
    status?: EnumStoryStatusWithAggregatesFilter<"StoryReview"> | $Enums.StoryStatus
    feedback?: StringNullableWithAggregatesFilter<"StoryReview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StoryReview"> | Date | string
  }

  export type StoryPlaySessionWhereInput = {
    AND?: StoryPlaySessionWhereInput | StoryPlaySessionWhereInput[]
    OR?: StoryPlaySessionWhereInput[]
    NOT?: StoryPlaySessionWhereInput | StoryPlaySessionWhereInput[]
    id?: StringFilter<"StoryPlaySession"> | string
    storyId?: StringFilter<"StoryPlaySession"> | string
    versionId?: StringNullableFilter<"StoryPlaySession"> | string | null
    userId?: StringNullableFilter<"StoryPlaySession"> | string | null
    sessionId?: StringNullableFilter<"StoryPlaySession"> | string | null
    startedAt?: DateTimeFilter<"StoryPlaySession"> | Date | string
    completedAt?: DateTimeNullableFilter<"StoryPlaySession"> | Date | string | null
    progress?: JsonNullableFilter<"StoryPlaySession">
    rating?: IntNullableFilter<"StoryPlaySession"> | number | null
    feedback?: StringNullableFilter<"StoryPlaySession"> | string | null
    story?: XOR<TwineStoryScalarRelationFilter, TwineStoryWhereInput>
    version?: XOR<StoryVersionNullableScalarRelationFilter, StoryVersionWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    session?: XOR<UserSessionNullableScalarRelationFilter, UserSessionWhereInput> | null
  }

  export type StoryPlaySessionOrderByWithRelationInput = {
    id?: SortOrder
    storyId?: SortOrder
    versionId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    story?: TwineStoryOrderByWithRelationInput
    version?: StoryVersionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    session?: UserSessionOrderByWithRelationInput
  }

  export type StoryPlaySessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryPlaySessionWhereInput | StoryPlaySessionWhereInput[]
    OR?: StoryPlaySessionWhereInput[]
    NOT?: StoryPlaySessionWhereInput | StoryPlaySessionWhereInput[]
    storyId?: StringFilter<"StoryPlaySession"> | string
    versionId?: StringNullableFilter<"StoryPlaySession"> | string | null
    userId?: StringNullableFilter<"StoryPlaySession"> | string | null
    sessionId?: StringNullableFilter<"StoryPlaySession"> | string | null
    startedAt?: DateTimeFilter<"StoryPlaySession"> | Date | string
    completedAt?: DateTimeNullableFilter<"StoryPlaySession"> | Date | string | null
    progress?: JsonNullableFilter<"StoryPlaySession">
    rating?: IntNullableFilter<"StoryPlaySession"> | number | null
    feedback?: StringNullableFilter<"StoryPlaySession"> | string | null
    story?: XOR<TwineStoryScalarRelationFilter, TwineStoryWhereInput>
    version?: XOR<StoryVersionNullableScalarRelationFilter, StoryVersionWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    session?: XOR<UserSessionNullableScalarRelationFilter, UserSessionWhereInput> | null
  }, "id">

  export type StoryPlaySessionOrderByWithAggregationInput = {
    id?: SortOrder
    storyId?: SortOrder
    versionId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    _count?: StoryPlaySessionCountOrderByAggregateInput
    _avg?: StoryPlaySessionAvgOrderByAggregateInput
    _max?: StoryPlaySessionMaxOrderByAggregateInput
    _min?: StoryPlaySessionMinOrderByAggregateInput
    _sum?: StoryPlaySessionSumOrderByAggregateInput
  }

  export type StoryPlaySessionScalarWhereWithAggregatesInput = {
    AND?: StoryPlaySessionScalarWhereWithAggregatesInput | StoryPlaySessionScalarWhereWithAggregatesInput[]
    OR?: StoryPlaySessionScalarWhereWithAggregatesInput[]
    NOT?: StoryPlaySessionScalarWhereWithAggregatesInput | StoryPlaySessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryPlaySession"> | string
    storyId?: StringWithAggregatesFilter<"StoryPlaySession"> | string
    versionId?: StringNullableWithAggregatesFilter<"StoryPlaySession"> | string | null
    userId?: StringNullableWithAggregatesFilter<"StoryPlaySession"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"StoryPlaySession"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"StoryPlaySession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"StoryPlaySession"> | Date | string | null
    progress?: JsonNullableWithAggregatesFilter<"StoryPlaySession">
    rating?: IntNullableWithAggregatesFilter<"StoryPlaySession"> | number | null
    feedback?: StringNullableWithAggregatesFilter<"StoryPlaySession"> | string | null
  }

  export type StoryNodeWhereInput = {
    AND?: StoryNodeWhereInput | StoryNodeWhereInput[]
    OR?: StoryNodeWhereInput[]
    NOT?: StoryNodeWhereInput | StoryNodeWhereInput[]
    id?: StringFilter<"StoryNode"> | string
    storyId?: StringFilter<"StoryNode"> | string
    key?: StringFilter<"StoryNode"> | string
    title?: StringNullableFilter<"StoryNode"> | string | null
    synopsis?: StringNullableFilter<"StoryNode"> | string | null
    type?: EnumStoryNodeTypeFilter<"StoryNode"> | $Enums.StoryNodeType
    content?: JsonNullableFilter<"StoryNode">
    media?: JsonNullableFilter<"StoryNode">
    createdAt?: DateTimeFilter<"StoryNode"> | Date | string
    updatedAt?: DateTimeFilter<"StoryNode"> | Date | string
    story?: XOR<TwineStoryScalarRelationFilter, TwineStoryWhereInput>
    outgoing?: StoryTransitionListRelationFilter
    incoming?: StoryTransitionListRelationFilter
  }

  export type StoryNodeOrderByWithRelationInput = {
    id?: SortOrder
    storyId?: SortOrder
    key?: SortOrder
    title?: SortOrderInput | SortOrder
    synopsis?: SortOrderInput | SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    media?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    story?: TwineStoryOrderByWithRelationInput
    outgoing?: StoryTransitionOrderByRelationAggregateInput
    incoming?: StoryTransitionOrderByRelationAggregateInput
  }

  export type StoryNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storyId_key?: StoryNodeStoryIdKeyCompoundUniqueInput
    AND?: StoryNodeWhereInput | StoryNodeWhereInput[]
    OR?: StoryNodeWhereInput[]
    NOT?: StoryNodeWhereInput | StoryNodeWhereInput[]
    storyId?: StringFilter<"StoryNode"> | string
    key?: StringFilter<"StoryNode"> | string
    title?: StringNullableFilter<"StoryNode"> | string | null
    synopsis?: StringNullableFilter<"StoryNode"> | string | null
    type?: EnumStoryNodeTypeFilter<"StoryNode"> | $Enums.StoryNodeType
    content?: JsonNullableFilter<"StoryNode">
    media?: JsonNullableFilter<"StoryNode">
    createdAt?: DateTimeFilter<"StoryNode"> | Date | string
    updatedAt?: DateTimeFilter<"StoryNode"> | Date | string
    story?: XOR<TwineStoryScalarRelationFilter, TwineStoryWhereInput>
    outgoing?: StoryTransitionListRelationFilter
    incoming?: StoryTransitionListRelationFilter
  }, "id" | "storyId_key">

  export type StoryNodeOrderByWithAggregationInput = {
    id?: SortOrder
    storyId?: SortOrder
    key?: SortOrder
    title?: SortOrderInput | SortOrder
    synopsis?: SortOrderInput | SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    media?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoryNodeCountOrderByAggregateInput
    _max?: StoryNodeMaxOrderByAggregateInput
    _min?: StoryNodeMinOrderByAggregateInput
  }

  export type StoryNodeScalarWhereWithAggregatesInput = {
    AND?: StoryNodeScalarWhereWithAggregatesInput | StoryNodeScalarWhereWithAggregatesInput[]
    OR?: StoryNodeScalarWhereWithAggregatesInput[]
    NOT?: StoryNodeScalarWhereWithAggregatesInput | StoryNodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryNode"> | string
    storyId?: StringWithAggregatesFilter<"StoryNode"> | string
    key?: StringWithAggregatesFilter<"StoryNode"> | string
    title?: StringNullableWithAggregatesFilter<"StoryNode"> | string | null
    synopsis?: StringNullableWithAggregatesFilter<"StoryNode"> | string | null
    type?: EnumStoryNodeTypeWithAggregatesFilter<"StoryNode"> | $Enums.StoryNodeType
    content?: JsonNullableWithAggregatesFilter<"StoryNode">
    media?: JsonNullableWithAggregatesFilter<"StoryNode">
    createdAt?: DateTimeWithAggregatesFilter<"StoryNode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoryNode"> | Date | string
  }

  export type StoryPathWhereInput = {
    AND?: StoryPathWhereInput | StoryPathWhereInput[]
    OR?: StoryPathWhereInput[]
    NOT?: StoryPathWhereInput | StoryPathWhereInput[]
    id?: StringFilter<"StoryPath"> | string
    storyId?: StringFilter<"StoryPath"> | string
    key?: StringFilter<"StoryPath"> | string
    label?: StringFilter<"StoryPath"> | string
    summary?: StringNullableFilter<"StoryPath"> | string | null
    metadata?: JsonNullableFilter<"StoryPath">
    createdAt?: DateTimeFilter<"StoryPath"> | Date | string
    updatedAt?: DateTimeFilter<"StoryPath"> | Date | string
    story?: XOR<TwineStoryScalarRelationFilter, TwineStoryWhereInput>
    transitions?: StoryTransitionListRelationFilter
  }

  export type StoryPathOrderByWithRelationInput = {
    id?: SortOrder
    storyId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    summary?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    story?: TwineStoryOrderByWithRelationInput
    transitions?: StoryTransitionOrderByRelationAggregateInput
  }

  export type StoryPathWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storyId_key?: StoryPathStoryIdKeyCompoundUniqueInput
    AND?: StoryPathWhereInput | StoryPathWhereInput[]
    OR?: StoryPathWhereInput[]
    NOT?: StoryPathWhereInput | StoryPathWhereInput[]
    storyId?: StringFilter<"StoryPath"> | string
    key?: StringFilter<"StoryPath"> | string
    label?: StringFilter<"StoryPath"> | string
    summary?: StringNullableFilter<"StoryPath"> | string | null
    metadata?: JsonNullableFilter<"StoryPath">
    createdAt?: DateTimeFilter<"StoryPath"> | Date | string
    updatedAt?: DateTimeFilter<"StoryPath"> | Date | string
    story?: XOR<TwineStoryScalarRelationFilter, TwineStoryWhereInput>
    transitions?: StoryTransitionListRelationFilter
  }, "id" | "storyId_key">

  export type StoryPathOrderByWithAggregationInput = {
    id?: SortOrder
    storyId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    summary?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoryPathCountOrderByAggregateInput
    _max?: StoryPathMaxOrderByAggregateInput
    _min?: StoryPathMinOrderByAggregateInput
  }

  export type StoryPathScalarWhereWithAggregatesInput = {
    AND?: StoryPathScalarWhereWithAggregatesInput | StoryPathScalarWhereWithAggregatesInput[]
    OR?: StoryPathScalarWhereWithAggregatesInput[]
    NOT?: StoryPathScalarWhereWithAggregatesInput | StoryPathScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryPath"> | string
    storyId?: StringWithAggregatesFilter<"StoryPath"> | string
    key?: StringWithAggregatesFilter<"StoryPath"> | string
    label?: StringWithAggregatesFilter<"StoryPath"> | string
    summary?: StringNullableWithAggregatesFilter<"StoryPath"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"StoryPath">
    createdAt?: DateTimeWithAggregatesFilter<"StoryPath"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoryPath"> | Date | string
  }

  export type StoryTransitionWhereInput = {
    AND?: StoryTransitionWhereInput | StoryTransitionWhereInput[]
    OR?: StoryTransitionWhereInput[]
    NOT?: StoryTransitionWhereInput | StoryTransitionWhereInput[]
    id?: StringFilter<"StoryTransition"> | string
    storyId?: StringFilter<"StoryTransition"> | string
    fromNodeId?: StringFilter<"StoryTransition"> | string
    pathId?: StringFilter<"StoryTransition"> | string
    toNodeId?: StringNullableFilter<"StoryTransition"> | string | null
    ordering?: IntNullableFilter<"StoryTransition"> | number | null
    condition?: JsonNullableFilter<"StoryTransition">
    effect?: JsonNullableFilter<"StoryTransition">
    createdAt?: DateTimeFilter<"StoryTransition"> | Date | string
    updatedAt?: DateTimeFilter<"StoryTransition"> | Date | string
    story?: XOR<TwineStoryScalarRelationFilter, TwineStoryWhereInput>
    fromNode?: XOR<StoryNodeScalarRelationFilter, StoryNodeWhereInput>
    toNode?: XOR<StoryNodeNullableScalarRelationFilter, StoryNodeWhereInput> | null
    path?: XOR<StoryPathScalarRelationFilter, StoryPathWhereInput>
  }

  export type StoryTransitionOrderByWithRelationInput = {
    id?: SortOrder
    storyId?: SortOrder
    fromNodeId?: SortOrder
    pathId?: SortOrder
    toNodeId?: SortOrderInput | SortOrder
    ordering?: SortOrderInput | SortOrder
    condition?: SortOrderInput | SortOrder
    effect?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    story?: TwineStoryOrderByWithRelationInput
    fromNode?: StoryNodeOrderByWithRelationInput
    toNode?: StoryNodeOrderByWithRelationInput
    path?: StoryPathOrderByWithRelationInput
  }

  export type StoryTransitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storyId_fromNodeId_pathId_toNodeId?: StoryTransitionStoryIdFromNodeIdPathIdToNodeIdCompoundUniqueInput
    AND?: StoryTransitionWhereInput | StoryTransitionWhereInput[]
    OR?: StoryTransitionWhereInput[]
    NOT?: StoryTransitionWhereInput | StoryTransitionWhereInput[]
    storyId?: StringFilter<"StoryTransition"> | string
    fromNodeId?: StringFilter<"StoryTransition"> | string
    pathId?: StringFilter<"StoryTransition"> | string
    toNodeId?: StringNullableFilter<"StoryTransition"> | string | null
    ordering?: IntNullableFilter<"StoryTransition"> | number | null
    condition?: JsonNullableFilter<"StoryTransition">
    effect?: JsonNullableFilter<"StoryTransition">
    createdAt?: DateTimeFilter<"StoryTransition"> | Date | string
    updatedAt?: DateTimeFilter<"StoryTransition"> | Date | string
    story?: XOR<TwineStoryScalarRelationFilter, TwineStoryWhereInput>
    fromNode?: XOR<StoryNodeScalarRelationFilter, StoryNodeWhereInput>
    toNode?: XOR<StoryNodeNullableScalarRelationFilter, StoryNodeWhereInput> | null
    path?: XOR<StoryPathScalarRelationFilter, StoryPathWhereInput>
  }, "id" | "storyId_fromNodeId_pathId_toNodeId">

  export type StoryTransitionOrderByWithAggregationInput = {
    id?: SortOrder
    storyId?: SortOrder
    fromNodeId?: SortOrder
    pathId?: SortOrder
    toNodeId?: SortOrderInput | SortOrder
    ordering?: SortOrderInput | SortOrder
    condition?: SortOrderInput | SortOrder
    effect?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoryTransitionCountOrderByAggregateInput
    _avg?: StoryTransitionAvgOrderByAggregateInput
    _max?: StoryTransitionMaxOrderByAggregateInput
    _min?: StoryTransitionMinOrderByAggregateInput
    _sum?: StoryTransitionSumOrderByAggregateInput
  }

  export type StoryTransitionScalarWhereWithAggregatesInput = {
    AND?: StoryTransitionScalarWhereWithAggregatesInput | StoryTransitionScalarWhereWithAggregatesInput[]
    OR?: StoryTransitionScalarWhereWithAggregatesInput[]
    NOT?: StoryTransitionScalarWhereWithAggregatesInput | StoryTransitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryTransition"> | string
    storyId?: StringWithAggregatesFilter<"StoryTransition"> | string
    fromNodeId?: StringWithAggregatesFilter<"StoryTransition"> | string
    pathId?: StringWithAggregatesFilter<"StoryTransition"> | string
    toNodeId?: StringNullableWithAggregatesFilter<"StoryTransition"> | string | null
    ordering?: IntNullableWithAggregatesFilter<"StoryTransition"> | number | null
    condition?: JsonNullableWithAggregatesFilter<"StoryTransition">
    effect?: JsonNullableWithAggregatesFilter<"StoryTransition">
    createdAt?: DateTimeWithAggregatesFilter<"StoryTransition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoryTransition"> | Date | string
  }

  export type AvatarProfileWhereInput = {
    AND?: AvatarProfileWhereInput | AvatarProfileWhereInput[]
    OR?: AvatarProfileWhereInput[]
    NOT?: AvatarProfileWhereInput | AvatarProfileWhereInput[]
    id?: StringFilter<"AvatarProfile"> | string
    name?: StringFilter<"AvatarProfile"> | string
    age?: IntNullableFilter<"AvatarProfile"> | number | null
    background?: StringNullableFilter<"AvatarProfile"> | string | null
    appearance?: JsonNullableFilter<"AvatarProfile">
    initialResources?: JsonFilter<"AvatarProfile">
    socialContext?: JsonNullableFilter<"AvatarProfile">
    isPlayable?: BoolFilter<"AvatarProfile"> | boolean
    storyId?: StringNullableFilter<"AvatarProfile"> | string | null
    experienceClicks?: IntFilter<"AvatarProfile"> | number
    experienceStarts?: IntFilter<"AvatarProfile"> | number
    createdAt?: DateTimeFilter<"AvatarProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AvatarProfile"> | Date | string
    story?: XOR<TwineStoryNullableScalarRelationFilter, TwineStoryWhereInput> | null
    interactions?: StoryInteractionListRelationFilter
  }

  export type AvatarProfileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrderInput | SortOrder
    background?: SortOrderInput | SortOrder
    appearance?: SortOrderInput | SortOrder
    initialResources?: SortOrder
    socialContext?: SortOrderInput | SortOrder
    isPlayable?: SortOrder
    storyId?: SortOrderInput | SortOrder
    experienceClicks?: SortOrder
    experienceStarts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    story?: TwineStoryOrderByWithRelationInput
    interactions?: StoryInteractionOrderByRelationAggregateInput
  }

  export type AvatarProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AvatarProfileWhereInput | AvatarProfileWhereInput[]
    OR?: AvatarProfileWhereInput[]
    NOT?: AvatarProfileWhereInput | AvatarProfileWhereInput[]
    name?: StringFilter<"AvatarProfile"> | string
    age?: IntNullableFilter<"AvatarProfile"> | number | null
    background?: StringNullableFilter<"AvatarProfile"> | string | null
    appearance?: JsonNullableFilter<"AvatarProfile">
    initialResources?: JsonFilter<"AvatarProfile">
    socialContext?: JsonNullableFilter<"AvatarProfile">
    isPlayable?: BoolFilter<"AvatarProfile"> | boolean
    storyId?: StringNullableFilter<"AvatarProfile"> | string | null
    experienceClicks?: IntFilter<"AvatarProfile"> | number
    experienceStarts?: IntFilter<"AvatarProfile"> | number
    createdAt?: DateTimeFilter<"AvatarProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AvatarProfile"> | Date | string
    story?: XOR<TwineStoryNullableScalarRelationFilter, TwineStoryWhereInput> | null
    interactions?: StoryInteractionListRelationFilter
  }, "id">

  export type AvatarProfileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrderInput | SortOrder
    background?: SortOrderInput | SortOrder
    appearance?: SortOrderInput | SortOrder
    initialResources?: SortOrder
    socialContext?: SortOrderInput | SortOrder
    isPlayable?: SortOrder
    storyId?: SortOrderInput | SortOrder
    experienceClicks?: SortOrder
    experienceStarts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AvatarProfileCountOrderByAggregateInput
    _avg?: AvatarProfileAvgOrderByAggregateInput
    _max?: AvatarProfileMaxOrderByAggregateInput
    _min?: AvatarProfileMinOrderByAggregateInput
    _sum?: AvatarProfileSumOrderByAggregateInput
  }

  export type AvatarProfileScalarWhereWithAggregatesInput = {
    AND?: AvatarProfileScalarWhereWithAggregatesInput | AvatarProfileScalarWhereWithAggregatesInput[]
    OR?: AvatarProfileScalarWhereWithAggregatesInput[]
    NOT?: AvatarProfileScalarWhereWithAggregatesInput | AvatarProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AvatarProfile"> | string
    name?: StringWithAggregatesFilter<"AvatarProfile"> | string
    age?: IntNullableWithAggregatesFilter<"AvatarProfile"> | number | null
    background?: StringNullableWithAggregatesFilter<"AvatarProfile"> | string | null
    appearance?: JsonNullableWithAggregatesFilter<"AvatarProfile">
    initialResources?: JsonWithAggregatesFilter<"AvatarProfile">
    socialContext?: JsonNullableWithAggregatesFilter<"AvatarProfile">
    isPlayable?: BoolWithAggregatesFilter<"AvatarProfile"> | boolean
    storyId?: StringNullableWithAggregatesFilter<"AvatarProfile"> | string | null
    experienceClicks?: IntWithAggregatesFilter<"AvatarProfile"> | number
    experienceStarts?: IntWithAggregatesFilter<"AvatarProfile"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AvatarProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AvatarProfile"> | Date | string
  }

  export type StoryInteractionWhereInput = {
    AND?: StoryInteractionWhereInput | StoryInteractionWhereInput[]
    OR?: StoryInteractionWhereInput[]
    NOT?: StoryInteractionWhereInput | StoryInteractionWhereInput[]
    id?: StringFilter<"StoryInteraction"> | string
    avatarId?: StringFilter<"StoryInteraction"> | string
    storyId?: StringNullableFilter<"StoryInteraction"> | string | null
    sessionId?: StringNullableFilter<"StoryInteraction"> | string | null
    userId?: StringNullableFilter<"StoryInteraction"> | string | null
    kind?: EnumStoryInteractionKindFilter<"StoryInteraction"> | $Enums.StoryInteractionKind
    metadata?: JsonNullableFilter<"StoryInteraction">
    createdAt?: DateTimeFilter<"StoryInteraction"> | Date | string
    avatar?: XOR<AvatarProfileScalarRelationFilter, AvatarProfileWhereInput>
    story?: XOR<TwineStoryNullableScalarRelationFilter, TwineStoryWhereInput> | null
    session?: XOR<UserSessionNullableScalarRelationFilter, UserSessionWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type StoryInteractionOrderByWithRelationInput = {
    id?: SortOrder
    avatarId?: SortOrder
    storyId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    kind?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    avatar?: AvatarProfileOrderByWithRelationInput
    story?: TwineStoryOrderByWithRelationInput
    session?: UserSessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StoryInteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryInteractionWhereInput | StoryInteractionWhereInput[]
    OR?: StoryInteractionWhereInput[]
    NOT?: StoryInteractionWhereInput | StoryInteractionWhereInput[]
    avatarId?: StringFilter<"StoryInteraction"> | string
    storyId?: StringNullableFilter<"StoryInteraction"> | string | null
    sessionId?: StringNullableFilter<"StoryInteraction"> | string | null
    userId?: StringNullableFilter<"StoryInteraction"> | string | null
    kind?: EnumStoryInteractionKindFilter<"StoryInteraction"> | $Enums.StoryInteractionKind
    metadata?: JsonNullableFilter<"StoryInteraction">
    createdAt?: DateTimeFilter<"StoryInteraction"> | Date | string
    avatar?: XOR<AvatarProfileScalarRelationFilter, AvatarProfileWhereInput>
    story?: XOR<TwineStoryNullableScalarRelationFilter, TwineStoryWhereInput> | null
    session?: XOR<UserSessionNullableScalarRelationFilter, UserSessionWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type StoryInteractionOrderByWithAggregationInput = {
    id?: SortOrder
    avatarId?: SortOrder
    storyId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    kind?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StoryInteractionCountOrderByAggregateInput
    _max?: StoryInteractionMaxOrderByAggregateInput
    _min?: StoryInteractionMinOrderByAggregateInput
  }

  export type StoryInteractionScalarWhereWithAggregatesInput = {
    AND?: StoryInteractionScalarWhereWithAggregatesInput | StoryInteractionScalarWhereWithAggregatesInput[]
    OR?: StoryInteractionScalarWhereWithAggregatesInput[]
    NOT?: StoryInteractionScalarWhereWithAggregatesInput | StoryInteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryInteraction"> | string
    avatarId?: StringWithAggregatesFilter<"StoryInteraction"> | string
    storyId?: StringNullableWithAggregatesFilter<"StoryInteraction"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"StoryInteraction"> | string | null
    userId?: StringNullableWithAggregatesFilter<"StoryInteraction"> | string | null
    kind?: EnumStoryInteractionKindWithAggregatesFilter<"StoryInteraction"> | $Enums.StoryInteractionKind
    metadata?: JsonNullableWithAggregatesFilter<"StoryInteraction">
    createdAt?: DateTimeWithAggregatesFilter<"StoryInteraction"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserProfileCreateInput = {
    id?: string
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    timezone?: string | null
    pronouns?: string | null
    location?: string | null
    publicEmail?: string | null
    websiteUrl?: string | null
    linkedinUrl?: string | null
    twitterHandle?: string | null
    instagramHandle?: string | null
    tiktokHandle?: string | null
    expertiseTags?: UserProfileCreateexpertiseTagsInput | string[]
    customLinks?: NullableJsonNullValueInput | InputJsonValue
    consentAcceptedAt?: Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    timezone?: string | null
    pronouns?: string | null
    location?: string | null
    publicEmail?: string | null
    websiteUrl?: string | null
    linkedinUrl?: string | null
    twitterHandle?: string | null
    instagramHandle?: string | null
    tiktokHandle?: string | null
    expertiseTags?: UserProfileCreateexpertiseTagsInput | string[]
    customLinks?: NullableJsonNullValueInput | InputJsonValue
    consentAcceptedAt?: Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    publicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    instagramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokHandle?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: UserProfileUpdateexpertiseTagsInput | string[]
    customLinks?: NullableJsonNullValueInput | InputJsonValue
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    publicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    instagramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokHandle?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: UserProfileUpdateexpertiseTagsInput | string[]
    customLinks?: NullableJsonNullValueInput | InputJsonValue
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateManyInput = {
    id?: string
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    timezone?: string | null
    pronouns?: string | null
    location?: string | null
    publicEmail?: string | null
    websiteUrl?: string | null
    linkedinUrl?: string | null
    twitterHandle?: string | null
    instagramHandle?: string | null
    tiktokHandle?: string | null
    expertiseTags?: UserProfileCreateexpertiseTagsInput | string[]
    customLinks?: NullableJsonNullValueInput | InputJsonValue
    consentAcceptedAt?: Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    publicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    instagramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokHandle?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: UserProfileUpdateexpertiseTagsInput | string[]
    customLinks?: NullableJsonNullValueInput | InputJsonValue
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    publicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    instagramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokHandle?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: UserProfileUpdateexpertiseTagsInput | string[]
    customLinks?: NullableJsonNullValueInput | InputJsonValue
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorProfileCreateInput = {
    id?: string
    penName?: string | null
    headline?: string | null
    expertiseTags?: CreatorProfileCreateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileCreatefocusAreasInput | string[]
    languages?: CreatorProfileCreatelanguagesInput | string[]
    tagline?: string | null
    biography?: string | null
    websiteUrl?: string | null
    portfolioUrl?: string | null
    contactEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: Date | string | null
    termsAcceptedAt?: Date | string | null
    consentAcceptedAt?: Date | string | null
    consentStatement?: string | null
    status?: $Enums.CreatorProfileStatus
    completedAt?: Date | string | null
    lastReviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCreatorProfileInput
    lastReviewer?: UserCreateNestedOneWithoutReviewedCreatorProfilesInput
    storiesSubmitted?: TwineStoryCreateNestedManyWithoutOriginalCreatorProfileInput
  }

  export type CreatorProfileUncheckedCreateInput = {
    id?: string
    userId: string
    penName?: string | null
    headline?: string | null
    expertiseTags?: CreatorProfileCreateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileCreatefocusAreasInput | string[]
    languages?: CreatorProfileCreatelanguagesInput | string[]
    tagline?: string | null
    biography?: string | null
    websiteUrl?: string | null
    portfolioUrl?: string | null
    contactEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: Date | string | null
    termsAcceptedAt?: Date | string | null
    consentAcceptedAt?: Date | string | null
    consentStatement?: string | null
    status?: $Enums.CreatorProfileStatus
    completedAt?: Date | string | null
    lastReviewedAt?: Date | string | null
    lastReviewerId?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    storiesSubmitted?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorProfileInput
  }

  export type CreatorProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    penName?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: CreatorProfileUpdateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileUpdatefocusAreasInput | string[]
    languages?: CreatorProfileUpdatelanguagesInput | string[]
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentStatement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCreatorProfileStatusFieldUpdateOperationsInput | $Enums.CreatorProfileStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCreatorProfileNestedInput
    lastReviewer?: UserUpdateOneWithoutReviewedCreatorProfilesNestedInput
    storiesSubmitted?: TwineStoryUpdateManyWithoutOriginalCreatorProfileNestedInput
  }

  export type CreatorProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    penName?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: CreatorProfileUpdateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileUpdatefocusAreasInput | string[]
    languages?: CreatorProfileUpdatelanguagesInput | string[]
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentStatement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCreatorProfileStatusFieldUpdateOperationsInput | $Enums.CreatorProfileStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storiesSubmitted?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorProfileNestedInput
  }

  export type CreatorProfileCreateManyInput = {
    id?: string
    userId: string
    penName?: string | null
    headline?: string | null
    expertiseTags?: CreatorProfileCreateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileCreatefocusAreasInput | string[]
    languages?: CreatorProfileCreatelanguagesInput | string[]
    tagline?: string | null
    biography?: string | null
    websiteUrl?: string | null
    portfolioUrl?: string | null
    contactEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: Date | string | null
    termsAcceptedAt?: Date | string | null
    consentAcceptedAt?: Date | string | null
    consentStatement?: string | null
    status?: $Enums.CreatorProfileStatus
    completedAt?: Date | string | null
    lastReviewedAt?: Date | string | null
    lastReviewerId?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreatorProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    penName?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: CreatorProfileUpdateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileUpdatefocusAreasInput | string[]
    languages?: CreatorProfileUpdatelanguagesInput | string[]
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentStatement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCreatorProfileStatusFieldUpdateOperationsInput | $Enums.CreatorProfileStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    penName?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: CreatorProfileUpdateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileUpdatefocusAreasInput | string[]
    languages?: CreatorProfileUpdatelanguagesInput | string[]
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentStatement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCreatorProfileStatusFieldUpdateOperationsInput | $Enums.CreatorProfileStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSessionsInput
    journeys?: JourneyProgressCreateNestedManyWithoutSessionInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutSessionInput
    achievements?: UserAchievementCreateNestedManyWithoutSessionInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutSessionInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    userId?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutSessionInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutSessionInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutSessionInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSessionsNestedInput
    journeys?: JourneyProgressUpdateManyWithoutSessionNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutSessionNestedInput
    achievements?: UserAchievementUpdateManyWithoutSessionNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutSessionNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journeys?: JourneyProgressUncheckedUpdateManyWithoutSessionNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutSessionNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutSessionNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserSessionCreateManyInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    userId?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioCreateInput = {
    id: string
    title: string
    summary?: string | null
    issueTag?: string | null
    difficulty?: string | null
    estimatedMinutes?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    journeys?: JourneyProgressCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUncheckedCreateInput = {
    id: string
    title: string
    summary?: string | null
    issueTag?: string | null
    difficulty?: string | null
    estimatedMinutes?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    issueTag?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journeys?: JourneyProgressUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    issueTag?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journeys?: JourneyProgressUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioCreateManyInput = {
    id: string
    title: string
    summary?: string | null
    issueTag?: string | null
    difficulty?: string | null
    estimatedMinutes?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    issueTag?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    issueTag?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JourneyProgressCreateInput = {
    id?: string
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    scenario: ScenarioCreateNestedOneWithoutJourneysInput
    user?: UserCreateNestedOneWithoutJourneysInput
    session?: UserSessionCreateNestedOneWithoutJourneysInput
    achievements?: UserAchievementCreateNestedManyWithoutJourneyInput
  }

  export type JourneyProgressUncheckedCreateInput = {
    id?: string
    scenarioId: string
    userId?: string | null
    sessionId?: string | null
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutJourneyInput
  }

  export type JourneyProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scenario?: ScenarioUpdateOneRequiredWithoutJourneysNestedInput
    user?: UserUpdateOneWithoutJourneysNestedInput
    session?: UserSessionUpdateOneWithoutJourneysNestedInput
    achievements?: UserAchievementUpdateManyWithoutJourneyNestedInput
  }

  export type JourneyProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievements?: UserAchievementUncheckedUpdateManyWithoutJourneyNestedInput
  }

  export type JourneyProgressCreateManyInput = {
    id?: string
    scenarioId: string
    userId?: string | null
    sessionId?: string | null
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type JourneyProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JourneyProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AchievementCreateInput = {
    id?: string
    code: string
    title: string
    description: string
    points?: number
    icon?: string | null
    unlockHint?: string | null
    unlockLogic?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userAwards?: UserAchievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    code: string
    title: string
    description: string
    points?: number
    icon?: string | null
    unlockHint?: string | null
    unlockLogic?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userAwards?: UserAchievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockHint?: NullableStringFieldUpdateOperationsInput | string | null
    unlockLogic?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAwards?: UserAchievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockHint?: NullableStringFieldUpdateOperationsInput | string | null
    unlockLogic?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAwards?: UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    code: string
    title: string
    description: string
    points?: number
    icon?: string | null
    unlockHint?: string | null
    unlockLogic?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockHint?: NullableStringFieldUpdateOperationsInput | string | null
    unlockLogic?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockHint?: NullableStringFieldUpdateOperationsInput | string | null
    unlockLogic?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateInput = {
    id?: string
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    achievement: AchievementCreateNestedOneWithoutUserAwardsInput
    user?: UserCreateNestedOneWithoutAchievementsInput
    session?: UserSessionCreateNestedOneWithoutAchievementsInput
    journey?: JourneyProgressCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    achievementId: string
    userId?: string | null
    sessionId?: string | null
    journeyId?: string | null
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    achievement?: AchievementUpdateOneRequiredWithoutUserAwardsNestedInput
    user?: UserUpdateOneWithoutAchievementsNestedInput
    session?: UserSessionUpdateOneWithoutAchievementsNestedInput
    journey?: JourneyProgressUpdateOneWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    journeyId?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    achievementId: string
    userId?: string | null
    sessionId?: string | null
    journeyId?: string | null
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    journeyId?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TwineStoryCreateInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryCreateManyInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwineStoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwineStoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryVersionCreateInput = {
    id?: string
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    story: TwineStoryCreateNestedOneWithoutVersionsInput
    featuredIn?: TwineStoryCreateNestedOneWithoutLatestVersionInput
    author?: UserCreateNestedOneWithoutAuthoredVersionsInput
    reviewer?: UserCreateNestedOneWithoutReviewedVersionsInput
    reviews?: StoryReviewCreateNestedManyWithoutVersionInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionUncheckedCreateInput = {
    id?: string
    storyId: string
    authorId?: string | null
    reviewerId?: string | null
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    featuredIn?: TwineStoryUncheckedCreateNestedOneWithoutLatestVersionInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutVersionInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    story?: TwineStoryUpdateOneRequiredWithoutVersionsNestedInput
    featuredIn?: TwineStoryUpdateOneWithoutLatestVersionNestedInput
    author?: UserUpdateOneWithoutAuthoredVersionsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedVersionsNestedInput
    reviews?: StoryReviewUpdateManyWithoutVersionNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutVersionNestedInput
  }

  export type StoryVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featuredIn?: TwineStoryUncheckedUpdateOneWithoutLatestVersionNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutVersionNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type StoryVersionCreateManyInput = {
    id?: string
    storyId: string
    authorId?: string | null
    reviewerId?: string | null
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StoryVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StoryVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StoryAuditLogCreateInput = {
    id?: string
    action: string
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    story: TwineStoryCreateNestedOneWithoutAuditLogsInput
    actor?: UserCreateNestedOneWithoutStoryAuditLogsInput
  }

  export type StoryAuditLogUncheckedCreateInput = {
    id?: string
    storyId: string
    actorId?: string | null
    action: string
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneRequiredWithoutAuditLogsNestedInput
    actor?: UserUpdateOneWithoutStoryAuditLogsNestedInput
  }

  export type StoryAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryAuditLogCreateManyInput = {
    id?: string
    storyId: string
    actorId?: string | null
    action: string
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryReviewCreateInput = {
    id?: string
    status: $Enums.StoryStatus
    feedback?: string | null
    createdAt?: Date | string
    version: StoryVersionCreateNestedOneWithoutReviewsInput
    reviewer: UserCreateNestedOneWithoutReviewsInput
  }

  export type StoryReviewUncheckedCreateInput = {
    id?: string
    versionId: string
    reviewerId: string
    status: $Enums.StoryStatus
    feedback?: string | null
    createdAt?: Date | string
  }

  export type StoryReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StoryVersionUpdateOneRequiredWithoutReviewsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type StoryReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryReviewCreateManyInput = {
    id?: string
    versionId: string
    reviewerId: string
    status: $Enums.StoryStatus
    feedback?: string | null
    createdAt?: Date | string
  }

  export type StoryReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryPlaySessionCreateInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
    story: TwineStoryCreateNestedOneWithoutPlaySessionsInput
    version?: StoryVersionCreateNestedOneWithoutPlaySessionsInput
    user?: UserCreateNestedOneWithoutStoryPlaysInput
    session?: UserSessionCreateNestedOneWithoutStoryPlaysInput
  }

  export type StoryPlaySessionUncheckedCreateInput = {
    id?: string
    storyId: string
    versionId?: string | null
    userId?: string | null
    sessionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
  }

  export type StoryPlaySessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    story?: TwineStoryUpdateOneRequiredWithoutPlaySessionsNestedInput
    version?: StoryVersionUpdateOneWithoutPlaySessionsNestedInput
    user?: UserUpdateOneWithoutStoryPlaysNestedInput
    session?: UserSessionUpdateOneWithoutStoryPlaysNestedInput
  }

  export type StoryPlaySessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoryPlaySessionCreateManyInput = {
    id?: string
    storyId: string
    versionId?: string | null
    userId?: string | null
    sessionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
  }

  export type StoryPlaySessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoryPlaySessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoryNodeCreateInput = {
    id?: string
    key: string
    title?: string | null
    synopsis?: string | null
    type?: $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    story: TwineStoryCreateNestedOneWithoutNodesInput
    outgoing?: StoryTransitionCreateNestedManyWithoutFromNodeInput
    incoming?: StoryTransitionCreateNestedManyWithoutToNodeInput
  }

  export type StoryNodeUncheckedCreateInput = {
    id?: string
    storyId: string
    key: string
    title?: string | null
    synopsis?: string | null
    type?: $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    outgoing?: StoryTransitionUncheckedCreateNestedManyWithoutFromNodeInput
    incoming?: StoryTransitionUncheckedCreateNestedManyWithoutToNodeInput
  }

  export type StoryNodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStoryNodeTypeFieldUpdateOperationsInput | $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneRequiredWithoutNodesNestedInput
    outgoing?: StoryTransitionUpdateManyWithoutFromNodeNestedInput
    incoming?: StoryTransitionUpdateManyWithoutToNodeNestedInput
  }

  export type StoryNodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStoryNodeTypeFieldUpdateOperationsInput | $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outgoing?: StoryTransitionUncheckedUpdateManyWithoutFromNodeNestedInput
    incoming?: StoryTransitionUncheckedUpdateManyWithoutToNodeNestedInput
  }

  export type StoryNodeCreateManyInput = {
    id?: string
    storyId: string
    key: string
    title?: string | null
    synopsis?: string | null
    type?: $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryNodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStoryNodeTypeFieldUpdateOperationsInput | $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryNodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStoryNodeTypeFieldUpdateOperationsInput | $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryPathCreateInput = {
    id?: string
    key: string
    label: string
    summary?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    story: TwineStoryCreateNestedOneWithoutPathsInput
    transitions?: StoryTransitionCreateNestedManyWithoutPathInput
  }

  export type StoryPathUncheckedCreateInput = {
    id?: string
    storyId: string
    key: string
    label: string
    summary?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutPathInput
  }

  export type StoryPathUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneRequiredWithoutPathsNestedInput
    transitions?: StoryTransitionUpdateManyWithoutPathNestedInput
  }

  export type StoryPathUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transitions?: StoryTransitionUncheckedUpdateManyWithoutPathNestedInput
  }

  export type StoryPathCreateManyInput = {
    id?: string
    storyId: string
    key: string
    label: string
    summary?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryPathUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryPathUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryTransitionCreateInput = {
    id?: string
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    story: TwineStoryCreateNestedOneWithoutTransitionsInput
    fromNode: StoryNodeCreateNestedOneWithoutOutgoingInput
    toNode?: StoryNodeCreateNestedOneWithoutIncomingInput
    path: StoryPathCreateNestedOneWithoutTransitionsInput
  }

  export type StoryTransitionUncheckedCreateInput = {
    id?: string
    storyId: string
    fromNodeId: string
    pathId: string
    toNodeId?: string | null
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryTransitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneRequiredWithoutTransitionsNestedInput
    fromNode?: StoryNodeUpdateOneRequiredWithoutOutgoingNestedInput
    toNode?: StoryNodeUpdateOneWithoutIncomingNestedInput
    path?: StoryPathUpdateOneRequiredWithoutTransitionsNestedInput
  }

  export type StoryTransitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    pathId?: StringFieldUpdateOperationsInput | string
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryTransitionCreateManyInput = {
    id?: string
    storyId: string
    fromNodeId: string
    pathId: string
    toNodeId?: string | null
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryTransitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryTransitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    pathId?: StringFieldUpdateOperationsInput | string
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarProfileCreateInput = {
    id: string
    name: string
    age?: number | null
    background?: string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: boolean
    experienceClicks?: number
    experienceStarts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    story?: TwineStoryCreateNestedOneWithoutAvatarsInput
    interactions?: StoryInteractionCreateNestedManyWithoutAvatarInput
  }

  export type AvatarProfileUncheckedCreateInput = {
    id: string
    name: string
    age?: number | null
    background?: string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: boolean
    storyId?: string | null
    experienceClicks?: number
    experienceStarts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutAvatarInput
  }

  export type AvatarProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources?: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    experienceClicks?: IntFieldUpdateOperationsInput | number
    experienceStarts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneWithoutAvatarsNestedInput
    interactions?: StoryInteractionUpdateManyWithoutAvatarNestedInput
  }

  export type AvatarProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources?: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    experienceClicks?: IntFieldUpdateOperationsInput | number
    experienceStarts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: StoryInteractionUncheckedUpdateManyWithoutAvatarNestedInput
  }

  export type AvatarProfileCreateManyInput = {
    id: string
    name: string
    age?: number | null
    background?: string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: boolean
    storyId?: string | null
    experienceClicks?: number
    experienceStarts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvatarProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources?: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    experienceClicks?: IntFieldUpdateOperationsInput | number
    experienceStarts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources?: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    experienceClicks?: IntFieldUpdateOperationsInput | number
    experienceStarts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryInteractionCreateInput = {
    id?: string
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    avatar: AvatarProfileCreateNestedOneWithoutInteractionsInput
    story?: TwineStoryCreateNestedOneWithoutInteractionsInput
    session?: UserSessionCreateNestedOneWithoutStoryInteractionsInput
    user?: UserCreateNestedOneWithoutStoryInteractionsInput
  }

  export type StoryInteractionUncheckedCreateInput = {
    id?: string
    avatarId: string
    storyId?: string | null
    sessionId?: string | null
    userId?: string | null
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryInteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: AvatarProfileUpdateOneRequiredWithoutInteractionsNestedInput
    story?: TwineStoryUpdateOneWithoutInteractionsNestedInput
    session?: UserSessionUpdateOneWithoutStoryInteractionsNestedInput
    user?: UserUpdateOneWithoutStoryInteractionsNestedInput
  }

  export type StoryInteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: StringFieldUpdateOperationsInput | string
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryInteractionCreateManyInput = {
    id?: string
    avatarId: string
    storyId?: string | null
    sessionId?: string | null
    userId?: string | null
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryInteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryInteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: StringFieldUpdateOperationsInput | string
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserProfileNullableScalarRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type JourneyProgressListRelationFilter = {
    every?: JourneyProgressWhereInput
    some?: JourneyProgressWhereInput
    none?: JourneyProgressWhereInput
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type StoryPlaySessionListRelationFilter = {
    every?: StoryPlaySessionWhereInput
    some?: StoryPlaySessionWhereInput
    none?: StoryPlaySessionWhereInput
  }

  export type TwineStoryListRelationFilter = {
    every?: TwineStoryWhereInput
    some?: TwineStoryWhereInput
    none?: TwineStoryWhereInput
  }

  export type StoryVersionListRelationFilter = {
    every?: StoryVersionWhereInput
    some?: StoryVersionWhereInput
    none?: StoryVersionWhereInput
  }

  export type StoryReviewListRelationFilter = {
    every?: StoryReviewWhereInput
    some?: StoryReviewWhereInput
    none?: StoryReviewWhereInput
  }

  export type CreatorProfileNullableScalarRelationFilter = {
    is?: CreatorProfileWhereInput | null
    isNot?: CreatorProfileWhereInput | null
  }

  export type CreatorProfileListRelationFilter = {
    every?: CreatorProfileWhereInput
    some?: CreatorProfileWhereInput
    none?: CreatorProfileWhereInput
  }

  export type StoryAuditLogListRelationFilter = {
    every?: StoryAuditLogWhereInput
    some?: StoryAuditLogWhereInput
    none?: StoryAuditLogWhereInput
  }

  export type StoryInteractionListRelationFilter = {
    every?: StoryInteractionWhereInput
    some?: StoryInteractionWhereInput
    none?: StoryInteractionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JourneyProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryPlaySessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwineStoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatorProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    role?: SortOrder
    onboardedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAdmin?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    role?: SortOrder
    onboardedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAdmin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    role?: SortOrder
    onboardedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAdmin?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    timezone?: SortOrder
    pronouns?: SortOrder
    location?: SortOrder
    publicEmail?: SortOrder
    websiteUrl?: SortOrder
    linkedinUrl?: SortOrder
    twitterHandle?: SortOrder
    instagramHandle?: SortOrder
    tiktokHandle?: SortOrder
    expertiseTags?: SortOrder
    customLinks?: SortOrder
    consentAcceptedAt?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    timezone?: SortOrder
    pronouns?: SortOrder
    location?: SortOrder
    publicEmail?: SortOrder
    websiteUrl?: SortOrder
    linkedinUrl?: SortOrder
    twitterHandle?: SortOrder
    instagramHandle?: SortOrder
    tiktokHandle?: SortOrder
    consentAcceptedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    timezone?: SortOrder
    pronouns?: SortOrder
    location?: SortOrder
    publicEmail?: SortOrder
    websiteUrl?: SortOrder
    linkedinUrl?: SortOrder
    twitterHandle?: SortOrder
    instagramHandle?: SortOrder
    tiktokHandle?: SortOrder
    consentAcceptedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumCreatorProfileStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatorProfileStatus | EnumCreatorProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreatorProfileStatus[] | ListEnumCreatorProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatorProfileStatus[] | ListEnumCreatorProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatorProfileStatusFilter<$PrismaModel> | $Enums.CreatorProfileStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CreatorProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    penName?: SortOrder
    headline?: SortOrder
    expertiseTags?: SortOrder
    focusAreas?: SortOrder
    languages?: SortOrder
    tagline?: SortOrder
    biography?: SortOrder
    websiteUrl?: SortOrder
    portfolioUrl?: SortOrder
    contactEmail?: SortOrder
    socialLinks?: SortOrder
    payoutDetails?: SortOrder
    guidelinesAcceptedAt?: SortOrder
    termsAcceptedAt?: SortOrder
    consentAcceptedAt?: SortOrder
    consentStatement?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    lastReviewedAt?: SortOrder
    lastReviewerId?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreatorProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    penName?: SortOrder
    headline?: SortOrder
    tagline?: SortOrder
    biography?: SortOrder
    websiteUrl?: SortOrder
    portfolioUrl?: SortOrder
    contactEmail?: SortOrder
    guidelinesAcceptedAt?: SortOrder
    termsAcceptedAt?: SortOrder
    consentAcceptedAt?: SortOrder
    consentStatement?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    lastReviewedAt?: SortOrder
    lastReviewerId?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreatorProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    penName?: SortOrder
    headline?: SortOrder
    tagline?: SortOrder
    biography?: SortOrder
    websiteUrl?: SortOrder
    portfolioUrl?: SortOrder
    contactEmail?: SortOrder
    guidelinesAcceptedAt?: SortOrder
    termsAcceptedAt?: SortOrder
    consentAcceptedAt?: SortOrder
    consentStatement?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    lastReviewedAt?: SortOrder
    lastReviewerId?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCreatorProfileStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatorProfileStatus | EnumCreatorProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreatorProfileStatus[] | ListEnumCreatorProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatorProfileStatus[] | ListEnumCreatorProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatorProfileStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreatorProfileStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreatorProfileStatusFilter<$PrismaModel>
    _max?: NestedEnumCreatorProfileStatusFilter<$PrismaModel>
  }

  export type EnumSessionKindFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionKind | EnumSessionKindFieldRefInput<$PrismaModel>
    in?: $Enums.SessionKind[] | ListEnumSessionKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionKind[] | ListEnumSessionKindFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionKindFilter<$PrismaModel> | $Enums.SessionKind
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    kind?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    kind?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    kind?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSessionKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionKind | EnumSessionKindFieldRefInput<$PrismaModel>
    in?: $Enums.SessionKind[] | ListEnumSessionKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionKind[] | ListEnumSessionKindFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionKindWithAggregatesFilter<$PrismaModel> | $Enums.SessionKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionKindFilter<$PrismaModel>
    _max?: NestedEnumSessionKindFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ScenarioCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    issueTag?: SortOrder
    difficulty?: SortOrder
    estimatedMinutes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioAvgOrderByAggregateInput = {
    estimatedMinutes?: SortOrder
  }

  export type ScenarioMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    issueTag?: SortOrder
    difficulty?: SortOrder
    estimatedMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    issueTag?: SortOrder
    difficulty?: SortOrder
    estimatedMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioSumOrderByAggregateInput = {
    estimatedMinutes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumJourneyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JourneyStatus | EnumJourneyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJourneyStatusFilter<$PrismaModel> | $Enums.JourneyStatus
  }

  export type ScenarioScalarRelationFilter = {
    is?: ScenarioWhereInput
    isNot?: ScenarioWhereInput
  }

  export type UserSessionNullableScalarRelationFilter = {
    is?: UserSessionWhereInput | null
    isNot?: UserSessionWhereInput | null
  }

  export type JourneyProgressUserIdScenarioIdCompoundUniqueInput = {
    userId: string
    scenarioId: string
  }

  export type JourneyProgressCountOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    status?: SortOrder
    currentNode?: SortOrder
    checkpoints?: SortOrder
    resources?: SortOrder
    notes?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type JourneyProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    status?: SortOrder
    currentNode?: SortOrder
    notes?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type JourneyProgressMinOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    status?: SortOrder
    currentNode?: SortOrder
    notes?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EnumJourneyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JourneyStatus | EnumJourneyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJourneyStatusWithAggregatesFilter<$PrismaModel> | $Enums.JourneyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJourneyStatusFilter<$PrismaModel>
    _max?: NestedEnumJourneyStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    icon?: SortOrder
    unlockHint?: SortOrder
    unlockLogic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    icon?: SortOrder
    unlockHint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    icon?: SortOrder
    unlockHint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AchievementScalarRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type JourneyProgressNullableScalarRelationFilter = {
    is?: JourneyProgressWhereInput | null
    isNot?: JourneyProgressWhereInput | null
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    achievementId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    journeyId?: SortOrder
    unlockedAt?: SortOrder
    metadata?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    achievementId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    journeyId?: SortOrder
    unlockedAt?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    achievementId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    journeyId?: SortOrder
    unlockedAt?: SortOrder
  }

  export type EnumStoryVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryVisibility | EnumStoryVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.StoryVisibility[] | ListEnumStoryVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryVisibility[] | ListEnumStoryVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryVisibilityFilter<$PrismaModel> | $Enums.StoryVisibility
  }

  export type EnumStoryOwnershipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryOwnershipStatus | EnumStoryOwnershipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoryOwnershipStatus[] | ListEnumStoryOwnershipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryOwnershipStatus[] | ListEnumStoryOwnershipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryOwnershipStatusFilter<$PrismaModel> | $Enums.StoryOwnershipStatus
  }

  export type StoryVersionNullableScalarRelationFilter = {
    is?: StoryVersionWhereInput | null
    isNot?: StoryVersionWhereInput | null
  }

  export type StoryNodeListRelationFilter = {
    every?: StoryNodeWhereInput
    some?: StoryNodeWhereInput
    none?: StoryNodeWhereInput
  }

  export type StoryPathListRelationFilter = {
    every?: StoryPathWhereInput
    some?: StoryPathWhereInput
    none?: StoryPathWhereInput
  }

  export type StoryTransitionListRelationFilter = {
    every?: StoryTransitionWhereInput
    some?: StoryTransitionWhereInput
    none?: StoryTransitionWhereInput
  }

  export type AvatarProfileListRelationFilter = {
    every?: AvatarProfileWhereInput
    some?: AvatarProfileWhereInput
    none?: AvatarProfileWhereInput
  }

  export type StoryNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryPathOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryTransitionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AvatarProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwineStoryCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    tags?: SortOrder
    visibility?: SortOrder
    ownerId?: SortOrder
    originalCreatorId?: SortOrder
    originalCreatorProfileId?: SortOrder
    approvedById?: SortOrder
    ownershipStatus?: SortOrder
    submittedAt?: SortOrder
    transferConsentAt?: SortOrder
    transferConsentIp?: SortOrder
    transferConsentUserAgent?: SortOrder
    approvalToken?: SortOrder
    approvalTokenExpiresAt?: SortOrder
    approvedAt?: SortOrder
    reviewComment?: SortOrder
    creditText?: SortOrder
    latestVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwineStoryMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    visibility?: SortOrder
    ownerId?: SortOrder
    originalCreatorId?: SortOrder
    originalCreatorProfileId?: SortOrder
    approvedById?: SortOrder
    ownershipStatus?: SortOrder
    submittedAt?: SortOrder
    transferConsentAt?: SortOrder
    transferConsentIp?: SortOrder
    transferConsentUserAgent?: SortOrder
    approvalToken?: SortOrder
    approvalTokenExpiresAt?: SortOrder
    approvedAt?: SortOrder
    reviewComment?: SortOrder
    creditText?: SortOrder
    latestVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwineStoryMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    visibility?: SortOrder
    ownerId?: SortOrder
    originalCreatorId?: SortOrder
    originalCreatorProfileId?: SortOrder
    approvedById?: SortOrder
    ownershipStatus?: SortOrder
    submittedAt?: SortOrder
    transferConsentAt?: SortOrder
    transferConsentIp?: SortOrder
    transferConsentUserAgent?: SortOrder
    approvalToken?: SortOrder
    approvalTokenExpiresAt?: SortOrder
    approvedAt?: SortOrder
    reviewComment?: SortOrder
    creditText?: SortOrder
    latestVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStoryVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryVisibility | EnumStoryVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.StoryVisibility[] | ListEnumStoryVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryVisibility[] | ListEnumStoryVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.StoryVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryVisibilityFilter<$PrismaModel>
    _max?: NestedEnumStoryVisibilityFilter<$PrismaModel>
  }

  export type EnumStoryOwnershipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryOwnershipStatus | EnumStoryOwnershipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoryOwnershipStatus[] | ListEnumStoryOwnershipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryOwnershipStatus[] | ListEnumStoryOwnershipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryOwnershipStatusWithAggregatesFilter<$PrismaModel> | $Enums.StoryOwnershipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryOwnershipStatusFilter<$PrismaModel>
    _max?: NestedEnumStoryOwnershipStatusFilter<$PrismaModel>
  }

  export type EnumStoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryStatus | EnumStoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryStatusFilter<$PrismaModel> | $Enums.StoryStatus
  }

  export type TwineStoryScalarRelationFilter = {
    is?: TwineStoryWhereInput
    isNot?: TwineStoryWhereInput
  }

  export type TwineStoryNullableScalarRelationFilter = {
    is?: TwineStoryWhereInput | null
    isNot?: TwineStoryWhereInput | null
  }

  export type StoryVersionCountOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    authorId?: SortOrder
    reviewerId?: SortOrder
    versionNumber?: SortOrder
    status?: SortOrder
    changelog?: SortOrder
    content?: SortOrder
    sourceUrl?: SortOrder
    assetPath?: SortOrder
    metadata?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    ownershipStatus?: SortOrder
    consentSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryVersionAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type StoryVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    authorId?: SortOrder
    reviewerId?: SortOrder
    versionNumber?: SortOrder
    status?: SortOrder
    changelog?: SortOrder
    sourceUrl?: SortOrder
    assetPath?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    ownershipStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryVersionMinOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    authorId?: SortOrder
    reviewerId?: SortOrder
    versionNumber?: SortOrder
    status?: SortOrder
    changelog?: SortOrder
    sourceUrl?: SortOrder
    assetPath?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    ownershipStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryVersionSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type EnumStoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryStatus | EnumStoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.StoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryStatusFilter<$PrismaModel>
    _max?: NestedEnumStoryStatusFilter<$PrismaModel>
  }

  export type StoryAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    note?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryVersionScalarRelationFilter = {
    is?: StoryVersionWhereInput
    isNot?: StoryVersionWhereInput
  }

  export type StoryReviewCountOrderByAggregateInput = {
    id?: SortOrder
    versionId?: SortOrder
    reviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    versionId?: SortOrder
    reviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryReviewMinOrderByAggregateInput = {
    id?: SortOrder
    versionId?: SortOrder
    reviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryPlaySessionCountOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    versionId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
  }

  export type StoryPlaySessionAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type StoryPlaySessionMaxOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    versionId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
  }

  export type StoryPlaySessionMinOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    versionId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
  }

  export type StoryPlaySessionSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumStoryNodeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryNodeType | EnumStoryNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoryNodeType[] | ListEnumStoryNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryNodeType[] | ListEnumStoryNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryNodeTypeFilter<$PrismaModel> | $Enums.StoryNodeType
  }

  export type StoryNodeStoryIdKeyCompoundUniqueInput = {
    storyId: string
    key: string
  }

  export type StoryNodeCountOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    key?: SortOrder
    title?: SortOrder
    synopsis?: SortOrder
    type?: SortOrder
    content?: SortOrder
    media?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    key?: SortOrder
    title?: SortOrder
    synopsis?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryNodeMinOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    key?: SortOrder
    title?: SortOrder
    synopsis?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStoryNodeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryNodeType | EnumStoryNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoryNodeType[] | ListEnumStoryNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryNodeType[] | ListEnumStoryNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryNodeTypeWithAggregatesFilter<$PrismaModel> | $Enums.StoryNodeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryNodeTypeFilter<$PrismaModel>
    _max?: NestedEnumStoryNodeTypeFilter<$PrismaModel>
  }

  export type StoryPathStoryIdKeyCompoundUniqueInput = {
    storyId: string
    key: string
  }

  export type StoryPathCountOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    summary?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryPathMaxOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryPathMinOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryNodeScalarRelationFilter = {
    is?: StoryNodeWhereInput
    isNot?: StoryNodeWhereInput
  }

  export type StoryNodeNullableScalarRelationFilter = {
    is?: StoryNodeWhereInput | null
    isNot?: StoryNodeWhereInput | null
  }

  export type StoryPathScalarRelationFilter = {
    is?: StoryPathWhereInput
    isNot?: StoryPathWhereInput
  }

  export type StoryTransitionStoryIdFromNodeIdPathIdToNodeIdCompoundUniqueInput = {
    storyId: string
    fromNodeId: string
    pathId: string
    toNodeId: string
  }

  export type StoryTransitionCountOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    fromNodeId?: SortOrder
    pathId?: SortOrder
    toNodeId?: SortOrder
    ordering?: SortOrder
    condition?: SortOrder
    effect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryTransitionAvgOrderByAggregateInput = {
    ordering?: SortOrder
  }

  export type StoryTransitionMaxOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    fromNodeId?: SortOrder
    pathId?: SortOrder
    toNodeId?: SortOrder
    ordering?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryTransitionMinOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    fromNodeId?: SortOrder
    pathId?: SortOrder
    toNodeId?: SortOrder
    ordering?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryTransitionSumOrderByAggregateInput = {
    ordering?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AvatarProfileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    background?: SortOrder
    appearance?: SortOrder
    initialResources?: SortOrder
    socialContext?: SortOrder
    isPlayable?: SortOrder
    storyId?: SortOrder
    experienceClicks?: SortOrder
    experienceStarts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvatarProfileAvgOrderByAggregateInput = {
    age?: SortOrder
    experienceClicks?: SortOrder
    experienceStarts?: SortOrder
  }

  export type AvatarProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    background?: SortOrder
    isPlayable?: SortOrder
    storyId?: SortOrder
    experienceClicks?: SortOrder
    experienceStarts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvatarProfileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    background?: SortOrder
    isPlayable?: SortOrder
    storyId?: SortOrder
    experienceClicks?: SortOrder
    experienceStarts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvatarProfileSumOrderByAggregateInput = {
    age?: SortOrder
    experienceClicks?: SortOrder
    experienceStarts?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumStoryInteractionKindFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryInteractionKind | EnumStoryInteractionKindFieldRefInput<$PrismaModel>
    in?: $Enums.StoryInteractionKind[] | ListEnumStoryInteractionKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryInteractionKind[] | ListEnumStoryInteractionKindFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryInteractionKindFilter<$PrismaModel> | $Enums.StoryInteractionKind
  }

  export type AvatarProfileScalarRelationFilter = {
    is?: AvatarProfileWhereInput
    isNot?: AvatarProfileWhereInput
  }

  export type StoryInteractionCountOrderByAggregateInput = {
    id?: SortOrder
    avatarId?: SortOrder
    storyId?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    kind?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryInteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    avatarId?: SortOrder
    storyId?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryInteractionMinOrderByAggregateInput = {
    id?: SortOrder
    avatarId?: SortOrder
    storyId?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumStoryInteractionKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryInteractionKind | EnumStoryInteractionKindFieldRefInput<$PrismaModel>
    in?: $Enums.StoryInteractionKind[] | ListEnumStoryInteractionKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryInteractionKind[] | ListEnumStoryInteractionKindFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryInteractionKindWithAggregatesFilter<$PrismaModel> | $Enums.StoryInteractionKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryInteractionKindFilter<$PrismaModel>
    _max?: NestedEnumStoryInteractionKindFilter<$PrismaModel>
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type JourneyProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<JourneyProgressCreateWithoutUserInput, JourneyProgressUncheckedCreateWithoutUserInput> | JourneyProgressCreateWithoutUserInput[] | JourneyProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutUserInput | JourneyProgressCreateOrConnectWithoutUserInput[]
    createMany?: JourneyProgressCreateManyUserInputEnvelope
    connect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type StoryPlaySessionCreateNestedManyWithoutUserInput = {
    create?: XOR<StoryPlaySessionCreateWithoutUserInput, StoryPlaySessionUncheckedCreateWithoutUserInput> | StoryPlaySessionCreateWithoutUserInput[] | StoryPlaySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutUserInput | StoryPlaySessionCreateOrConnectWithoutUserInput[]
    createMany?: StoryPlaySessionCreateManyUserInputEnvelope
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
  }

  export type TwineStoryCreateNestedManyWithoutOwnerInput = {
    create?: XOR<TwineStoryCreateWithoutOwnerInput, TwineStoryUncheckedCreateWithoutOwnerInput> | TwineStoryCreateWithoutOwnerInput[] | TwineStoryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutOwnerInput | TwineStoryCreateOrConnectWithoutOwnerInput[]
    createMany?: TwineStoryCreateManyOwnerInputEnvelope
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
  }

  export type StoryVersionCreateNestedManyWithoutAuthorInput = {
    create?: XOR<StoryVersionCreateWithoutAuthorInput, StoryVersionUncheckedCreateWithoutAuthorInput> | StoryVersionCreateWithoutAuthorInput[] | StoryVersionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutAuthorInput | StoryVersionCreateOrConnectWithoutAuthorInput[]
    createMany?: StoryVersionCreateManyAuthorInputEnvelope
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
  }

  export type StoryVersionCreateNestedManyWithoutReviewerInput = {
    create?: XOR<StoryVersionCreateWithoutReviewerInput, StoryVersionUncheckedCreateWithoutReviewerInput> | StoryVersionCreateWithoutReviewerInput[] | StoryVersionUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutReviewerInput | StoryVersionCreateOrConnectWithoutReviewerInput[]
    createMany?: StoryVersionCreateManyReviewerInputEnvelope
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
  }

  export type StoryReviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<StoryReviewCreateWithoutReviewerInput, StoryReviewUncheckedCreateWithoutReviewerInput> | StoryReviewCreateWithoutReviewerInput[] | StoryReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: StoryReviewCreateOrConnectWithoutReviewerInput | StoryReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: StoryReviewCreateManyReviewerInputEnvelope
    connect?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
  }

  export type CreatorProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<CreatorProfileCreateWithoutUserInput, CreatorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: CreatorProfileCreateOrConnectWithoutUserInput
    connect?: CreatorProfileWhereUniqueInput
  }

  export type TwineStoryCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<TwineStoryCreateWithoutApprovedByInput, TwineStoryUncheckedCreateWithoutApprovedByInput> | TwineStoryCreateWithoutApprovedByInput[] | TwineStoryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutApprovedByInput | TwineStoryCreateOrConnectWithoutApprovedByInput[]
    createMany?: TwineStoryCreateManyApprovedByInputEnvelope
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
  }

  export type TwineStoryCreateNestedManyWithoutOriginalCreatorInput = {
    create?: XOR<TwineStoryCreateWithoutOriginalCreatorInput, TwineStoryUncheckedCreateWithoutOriginalCreatorInput> | TwineStoryCreateWithoutOriginalCreatorInput[] | TwineStoryUncheckedCreateWithoutOriginalCreatorInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutOriginalCreatorInput | TwineStoryCreateOrConnectWithoutOriginalCreatorInput[]
    createMany?: TwineStoryCreateManyOriginalCreatorInputEnvelope
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
  }

  export type CreatorProfileCreateNestedManyWithoutLastReviewerInput = {
    create?: XOR<CreatorProfileCreateWithoutLastReviewerInput, CreatorProfileUncheckedCreateWithoutLastReviewerInput> | CreatorProfileCreateWithoutLastReviewerInput[] | CreatorProfileUncheckedCreateWithoutLastReviewerInput[]
    connectOrCreate?: CreatorProfileCreateOrConnectWithoutLastReviewerInput | CreatorProfileCreateOrConnectWithoutLastReviewerInput[]
    createMany?: CreatorProfileCreateManyLastReviewerInputEnvelope
    connect?: CreatorProfileWhereUniqueInput | CreatorProfileWhereUniqueInput[]
  }

  export type StoryAuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<StoryAuditLogCreateWithoutActorInput, StoryAuditLogUncheckedCreateWithoutActorInput> | StoryAuditLogCreateWithoutActorInput[] | StoryAuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: StoryAuditLogCreateOrConnectWithoutActorInput | StoryAuditLogCreateOrConnectWithoutActorInput[]
    createMany?: StoryAuditLogCreateManyActorInputEnvelope
    connect?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
  }

  export type StoryInteractionCreateNestedManyWithoutUserInput = {
    create?: XOR<StoryInteractionCreateWithoutUserInput, StoryInteractionUncheckedCreateWithoutUserInput> | StoryInteractionCreateWithoutUserInput[] | StoryInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutUserInput | StoryInteractionCreateOrConnectWithoutUserInput[]
    createMany?: StoryInteractionCreateManyUserInputEnvelope
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type JourneyProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JourneyProgressCreateWithoutUserInput, JourneyProgressUncheckedCreateWithoutUserInput> | JourneyProgressCreateWithoutUserInput[] | JourneyProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutUserInput | JourneyProgressCreateOrConnectWithoutUserInput[]
    createMany?: JourneyProgressCreateManyUserInputEnvelope
    connect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StoryPlaySessionCreateWithoutUserInput, StoryPlaySessionUncheckedCreateWithoutUserInput> | StoryPlaySessionCreateWithoutUserInput[] | StoryPlaySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutUserInput | StoryPlaySessionCreateOrConnectWithoutUserInput[]
    createMany?: StoryPlaySessionCreateManyUserInputEnvelope
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
  }

  export type TwineStoryUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<TwineStoryCreateWithoutOwnerInput, TwineStoryUncheckedCreateWithoutOwnerInput> | TwineStoryCreateWithoutOwnerInput[] | TwineStoryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutOwnerInput | TwineStoryCreateOrConnectWithoutOwnerInput[]
    createMany?: TwineStoryCreateManyOwnerInputEnvelope
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
  }

  export type StoryVersionUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<StoryVersionCreateWithoutAuthorInput, StoryVersionUncheckedCreateWithoutAuthorInput> | StoryVersionCreateWithoutAuthorInput[] | StoryVersionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutAuthorInput | StoryVersionCreateOrConnectWithoutAuthorInput[]
    createMany?: StoryVersionCreateManyAuthorInputEnvelope
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
  }

  export type StoryVersionUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<StoryVersionCreateWithoutReviewerInput, StoryVersionUncheckedCreateWithoutReviewerInput> | StoryVersionCreateWithoutReviewerInput[] | StoryVersionUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutReviewerInput | StoryVersionCreateOrConnectWithoutReviewerInput[]
    createMany?: StoryVersionCreateManyReviewerInputEnvelope
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
  }

  export type StoryReviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<StoryReviewCreateWithoutReviewerInput, StoryReviewUncheckedCreateWithoutReviewerInput> | StoryReviewCreateWithoutReviewerInput[] | StoryReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: StoryReviewCreateOrConnectWithoutReviewerInput | StoryReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: StoryReviewCreateManyReviewerInputEnvelope
    connect?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
  }

  export type CreatorProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CreatorProfileCreateWithoutUserInput, CreatorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: CreatorProfileCreateOrConnectWithoutUserInput
    connect?: CreatorProfileWhereUniqueInput
  }

  export type TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<TwineStoryCreateWithoutApprovedByInput, TwineStoryUncheckedCreateWithoutApprovedByInput> | TwineStoryCreateWithoutApprovedByInput[] | TwineStoryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutApprovedByInput | TwineStoryCreateOrConnectWithoutApprovedByInput[]
    createMany?: TwineStoryCreateManyApprovedByInputEnvelope
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
  }

  export type TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput = {
    create?: XOR<TwineStoryCreateWithoutOriginalCreatorInput, TwineStoryUncheckedCreateWithoutOriginalCreatorInput> | TwineStoryCreateWithoutOriginalCreatorInput[] | TwineStoryUncheckedCreateWithoutOriginalCreatorInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutOriginalCreatorInput | TwineStoryCreateOrConnectWithoutOriginalCreatorInput[]
    createMany?: TwineStoryCreateManyOriginalCreatorInputEnvelope
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
  }

  export type CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput = {
    create?: XOR<CreatorProfileCreateWithoutLastReviewerInput, CreatorProfileUncheckedCreateWithoutLastReviewerInput> | CreatorProfileCreateWithoutLastReviewerInput[] | CreatorProfileUncheckedCreateWithoutLastReviewerInput[]
    connectOrCreate?: CreatorProfileCreateOrConnectWithoutLastReviewerInput | CreatorProfileCreateOrConnectWithoutLastReviewerInput[]
    createMany?: CreatorProfileCreateManyLastReviewerInputEnvelope
    connect?: CreatorProfileWhereUniqueInput | CreatorProfileWhereUniqueInput[]
  }

  export type StoryAuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<StoryAuditLogCreateWithoutActorInput, StoryAuditLogUncheckedCreateWithoutActorInput> | StoryAuditLogCreateWithoutActorInput[] | StoryAuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: StoryAuditLogCreateOrConnectWithoutActorInput | StoryAuditLogCreateOrConnectWithoutActorInput[]
    createMany?: StoryAuditLogCreateManyActorInputEnvelope
    connect?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
  }

  export type StoryInteractionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StoryInteractionCreateWithoutUserInput, StoryInteractionUncheckedCreateWithoutUserInput> | StoryInteractionCreateWithoutUserInput[] | StoryInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutUserInput | StoryInteractionCreateOrConnectWithoutUserInput[]
    createMany?: StoryInteractionCreateManyUserInputEnvelope
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type JourneyProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<JourneyProgressCreateWithoutUserInput, JourneyProgressUncheckedCreateWithoutUserInput> | JourneyProgressCreateWithoutUserInput[] | JourneyProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutUserInput | JourneyProgressCreateOrConnectWithoutUserInput[]
    upsert?: JourneyProgressUpsertWithWhereUniqueWithoutUserInput | JourneyProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JourneyProgressCreateManyUserInputEnvelope
    set?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    disconnect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    delete?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    connect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    update?: JourneyProgressUpdateWithWhereUniqueWithoutUserInput | JourneyProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JourneyProgressUpdateManyWithWhereWithoutUserInput | JourneyProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JourneyProgressScalarWhereInput | JourneyProgressScalarWhereInput[]
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type StoryPlaySessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoryPlaySessionCreateWithoutUserInput, StoryPlaySessionUncheckedCreateWithoutUserInput> | StoryPlaySessionCreateWithoutUserInput[] | StoryPlaySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutUserInput | StoryPlaySessionCreateOrConnectWithoutUserInput[]
    upsert?: StoryPlaySessionUpsertWithWhereUniqueWithoutUserInput | StoryPlaySessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoryPlaySessionCreateManyUserInputEnvelope
    set?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    disconnect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    delete?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    update?: StoryPlaySessionUpdateWithWhereUniqueWithoutUserInput | StoryPlaySessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoryPlaySessionUpdateManyWithWhereWithoutUserInput | StoryPlaySessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoryPlaySessionScalarWhereInput | StoryPlaySessionScalarWhereInput[]
  }

  export type TwineStoryUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<TwineStoryCreateWithoutOwnerInput, TwineStoryUncheckedCreateWithoutOwnerInput> | TwineStoryCreateWithoutOwnerInput[] | TwineStoryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutOwnerInput | TwineStoryCreateOrConnectWithoutOwnerInput[]
    upsert?: TwineStoryUpsertWithWhereUniqueWithoutOwnerInput | TwineStoryUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: TwineStoryCreateManyOwnerInputEnvelope
    set?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    disconnect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    delete?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    update?: TwineStoryUpdateWithWhereUniqueWithoutOwnerInput | TwineStoryUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: TwineStoryUpdateManyWithWhereWithoutOwnerInput | TwineStoryUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: TwineStoryScalarWhereInput | TwineStoryScalarWhereInput[]
  }

  export type StoryVersionUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<StoryVersionCreateWithoutAuthorInput, StoryVersionUncheckedCreateWithoutAuthorInput> | StoryVersionCreateWithoutAuthorInput[] | StoryVersionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutAuthorInput | StoryVersionCreateOrConnectWithoutAuthorInput[]
    upsert?: StoryVersionUpsertWithWhereUniqueWithoutAuthorInput | StoryVersionUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: StoryVersionCreateManyAuthorInputEnvelope
    set?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    disconnect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    delete?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    update?: StoryVersionUpdateWithWhereUniqueWithoutAuthorInput | StoryVersionUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: StoryVersionUpdateManyWithWhereWithoutAuthorInput | StoryVersionUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: StoryVersionScalarWhereInput | StoryVersionScalarWhereInput[]
  }

  export type StoryVersionUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<StoryVersionCreateWithoutReviewerInput, StoryVersionUncheckedCreateWithoutReviewerInput> | StoryVersionCreateWithoutReviewerInput[] | StoryVersionUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutReviewerInput | StoryVersionCreateOrConnectWithoutReviewerInput[]
    upsert?: StoryVersionUpsertWithWhereUniqueWithoutReviewerInput | StoryVersionUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: StoryVersionCreateManyReviewerInputEnvelope
    set?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    disconnect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    delete?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    update?: StoryVersionUpdateWithWhereUniqueWithoutReviewerInput | StoryVersionUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: StoryVersionUpdateManyWithWhereWithoutReviewerInput | StoryVersionUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: StoryVersionScalarWhereInput | StoryVersionScalarWhereInput[]
  }

  export type StoryReviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<StoryReviewCreateWithoutReviewerInput, StoryReviewUncheckedCreateWithoutReviewerInput> | StoryReviewCreateWithoutReviewerInput[] | StoryReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: StoryReviewCreateOrConnectWithoutReviewerInput | StoryReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: StoryReviewUpsertWithWhereUniqueWithoutReviewerInput | StoryReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: StoryReviewCreateManyReviewerInputEnvelope
    set?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    disconnect?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    delete?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    connect?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    update?: StoryReviewUpdateWithWhereUniqueWithoutReviewerInput | StoryReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: StoryReviewUpdateManyWithWhereWithoutReviewerInput | StoryReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: StoryReviewScalarWhereInput | StoryReviewScalarWhereInput[]
  }

  export type CreatorProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<CreatorProfileCreateWithoutUserInput, CreatorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: CreatorProfileCreateOrConnectWithoutUserInput
    upsert?: CreatorProfileUpsertWithoutUserInput
    disconnect?: CreatorProfileWhereInput | boolean
    delete?: CreatorProfileWhereInput | boolean
    connect?: CreatorProfileWhereUniqueInput
    update?: XOR<XOR<CreatorProfileUpdateToOneWithWhereWithoutUserInput, CreatorProfileUpdateWithoutUserInput>, CreatorProfileUncheckedUpdateWithoutUserInput>
  }

  export type TwineStoryUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<TwineStoryCreateWithoutApprovedByInput, TwineStoryUncheckedCreateWithoutApprovedByInput> | TwineStoryCreateWithoutApprovedByInput[] | TwineStoryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutApprovedByInput | TwineStoryCreateOrConnectWithoutApprovedByInput[]
    upsert?: TwineStoryUpsertWithWhereUniqueWithoutApprovedByInput | TwineStoryUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: TwineStoryCreateManyApprovedByInputEnvelope
    set?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    disconnect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    delete?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    update?: TwineStoryUpdateWithWhereUniqueWithoutApprovedByInput | TwineStoryUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: TwineStoryUpdateManyWithWhereWithoutApprovedByInput | TwineStoryUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: TwineStoryScalarWhereInput | TwineStoryScalarWhereInput[]
  }

  export type TwineStoryUpdateManyWithoutOriginalCreatorNestedInput = {
    create?: XOR<TwineStoryCreateWithoutOriginalCreatorInput, TwineStoryUncheckedCreateWithoutOriginalCreatorInput> | TwineStoryCreateWithoutOriginalCreatorInput[] | TwineStoryUncheckedCreateWithoutOriginalCreatorInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutOriginalCreatorInput | TwineStoryCreateOrConnectWithoutOriginalCreatorInput[]
    upsert?: TwineStoryUpsertWithWhereUniqueWithoutOriginalCreatorInput | TwineStoryUpsertWithWhereUniqueWithoutOriginalCreatorInput[]
    createMany?: TwineStoryCreateManyOriginalCreatorInputEnvelope
    set?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    disconnect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    delete?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    update?: TwineStoryUpdateWithWhereUniqueWithoutOriginalCreatorInput | TwineStoryUpdateWithWhereUniqueWithoutOriginalCreatorInput[]
    updateMany?: TwineStoryUpdateManyWithWhereWithoutOriginalCreatorInput | TwineStoryUpdateManyWithWhereWithoutOriginalCreatorInput[]
    deleteMany?: TwineStoryScalarWhereInput | TwineStoryScalarWhereInput[]
  }

  export type CreatorProfileUpdateManyWithoutLastReviewerNestedInput = {
    create?: XOR<CreatorProfileCreateWithoutLastReviewerInput, CreatorProfileUncheckedCreateWithoutLastReviewerInput> | CreatorProfileCreateWithoutLastReviewerInput[] | CreatorProfileUncheckedCreateWithoutLastReviewerInput[]
    connectOrCreate?: CreatorProfileCreateOrConnectWithoutLastReviewerInput | CreatorProfileCreateOrConnectWithoutLastReviewerInput[]
    upsert?: CreatorProfileUpsertWithWhereUniqueWithoutLastReviewerInput | CreatorProfileUpsertWithWhereUniqueWithoutLastReviewerInput[]
    createMany?: CreatorProfileCreateManyLastReviewerInputEnvelope
    set?: CreatorProfileWhereUniqueInput | CreatorProfileWhereUniqueInput[]
    disconnect?: CreatorProfileWhereUniqueInput | CreatorProfileWhereUniqueInput[]
    delete?: CreatorProfileWhereUniqueInput | CreatorProfileWhereUniqueInput[]
    connect?: CreatorProfileWhereUniqueInput | CreatorProfileWhereUniqueInput[]
    update?: CreatorProfileUpdateWithWhereUniqueWithoutLastReviewerInput | CreatorProfileUpdateWithWhereUniqueWithoutLastReviewerInput[]
    updateMany?: CreatorProfileUpdateManyWithWhereWithoutLastReviewerInput | CreatorProfileUpdateManyWithWhereWithoutLastReviewerInput[]
    deleteMany?: CreatorProfileScalarWhereInput | CreatorProfileScalarWhereInput[]
  }

  export type StoryAuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<StoryAuditLogCreateWithoutActorInput, StoryAuditLogUncheckedCreateWithoutActorInput> | StoryAuditLogCreateWithoutActorInput[] | StoryAuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: StoryAuditLogCreateOrConnectWithoutActorInput | StoryAuditLogCreateOrConnectWithoutActorInput[]
    upsert?: StoryAuditLogUpsertWithWhereUniqueWithoutActorInput | StoryAuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: StoryAuditLogCreateManyActorInputEnvelope
    set?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    disconnect?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    delete?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    connect?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    update?: StoryAuditLogUpdateWithWhereUniqueWithoutActorInput | StoryAuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: StoryAuditLogUpdateManyWithWhereWithoutActorInput | StoryAuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: StoryAuditLogScalarWhereInput | StoryAuditLogScalarWhereInput[]
  }

  export type StoryInteractionUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoryInteractionCreateWithoutUserInput, StoryInteractionUncheckedCreateWithoutUserInput> | StoryInteractionCreateWithoutUserInput[] | StoryInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutUserInput | StoryInteractionCreateOrConnectWithoutUserInput[]
    upsert?: StoryInteractionUpsertWithWhereUniqueWithoutUserInput | StoryInteractionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoryInteractionCreateManyUserInputEnvelope
    set?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    disconnect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    delete?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    update?: StoryInteractionUpdateWithWhereUniqueWithoutUserInput | StoryInteractionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoryInteractionUpdateManyWithWhereWithoutUserInput | StoryInteractionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoryInteractionScalarWhereInput | StoryInteractionScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type JourneyProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JourneyProgressCreateWithoutUserInput, JourneyProgressUncheckedCreateWithoutUserInput> | JourneyProgressCreateWithoutUserInput[] | JourneyProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutUserInput | JourneyProgressCreateOrConnectWithoutUserInput[]
    upsert?: JourneyProgressUpsertWithWhereUniqueWithoutUserInput | JourneyProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JourneyProgressCreateManyUserInputEnvelope
    set?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    disconnect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    delete?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    connect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    update?: JourneyProgressUpdateWithWhereUniqueWithoutUserInput | JourneyProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JourneyProgressUpdateManyWithWhereWithoutUserInput | JourneyProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JourneyProgressScalarWhereInput | JourneyProgressScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoryPlaySessionCreateWithoutUserInput, StoryPlaySessionUncheckedCreateWithoutUserInput> | StoryPlaySessionCreateWithoutUserInput[] | StoryPlaySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutUserInput | StoryPlaySessionCreateOrConnectWithoutUserInput[]
    upsert?: StoryPlaySessionUpsertWithWhereUniqueWithoutUserInput | StoryPlaySessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoryPlaySessionCreateManyUserInputEnvelope
    set?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    disconnect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    delete?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    update?: StoryPlaySessionUpdateWithWhereUniqueWithoutUserInput | StoryPlaySessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoryPlaySessionUpdateManyWithWhereWithoutUserInput | StoryPlaySessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoryPlaySessionScalarWhereInput | StoryPlaySessionScalarWhereInput[]
  }

  export type TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<TwineStoryCreateWithoutOwnerInput, TwineStoryUncheckedCreateWithoutOwnerInput> | TwineStoryCreateWithoutOwnerInput[] | TwineStoryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutOwnerInput | TwineStoryCreateOrConnectWithoutOwnerInput[]
    upsert?: TwineStoryUpsertWithWhereUniqueWithoutOwnerInput | TwineStoryUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: TwineStoryCreateManyOwnerInputEnvelope
    set?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    disconnect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    delete?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    update?: TwineStoryUpdateWithWhereUniqueWithoutOwnerInput | TwineStoryUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: TwineStoryUpdateManyWithWhereWithoutOwnerInput | TwineStoryUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: TwineStoryScalarWhereInput | TwineStoryScalarWhereInput[]
  }

  export type StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<StoryVersionCreateWithoutAuthorInput, StoryVersionUncheckedCreateWithoutAuthorInput> | StoryVersionCreateWithoutAuthorInput[] | StoryVersionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutAuthorInput | StoryVersionCreateOrConnectWithoutAuthorInput[]
    upsert?: StoryVersionUpsertWithWhereUniqueWithoutAuthorInput | StoryVersionUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: StoryVersionCreateManyAuthorInputEnvelope
    set?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    disconnect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    delete?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    update?: StoryVersionUpdateWithWhereUniqueWithoutAuthorInput | StoryVersionUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: StoryVersionUpdateManyWithWhereWithoutAuthorInput | StoryVersionUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: StoryVersionScalarWhereInput | StoryVersionScalarWhereInput[]
  }

  export type StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<StoryVersionCreateWithoutReviewerInput, StoryVersionUncheckedCreateWithoutReviewerInput> | StoryVersionCreateWithoutReviewerInput[] | StoryVersionUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutReviewerInput | StoryVersionCreateOrConnectWithoutReviewerInput[]
    upsert?: StoryVersionUpsertWithWhereUniqueWithoutReviewerInput | StoryVersionUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: StoryVersionCreateManyReviewerInputEnvelope
    set?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    disconnect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    delete?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    update?: StoryVersionUpdateWithWhereUniqueWithoutReviewerInput | StoryVersionUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: StoryVersionUpdateManyWithWhereWithoutReviewerInput | StoryVersionUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: StoryVersionScalarWhereInput | StoryVersionScalarWhereInput[]
  }

  export type StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<StoryReviewCreateWithoutReviewerInput, StoryReviewUncheckedCreateWithoutReviewerInput> | StoryReviewCreateWithoutReviewerInput[] | StoryReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: StoryReviewCreateOrConnectWithoutReviewerInput | StoryReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: StoryReviewUpsertWithWhereUniqueWithoutReviewerInput | StoryReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: StoryReviewCreateManyReviewerInputEnvelope
    set?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    disconnect?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    delete?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    connect?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    update?: StoryReviewUpdateWithWhereUniqueWithoutReviewerInput | StoryReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: StoryReviewUpdateManyWithWhereWithoutReviewerInput | StoryReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: StoryReviewScalarWhereInput | StoryReviewScalarWhereInput[]
  }

  export type CreatorProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CreatorProfileCreateWithoutUserInput, CreatorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: CreatorProfileCreateOrConnectWithoutUserInput
    upsert?: CreatorProfileUpsertWithoutUserInput
    disconnect?: CreatorProfileWhereInput | boolean
    delete?: CreatorProfileWhereInput | boolean
    connect?: CreatorProfileWhereUniqueInput
    update?: XOR<XOR<CreatorProfileUpdateToOneWithWhereWithoutUserInput, CreatorProfileUpdateWithoutUserInput>, CreatorProfileUncheckedUpdateWithoutUserInput>
  }

  export type TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<TwineStoryCreateWithoutApprovedByInput, TwineStoryUncheckedCreateWithoutApprovedByInput> | TwineStoryCreateWithoutApprovedByInput[] | TwineStoryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutApprovedByInput | TwineStoryCreateOrConnectWithoutApprovedByInput[]
    upsert?: TwineStoryUpsertWithWhereUniqueWithoutApprovedByInput | TwineStoryUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: TwineStoryCreateManyApprovedByInputEnvelope
    set?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    disconnect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    delete?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    update?: TwineStoryUpdateWithWhereUniqueWithoutApprovedByInput | TwineStoryUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: TwineStoryUpdateManyWithWhereWithoutApprovedByInput | TwineStoryUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: TwineStoryScalarWhereInput | TwineStoryScalarWhereInput[]
  }

  export type TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput = {
    create?: XOR<TwineStoryCreateWithoutOriginalCreatorInput, TwineStoryUncheckedCreateWithoutOriginalCreatorInput> | TwineStoryCreateWithoutOriginalCreatorInput[] | TwineStoryUncheckedCreateWithoutOriginalCreatorInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutOriginalCreatorInput | TwineStoryCreateOrConnectWithoutOriginalCreatorInput[]
    upsert?: TwineStoryUpsertWithWhereUniqueWithoutOriginalCreatorInput | TwineStoryUpsertWithWhereUniqueWithoutOriginalCreatorInput[]
    createMany?: TwineStoryCreateManyOriginalCreatorInputEnvelope
    set?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    disconnect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    delete?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    update?: TwineStoryUpdateWithWhereUniqueWithoutOriginalCreatorInput | TwineStoryUpdateWithWhereUniqueWithoutOriginalCreatorInput[]
    updateMany?: TwineStoryUpdateManyWithWhereWithoutOriginalCreatorInput | TwineStoryUpdateManyWithWhereWithoutOriginalCreatorInput[]
    deleteMany?: TwineStoryScalarWhereInput | TwineStoryScalarWhereInput[]
  }

  export type CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput = {
    create?: XOR<CreatorProfileCreateWithoutLastReviewerInput, CreatorProfileUncheckedCreateWithoutLastReviewerInput> | CreatorProfileCreateWithoutLastReviewerInput[] | CreatorProfileUncheckedCreateWithoutLastReviewerInput[]
    connectOrCreate?: CreatorProfileCreateOrConnectWithoutLastReviewerInput | CreatorProfileCreateOrConnectWithoutLastReviewerInput[]
    upsert?: CreatorProfileUpsertWithWhereUniqueWithoutLastReviewerInput | CreatorProfileUpsertWithWhereUniqueWithoutLastReviewerInput[]
    createMany?: CreatorProfileCreateManyLastReviewerInputEnvelope
    set?: CreatorProfileWhereUniqueInput | CreatorProfileWhereUniqueInput[]
    disconnect?: CreatorProfileWhereUniqueInput | CreatorProfileWhereUniqueInput[]
    delete?: CreatorProfileWhereUniqueInput | CreatorProfileWhereUniqueInput[]
    connect?: CreatorProfileWhereUniqueInput | CreatorProfileWhereUniqueInput[]
    update?: CreatorProfileUpdateWithWhereUniqueWithoutLastReviewerInput | CreatorProfileUpdateWithWhereUniqueWithoutLastReviewerInput[]
    updateMany?: CreatorProfileUpdateManyWithWhereWithoutLastReviewerInput | CreatorProfileUpdateManyWithWhereWithoutLastReviewerInput[]
    deleteMany?: CreatorProfileScalarWhereInput | CreatorProfileScalarWhereInput[]
  }

  export type StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<StoryAuditLogCreateWithoutActorInput, StoryAuditLogUncheckedCreateWithoutActorInput> | StoryAuditLogCreateWithoutActorInput[] | StoryAuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: StoryAuditLogCreateOrConnectWithoutActorInput | StoryAuditLogCreateOrConnectWithoutActorInput[]
    upsert?: StoryAuditLogUpsertWithWhereUniqueWithoutActorInput | StoryAuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: StoryAuditLogCreateManyActorInputEnvelope
    set?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    disconnect?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    delete?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    connect?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    update?: StoryAuditLogUpdateWithWhereUniqueWithoutActorInput | StoryAuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: StoryAuditLogUpdateManyWithWhereWithoutActorInput | StoryAuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: StoryAuditLogScalarWhereInput | StoryAuditLogScalarWhereInput[]
  }

  export type StoryInteractionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoryInteractionCreateWithoutUserInput, StoryInteractionUncheckedCreateWithoutUserInput> | StoryInteractionCreateWithoutUserInput[] | StoryInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutUserInput | StoryInteractionCreateOrConnectWithoutUserInput[]
    upsert?: StoryInteractionUpsertWithWhereUniqueWithoutUserInput | StoryInteractionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoryInteractionCreateManyUserInputEnvelope
    set?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    disconnect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    delete?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    update?: StoryInteractionUpdateWithWhereUniqueWithoutUserInput | StoryInteractionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoryInteractionUpdateManyWithWhereWithoutUserInput | StoryInteractionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoryInteractionScalarWhereInput | StoryInteractionScalarWhereInput[]
  }

  export type UserProfileCreateexpertiseTagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserProfileUpdateexpertiseTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type CreatorProfileCreateexpertiseTagsInput = {
    set: string[]
  }

  export type CreatorProfileCreatefocusAreasInput = {
    set: string[]
  }

  export type CreatorProfileCreatelanguagesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCreatorProfileInput = {
    create?: XOR<UserCreateWithoutCreatorProfileInput, UserUncheckedCreateWithoutCreatorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatorProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedCreatorProfilesInput = {
    create?: XOR<UserCreateWithoutReviewedCreatorProfilesInput, UserUncheckedCreateWithoutReviewedCreatorProfilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedCreatorProfilesInput
    connect?: UserWhereUniqueInput
  }

  export type TwineStoryCreateNestedManyWithoutOriginalCreatorProfileInput = {
    create?: XOR<TwineStoryCreateWithoutOriginalCreatorProfileInput, TwineStoryUncheckedCreateWithoutOriginalCreatorProfileInput> | TwineStoryCreateWithoutOriginalCreatorProfileInput[] | TwineStoryUncheckedCreateWithoutOriginalCreatorProfileInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutOriginalCreatorProfileInput | TwineStoryCreateOrConnectWithoutOriginalCreatorProfileInput[]
    createMany?: TwineStoryCreateManyOriginalCreatorProfileInputEnvelope
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
  }

  export type TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorProfileInput = {
    create?: XOR<TwineStoryCreateWithoutOriginalCreatorProfileInput, TwineStoryUncheckedCreateWithoutOriginalCreatorProfileInput> | TwineStoryCreateWithoutOriginalCreatorProfileInput[] | TwineStoryUncheckedCreateWithoutOriginalCreatorProfileInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutOriginalCreatorProfileInput | TwineStoryCreateOrConnectWithoutOriginalCreatorProfileInput[]
    createMany?: TwineStoryCreateManyOriginalCreatorProfileInputEnvelope
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
  }

  export type CreatorProfileUpdateexpertiseTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CreatorProfileUpdatefocusAreasInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CreatorProfileUpdatelanguagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumCreatorProfileStatusFieldUpdateOperationsInput = {
    set?: $Enums.CreatorProfileStatus
  }

  export type UserUpdateOneRequiredWithoutCreatorProfileNestedInput = {
    create?: XOR<UserCreateWithoutCreatorProfileInput, UserUncheckedCreateWithoutCreatorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatorProfileInput
    upsert?: UserUpsertWithoutCreatorProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatorProfileInput, UserUpdateWithoutCreatorProfileInput>, UserUncheckedUpdateWithoutCreatorProfileInput>
  }

  export type UserUpdateOneWithoutReviewedCreatorProfilesNestedInput = {
    create?: XOR<UserCreateWithoutReviewedCreatorProfilesInput, UserUncheckedCreateWithoutReviewedCreatorProfilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedCreatorProfilesInput
    upsert?: UserUpsertWithoutReviewedCreatorProfilesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedCreatorProfilesInput, UserUpdateWithoutReviewedCreatorProfilesInput>, UserUncheckedUpdateWithoutReviewedCreatorProfilesInput>
  }

  export type TwineStoryUpdateManyWithoutOriginalCreatorProfileNestedInput = {
    create?: XOR<TwineStoryCreateWithoutOriginalCreatorProfileInput, TwineStoryUncheckedCreateWithoutOriginalCreatorProfileInput> | TwineStoryCreateWithoutOriginalCreatorProfileInput[] | TwineStoryUncheckedCreateWithoutOriginalCreatorProfileInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutOriginalCreatorProfileInput | TwineStoryCreateOrConnectWithoutOriginalCreatorProfileInput[]
    upsert?: TwineStoryUpsertWithWhereUniqueWithoutOriginalCreatorProfileInput | TwineStoryUpsertWithWhereUniqueWithoutOriginalCreatorProfileInput[]
    createMany?: TwineStoryCreateManyOriginalCreatorProfileInputEnvelope
    set?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    disconnect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    delete?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    update?: TwineStoryUpdateWithWhereUniqueWithoutOriginalCreatorProfileInput | TwineStoryUpdateWithWhereUniqueWithoutOriginalCreatorProfileInput[]
    updateMany?: TwineStoryUpdateManyWithWhereWithoutOriginalCreatorProfileInput | TwineStoryUpdateManyWithWhereWithoutOriginalCreatorProfileInput[]
    deleteMany?: TwineStoryScalarWhereInput | TwineStoryScalarWhereInput[]
  }

  export type TwineStoryUncheckedUpdateManyWithoutOriginalCreatorProfileNestedInput = {
    create?: XOR<TwineStoryCreateWithoutOriginalCreatorProfileInput, TwineStoryUncheckedCreateWithoutOriginalCreatorProfileInput> | TwineStoryCreateWithoutOriginalCreatorProfileInput[] | TwineStoryUncheckedCreateWithoutOriginalCreatorProfileInput[]
    connectOrCreate?: TwineStoryCreateOrConnectWithoutOriginalCreatorProfileInput | TwineStoryCreateOrConnectWithoutOriginalCreatorProfileInput[]
    upsert?: TwineStoryUpsertWithWhereUniqueWithoutOriginalCreatorProfileInput | TwineStoryUpsertWithWhereUniqueWithoutOriginalCreatorProfileInput[]
    createMany?: TwineStoryCreateManyOriginalCreatorProfileInputEnvelope
    set?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    disconnect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    delete?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    connect?: TwineStoryWhereUniqueInput | TwineStoryWhereUniqueInput[]
    update?: TwineStoryUpdateWithWhereUniqueWithoutOriginalCreatorProfileInput | TwineStoryUpdateWithWhereUniqueWithoutOriginalCreatorProfileInput[]
    updateMany?: TwineStoryUpdateManyWithWhereWithoutOriginalCreatorProfileInput | TwineStoryUpdateManyWithWhereWithoutOriginalCreatorProfileInput[]
    deleteMany?: TwineStoryScalarWhereInput | TwineStoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type JourneyProgressCreateNestedManyWithoutSessionInput = {
    create?: XOR<JourneyProgressCreateWithoutSessionInput, JourneyProgressUncheckedCreateWithoutSessionInput> | JourneyProgressCreateWithoutSessionInput[] | JourneyProgressUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutSessionInput | JourneyProgressCreateOrConnectWithoutSessionInput[]
    createMany?: JourneyProgressCreateManySessionInputEnvelope
    connect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
  }

  export type StoryPlaySessionCreateNestedManyWithoutSessionInput = {
    create?: XOR<StoryPlaySessionCreateWithoutSessionInput, StoryPlaySessionUncheckedCreateWithoutSessionInput> | StoryPlaySessionCreateWithoutSessionInput[] | StoryPlaySessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutSessionInput | StoryPlaySessionCreateOrConnectWithoutSessionInput[]
    createMany?: StoryPlaySessionCreateManySessionInputEnvelope
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
  }

  export type UserAchievementCreateNestedManyWithoutSessionInput = {
    create?: XOR<UserAchievementCreateWithoutSessionInput, UserAchievementUncheckedCreateWithoutSessionInput> | UserAchievementCreateWithoutSessionInput[] | UserAchievementUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutSessionInput | UserAchievementCreateOrConnectWithoutSessionInput[]
    createMany?: UserAchievementCreateManySessionInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type StoryInteractionCreateNestedManyWithoutSessionInput = {
    create?: XOR<StoryInteractionCreateWithoutSessionInput, StoryInteractionUncheckedCreateWithoutSessionInput> | StoryInteractionCreateWithoutSessionInput[] | StoryInteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutSessionInput | StoryInteractionCreateOrConnectWithoutSessionInput[]
    createMany?: StoryInteractionCreateManySessionInputEnvelope
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
  }

  export type JourneyProgressUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<JourneyProgressCreateWithoutSessionInput, JourneyProgressUncheckedCreateWithoutSessionInput> | JourneyProgressCreateWithoutSessionInput[] | JourneyProgressUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutSessionInput | JourneyProgressCreateOrConnectWithoutSessionInput[]
    createMany?: JourneyProgressCreateManySessionInputEnvelope
    connect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
  }

  export type StoryPlaySessionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<StoryPlaySessionCreateWithoutSessionInput, StoryPlaySessionUncheckedCreateWithoutSessionInput> | StoryPlaySessionCreateWithoutSessionInput[] | StoryPlaySessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutSessionInput | StoryPlaySessionCreateOrConnectWithoutSessionInput[]
    createMany?: StoryPlaySessionCreateManySessionInputEnvelope
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<UserAchievementCreateWithoutSessionInput, UserAchievementUncheckedCreateWithoutSessionInput> | UserAchievementCreateWithoutSessionInput[] | UserAchievementUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutSessionInput | UserAchievementCreateOrConnectWithoutSessionInput[]
    createMany?: UserAchievementCreateManySessionInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type StoryInteractionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<StoryInteractionCreateWithoutSessionInput, StoryInteractionUncheckedCreateWithoutSessionInput> | StoryInteractionCreateWithoutSessionInput[] | StoryInteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutSessionInput | StoryInteractionCreateOrConnectWithoutSessionInput[]
    createMany?: StoryInteractionCreateManySessionInputEnvelope
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
  }

  export type EnumSessionKindFieldUpdateOperationsInput = {
    set?: $Enums.SessionKind
  }

  export type UserUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type JourneyProgressUpdateManyWithoutSessionNestedInput = {
    create?: XOR<JourneyProgressCreateWithoutSessionInput, JourneyProgressUncheckedCreateWithoutSessionInput> | JourneyProgressCreateWithoutSessionInput[] | JourneyProgressUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutSessionInput | JourneyProgressCreateOrConnectWithoutSessionInput[]
    upsert?: JourneyProgressUpsertWithWhereUniqueWithoutSessionInput | JourneyProgressUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: JourneyProgressCreateManySessionInputEnvelope
    set?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    disconnect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    delete?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    connect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    update?: JourneyProgressUpdateWithWhereUniqueWithoutSessionInput | JourneyProgressUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: JourneyProgressUpdateManyWithWhereWithoutSessionInput | JourneyProgressUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: JourneyProgressScalarWhereInput | JourneyProgressScalarWhereInput[]
  }

  export type StoryPlaySessionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<StoryPlaySessionCreateWithoutSessionInput, StoryPlaySessionUncheckedCreateWithoutSessionInput> | StoryPlaySessionCreateWithoutSessionInput[] | StoryPlaySessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutSessionInput | StoryPlaySessionCreateOrConnectWithoutSessionInput[]
    upsert?: StoryPlaySessionUpsertWithWhereUniqueWithoutSessionInput | StoryPlaySessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: StoryPlaySessionCreateManySessionInputEnvelope
    set?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    disconnect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    delete?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    update?: StoryPlaySessionUpdateWithWhereUniqueWithoutSessionInput | StoryPlaySessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: StoryPlaySessionUpdateManyWithWhereWithoutSessionInput | StoryPlaySessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: StoryPlaySessionScalarWhereInput | StoryPlaySessionScalarWhereInput[]
  }

  export type UserAchievementUpdateManyWithoutSessionNestedInput = {
    create?: XOR<UserAchievementCreateWithoutSessionInput, UserAchievementUncheckedCreateWithoutSessionInput> | UserAchievementCreateWithoutSessionInput[] | UserAchievementUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutSessionInput | UserAchievementCreateOrConnectWithoutSessionInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutSessionInput | UserAchievementUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: UserAchievementCreateManySessionInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutSessionInput | UserAchievementUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutSessionInput | UserAchievementUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type StoryInteractionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<StoryInteractionCreateWithoutSessionInput, StoryInteractionUncheckedCreateWithoutSessionInput> | StoryInteractionCreateWithoutSessionInput[] | StoryInteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutSessionInput | StoryInteractionCreateOrConnectWithoutSessionInput[]
    upsert?: StoryInteractionUpsertWithWhereUniqueWithoutSessionInput | StoryInteractionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: StoryInteractionCreateManySessionInputEnvelope
    set?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    disconnect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    delete?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    update?: StoryInteractionUpdateWithWhereUniqueWithoutSessionInput | StoryInteractionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: StoryInteractionUpdateManyWithWhereWithoutSessionInput | StoryInteractionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: StoryInteractionScalarWhereInput | StoryInteractionScalarWhereInput[]
  }

  export type JourneyProgressUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<JourneyProgressCreateWithoutSessionInput, JourneyProgressUncheckedCreateWithoutSessionInput> | JourneyProgressCreateWithoutSessionInput[] | JourneyProgressUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutSessionInput | JourneyProgressCreateOrConnectWithoutSessionInput[]
    upsert?: JourneyProgressUpsertWithWhereUniqueWithoutSessionInput | JourneyProgressUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: JourneyProgressCreateManySessionInputEnvelope
    set?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    disconnect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    delete?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    connect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    update?: JourneyProgressUpdateWithWhereUniqueWithoutSessionInput | JourneyProgressUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: JourneyProgressUpdateManyWithWhereWithoutSessionInput | JourneyProgressUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: JourneyProgressScalarWhereInput | JourneyProgressScalarWhereInput[]
  }

  export type StoryPlaySessionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<StoryPlaySessionCreateWithoutSessionInput, StoryPlaySessionUncheckedCreateWithoutSessionInput> | StoryPlaySessionCreateWithoutSessionInput[] | StoryPlaySessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutSessionInput | StoryPlaySessionCreateOrConnectWithoutSessionInput[]
    upsert?: StoryPlaySessionUpsertWithWhereUniqueWithoutSessionInput | StoryPlaySessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: StoryPlaySessionCreateManySessionInputEnvelope
    set?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    disconnect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    delete?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    update?: StoryPlaySessionUpdateWithWhereUniqueWithoutSessionInput | StoryPlaySessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: StoryPlaySessionUpdateManyWithWhereWithoutSessionInput | StoryPlaySessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: StoryPlaySessionScalarWhereInput | StoryPlaySessionScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<UserAchievementCreateWithoutSessionInput, UserAchievementUncheckedCreateWithoutSessionInput> | UserAchievementCreateWithoutSessionInput[] | UserAchievementUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutSessionInput | UserAchievementCreateOrConnectWithoutSessionInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutSessionInput | UserAchievementUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: UserAchievementCreateManySessionInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutSessionInput | UserAchievementUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutSessionInput | UserAchievementUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type StoryInteractionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<StoryInteractionCreateWithoutSessionInput, StoryInteractionUncheckedCreateWithoutSessionInput> | StoryInteractionCreateWithoutSessionInput[] | StoryInteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutSessionInput | StoryInteractionCreateOrConnectWithoutSessionInput[]
    upsert?: StoryInteractionUpsertWithWhereUniqueWithoutSessionInput | StoryInteractionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: StoryInteractionCreateManySessionInputEnvelope
    set?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    disconnect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    delete?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    update?: StoryInteractionUpdateWithWhereUniqueWithoutSessionInput | StoryInteractionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: StoryInteractionUpdateManyWithWhereWithoutSessionInput | StoryInteractionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: StoryInteractionScalarWhereInput | StoryInteractionScalarWhereInput[]
  }

  export type JourneyProgressCreateNestedManyWithoutScenarioInput = {
    create?: XOR<JourneyProgressCreateWithoutScenarioInput, JourneyProgressUncheckedCreateWithoutScenarioInput> | JourneyProgressCreateWithoutScenarioInput[] | JourneyProgressUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutScenarioInput | JourneyProgressCreateOrConnectWithoutScenarioInput[]
    createMany?: JourneyProgressCreateManyScenarioInputEnvelope
    connect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
  }

  export type JourneyProgressUncheckedCreateNestedManyWithoutScenarioInput = {
    create?: XOR<JourneyProgressCreateWithoutScenarioInput, JourneyProgressUncheckedCreateWithoutScenarioInput> | JourneyProgressCreateWithoutScenarioInput[] | JourneyProgressUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutScenarioInput | JourneyProgressCreateOrConnectWithoutScenarioInput[]
    createMany?: JourneyProgressCreateManyScenarioInputEnvelope
    connect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JourneyProgressUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<JourneyProgressCreateWithoutScenarioInput, JourneyProgressUncheckedCreateWithoutScenarioInput> | JourneyProgressCreateWithoutScenarioInput[] | JourneyProgressUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutScenarioInput | JourneyProgressCreateOrConnectWithoutScenarioInput[]
    upsert?: JourneyProgressUpsertWithWhereUniqueWithoutScenarioInput | JourneyProgressUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: JourneyProgressCreateManyScenarioInputEnvelope
    set?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    disconnect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    delete?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    connect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    update?: JourneyProgressUpdateWithWhereUniqueWithoutScenarioInput | JourneyProgressUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: JourneyProgressUpdateManyWithWhereWithoutScenarioInput | JourneyProgressUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: JourneyProgressScalarWhereInput | JourneyProgressScalarWhereInput[]
  }

  export type JourneyProgressUncheckedUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<JourneyProgressCreateWithoutScenarioInput, JourneyProgressUncheckedCreateWithoutScenarioInput> | JourneyProgressCreateWithoutScenarioInput[] | JourneyProgressUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutScenarioInput | JourneyProgressCreateOrConnectWithoutScenarioInput[]
    upsert?: JourneyProgressUpsertWithWhereUniqueWithoutScenarioInput | JourneyProgressUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: JourneyProgressCreateManyScenarioInputEnvelope
    set?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    disconnect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    delete?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    connect?: JourneyProgressWhereUniqueInput | JourneyProgressWhereUniqueInput[]
    update?: JourneyProgressUpdateWithWhereUniqueWithoutScenarioInput | JourneyProgressUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: JourneyProgressUpdateManyWithWhereWithoutScenarioInput | JourneyProgressUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: JourneyProgressScalarWhereInput | JourneyProgressScalarWhereInput[]
  }

  export type ScenarioCreateNestedOneWithoutJourneysInput = {
    create?: XOR<ScenarioCreateWithoutJourneysInput, ScenarioUncheckedCreateWithoutJourneysInput>
    connectOrCreate?: ScenarioCreateOrConnectWithoutJourneysInput
    connect?: ScenarioWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutJourneysInput = {
    create?: XOR<UserCreateWithoutJourneysInput, UserUncheckedCreateWithoutJourneysInput>
    connectOrCreate?: UserCreateOrConnectWithoutJourneysInput
    connect?: UserWhereUniqueInput
  }

  export type UserSessionCreateNestedOneWithoutJourneysInput = {
    create?: XOR<UserSessionCreateWithoutJourneysInput, UserSessionUncheckedCreateWithoutJourneysInput>
    connectOrCreate?: UserSessionCreateOrConnectWithoutJourneysInput
    connect?: UserSessionWhereUniqueInput
  }

  export type UserAchievementCreateNestedManyWithoutJourneyInput = {
    create?: XOR<UserAchievementCreateWithoutJourneyInput, UserAchievementUncheckedCreateWithoutJourneyInput> | UserAchievementCreateWithoutJourneyInput[] | UserAchievementUncheckedCreateWithoutJourneyInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutJourneyInput | UserAchievementCreateOrConnectWithoutJourneyInput[]
    createMany?: UserAchievementCreateManyJourneyInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutJourneyInput = {
    create?: XOR<UserAchievementCreateWithoutJourneyInput, UserAchievementUncheckedCreateWithoutJourneyInput> | UserAchievementCreateWithoutJourneyInput[] | UserAchievementUncheckedCreateWithoutJourneyInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutJourneyInput | UserAchievementCreateOrConnectWithoutJourneyInput[]
    createMany?: UserAchievementCreateManyJourneyInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type EnumJourneyStatusFieldUpdateOperationsInput = {
    set?: $Enums.JourneyStatus
  }

  export type ScenarioUpdateOneRequiredWithoutJourneysNestedInput = {
    create?: XOR<ScenarioCreateWithoutJourneysInput, ScenarioUncheckedCreateWithoutJourneysInput>
    connectOrCreate?: ScenarioCreateOrConnectWithoutJourneysInput
    upsert?: ScenarioUpsertWithoutJourneysInput
    connect?: ScenarioWhereUniqueInput
    update?: XOR<XOR<ScenarioUpdateToOneWithWhereWithoutJourneysInput, ScenarioUpdateWithoutJourneysInput>, ScenarioUncheckedUpdateWithoutJourneysInput>
  }

  export type UserUpdateOneWithoutJourneysNestedInput = {
    create?: XOR<UserCreateWithoutJourneysInput, UserUncheckedCreateWithoutJourneysInput>
    connectOrCreate?: UserCreateOrConnectWithoutJourneysInput
    upsert?: UserUpsertWithoutJourneysInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJourneysInput, UserUpdateWithoutJourneysInput>, UserUncheckedUpdateWithoutJourneysInput>
  }

  export type UserSessionUpdateOneWithoutJourneysNestedInput = {
    create?: XOR<UserSessionCreateWithoutJourneysInput, UserSessionUncheckedCreateWithoutJourneysInput>
    connectOrCreate?: UserSessionCreateOrConnectWithoutJourneysInput
    upsert?: UserSessionUpsertWithoutJourneysInput
    disconnect?: UserSessionWhereInput | boolean
    delete?: UserSessionWhereInput | boolean
    connect?: UserSessionWhereUniqueInput
    update?: XOR<XOR<UserSessionUpdateToOneWithWhereWithoutJourneysInput, UserSessionUpdateWithoutJourneysInput>, UserSessionUncheckedUpdateWithoutJourneysInput>
  }

  export type UserAchievementUpdateManyWithoutJourneyNestedInput = {
    create?: XOR<UserAchievementCreateWithoutJourneyInput, UserAchievementUncheckedCreateWithoutJourneyInput> | UserAchievementCreateWithoutJourneyInput[] | UserAchievementUncheckedCreateWithoutJourneyInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutJourneyInput | UserAchievementCreateOrConnectWithoutJourneyInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutJourneyInput | UserAchievementUpsertWithWhereUniqueWithoutJourneyInput[]
    createMany?: UserAchievementCreateManyJourneyInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutJourneyInput | UserAchievementUpdateWithWhereUniqueWithoutJourneyInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutJourneyInput | UserAchievementUpdateManyWithWhereWithoutJourneyInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutJourneyNestedInput = {
    create?: XOR<UserAchievementCreateWithoutJourneyInput, UserAchievementUncheckedCreateWithoutJourneyInput> | UserAchievementCreateWithoutJourneyInput[] | UserAchievementUncheckedCreateWithoutJourneyInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutJourneyInput | UserAchievementCreateOrConnectWithoutJourneyInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutJourneyInput | UserAchievementUpsertWithWhereUniqueWithoutJourneyInput[]
    createMany?: UserAchievementCreateManyJourneyInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutJourneyInput | UserAchievementUpdateWithWhereUniqueWithoutJourneyInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutJourneyInput | UserAchievementUpdateManyWithWhereWithoutJourneyInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserAchievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type AchievementCreateNestedOneWithoutUserAwardsInput = {
    create?: XOR<AchievementCreateWithoutUserAwardsInput, AchievementUncheckedCreateWithoutUserAwardsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAwardsInput
    connect?: AchievementWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type UserSessionCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserSessionCreateWithoutAchievementsInput, UserSessionUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserSessionCreateOrConnectWithoutAchievementsInput
    connect?: UserSessionWhereUniqueInput
  }

  export type JourneyProgressCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<JourneyProgressCreateWithoutAchievementsInput, JourneyProgressUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutAchievementsInput
    connect?: JourneyProgressWhereUniqueInput
  }

  export type AchievementUpdateOneRequiredWithoutUserAwardsNestedInput = {
    create?: XOR<AchievementCreateWithoutUserAwardsInput, AchievementUncheckedCreateWithoutUserAwardsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAwardsInput
    upsert?: AchievementUpsertWithoutUserAwardsInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUserAwardsInput, AchievementUpdateWithoutUserAwardsInput>, AchievementUncheckedUpdateWithoutUserAwardsInput>
  }

  export type UserUpdateOneWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserSessionUpdateOneWithoutAchievementsNestedInput = {
    create?: XOR<UserSessionCreateWithoutAchievementsInput, UserSessionUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserSessionCreateOrConnectWithoutAchievementsInput
    upsert?: UserSessionUpsertWithoutAchievementsInput
    disconnect?: UserSessionWhereInput | boolean
    delete?: UserSessionWhereInput | boolean
    connect?: UserSessionWhereUniqueInput
    update?: XOR<XOR<UserSessionUpdateToOneWithWhereWithoutAchievementsInput, UserSessionUpdateWithoutAchievementsInput>, UserSessionUncheckedUpdateWithoutAchievementsInput>
  }

  export type JourneyProgressUpdateOneWithoutAchievementsNestedInput = {
    create?: XOR<JourneyProgressCreateWithoutAchievementsInput, JourneyProgressUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: JourneyProgressCreateOrConnectWithoutAchievementsInput
    upsert?: JourneyProgressUpsertWithoutAchievementsInput
    disconnect?: JourneyProgressWhereInput | boolean
    delete?: JourneyProgressWhereInput | boolean
    connect?: JourneyProgressWhereUniqueInput
    update?: XOR<XOR<JourneyProgressUpdateToOneWithWhereWithoutAchievementsInput, JourneyProgressUpdateWithoutAchievementsInput>, JourneyProgressUncheckedUpdateWithoutAchievementsInput>
  }

  export type TwineStoryCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutStoriesInput = {
    create?: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOriginalStoriesInput = {
    create?: XOR<UserCreateWithoutOriginalStoriesInput, UserUncheckedCreateWithoutOriginalStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOriginalStoriesInput
    connect?: UserWhereUniqueInput
  }

  export type CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput = {
    create?: XOR<CreatorProfileCreateWithoutStoriesSubmittedInput, CreatorProfileUncheckedCreateWithoutStoriesSubmittedInput>
    connectOrCreate?: CreatorProfileCreateOrConnectWithoutStoriesSubmittedInput
    connect?: CreatorProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedStoriesInput = {
    create?: XOR<UserCreateWithoutApprovedStoriesInput, UserUncheckedCreateWithoutApprovedStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedStoriesInput
    connect?: UserWhereUniqueInput
  }

  export type StoryVersionCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryVersionCreateWithoutStoryInput, StoryVersionUncheckedCreateWithoutStoryInput> | StoryVersionCreateWithoutStoryInput[] | StoryVersionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutStoryInput | StoryVersionCreateOrConnectWithoutStoryInput[]
    createMany?: StoryVersionCreateManyStoryInputEnvelope
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
  }

  export type StoryVersionCreateNestedOneWithoutFeaturedInInput = {
    create?: XOR<StoryVersionCreateWithoutFeaturedInInput, StoryVersionUncheckedCreateWithoutFeaturedInInput>
    connectOrCreate?: StoryVersionCreateOrConnectWithoutFeaturedInInput
    connect?: StoryVersionWhereUniqueInput
  }

  export type StoryPlaySessionCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryPlaySessionCreateWithoutStoryInput, StoryPlaySessionUncheckedCreateWithoutStoryInput> | StoryPlaySessionCreateWithoutStoryInput[] | StoryPlaySessionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutStoryInput | StoryPlaySessionCreateOrConnectWithoutStoryInput[]
    createMany?: StoryPlaySessionCreateManyStoryInputEnvelope
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
  }

  export type StoryNodeCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryNodeCreateWithoutStoryInput, StoryNodeUncheckedCreateWithoutStoryInput> | StoryNodeCreateWithoutStoryInput[] | StoryNodeUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryNodeCreateOrConnectWithoutStoryInput | StoryNodeCreateOrConnectWithoutStoryInput[]
    createMany?: StoryNodeCreateManyStoryInputEnvelope
    connect?: StoryNodeWhereUniqueInput | StoryNodeWhereUniqueInput[]
  }

  export type StoryPathCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryPathCreateWithoutStoryInput, StoryPathUncheckedCreateWithoutStoryInput> | StoryPathCreateWithoutStoryInput[] | StoryPathUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryPathCreateOrConnectWithoutStoryInput | StoryPathCreateOrConnectWithoutStoryInput[]
    createMany?: StoryPathCreateManyStoryInputEnvelope
    connect?: StoryPathWhereUniqueInput | StoryPathWhereUniqueInput[]
  }

  export type StoryTransitionCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryTransitionCreateWithoutStoryInput, StoryTransitionUncheckedCreateWithoutStoryInput> | StoryTransitionCreateWithoutStoryInput[] | StoryTransitionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutStoryInput | StoryTransitionCreateOrConnectWithoutStoryInput[]
    createMany?: StoryTransitionCreateManyStoryInputEnvelope
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
  }

  export type AvatarProfileCreateNestedManyWithoutStoryInput = {
    create?: XOR<AvatarProfileCreateWithoutStoryInput, AvatarProfileUncheckedCreateWithoutStoryInput> | AvatarProfileCreateWithoutStoryInput[] | AvatarProfileUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: AvatarProfileCreateOrConnectWithoutStoryInput | AvatarProfileCreateOrConnectWithoutStoryInput[]
    createMany?: AvatarProfileCreateManyStoryInputEnvelope
    connect?: AvatarProfileWhereUniqueInput | AvatarProfileWhereUniqueInput[]
  }

  export type StoryAuditLogCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryAuditLogCreateWithoutStoryInput, StoryAuditLogUncheckedCreateWithoutStoryInput> | StoryAuditLogCreateWithoutStoryInput[] | StoryAuditLogUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryAuditLogCreateOrConnectWithoutStoryInput | StoryAuditLogCreateOrConnectWithoutStoryInput[]
    createMany?: StoryAuditLogCreateManyStoryInputEnvelope
    connect?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
  }

  export type StoryInteractionCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryInteractionCreateWithoutStoryInput, StoryInteractionUncheckedCreateWithoutStoryInput> | StoryInteractionCreateWithoutStoryInput[] | StoryInteractionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutStoryInput | StoryInteractionCreateOrConnectWithoutStoryInput[]
    createMany?: StoryInteractionCreateManyStoryInputEnvelope
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
  }

  export type StoryVersionUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryVersionCreateWithoutStoryInput, StoryVersionUncheckedCreateWithoutStoryInput> | StoryVersionCreateWithoutStoryInput[] | StoryVersionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutStoryInput | StoryVersionCreateOrConnectWithoutStoryInput[]
    createMany?: StoryVersionCreateManyStoryInputEnvelope
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
  }

  export type StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryPlaySessionCreateWithoutStoryInput, StoryPlaySessionUncheckedCreateWithoutStoryInput> | StoryPlaySessionCreateWithoutStoryInput[] | StoryPlaySessionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutStoryInput | StoryPlaySessionCreateOrConnectWithoutStoryInput[]
    createMany?: StoryPlaySessionCreateManyStoryInputEnvelope
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
  }

  export type StoryNodeUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryNodeCreateWithoutStoryInput, StoryNodeUncheckedCreateWithoutStoryInput> | StoryNodeCreateWithoutStoryInput[] | StoryNodeUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryNodeCreateOrConnectWithoutStoryInput | StoryNodeCreateOrConnectWithoutStoryInput[]
    createMany?: StoryNodeCreateManyStoryInputEnvelope
    connect?: StoryNodeWhereUniqueInput | StoryNodeWhereUniqueInput[]
  }

  export type StoryPathUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryPathCreateWithoutStoryInput, StoryPathUncheckedCreateWithoutStoryInput> | StoryPathCreateWithoutStoryInput[] | StoryPathUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryPathCreateOrConnectWithoutStoryInput | StoryPathCreateOrConnectWithoutStoryInput[]
    createMany?: StoryPathCreateManyStoryInputEnvelope
    connect?: StoryPathWhereUniqueInput | StoryPathWhereUniqueInput[]
  }

  export type StoryTransitionUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryTransitionCreateWithoutStoryInput, StoryTransitionUncheckedCreateWithoutStoryInput> | StoryTransitionCreateWithoutStoryInput[] | StoryTransitionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutStoryInput | StoryTransitionCreateOrConnectWithoutStoryInput[]
    createMany?: StoryTransitionCreateManyStoryInputEnvelope
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
  }

  export type AvatarProfileUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<AvatarProfileCreateWithoutStoryInput, AvatarProfileUncheckedCreateWithoutStoryInput> | AvatarProfileCreateWithoutStoryInput[] | AvatarProfileUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: AvatarProfileCreateOrConnectWithoutStoryInput | AvatarProfileCreateOrConnectWithoutStoryInput[]
    createMany?: AvatarProfileCreateManyStoryInputEnvelope
    connect?: AvatarProfileWhereUniqueInput | AvatarProfileWhereUniqueInput[]
  }

  export type StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryAuditLogCreateWithoutStoryInput, StoryAuditLogUncheckedCreateWithoutStoryInput> | StoryAuditLogCreateWithoutStoryInput[] | StoryAuditLogUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryAuditLogCreateOrConnectWithoutStoryInput | StoryAuditLogCreateOrConnectWithoutStoryInput[]
    createMany?: StoryAuditLogCreateManyStoryInputEnvelope
    connect?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
  }

  export type StoryInteractionUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryInteractionCreateWithoutStoryInput, StoryInteractionUncheckedCreateWithoutStoryInput> | StoryInteractionCreateWithoutStoryInput[] | StoryInteractionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutStoryInput | StoryInteractionCreateOrConnectWithoutStoryInput[]
    createMany?: StoryInteractionCreateManyStoryInputEnvelope
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
  }

  export type TwineStoryUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumStoryVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.StoryVisibility
  }

  export type EnumStoryOwnershipStatusFieldUpdateOperationsInput = {
    set?: $Enums.StoryOwnershipStatus
  }

  export type UserUpdateOneWithoutStoriesNestedInput = {
    create?: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoriesInput
    upsert?: UserUpsertWithoutStoriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoriesInput, UserUpdateWithoutStoriesInput>, UserUncheckedUpdateWithoutStoriesInput>
  }

  export type UserUpdateOneWithoutOriginalStoriesNestedInput = {
    create?: XOR<UserCreateWithoutOriginalStoriesInput, UserUncheckedCreateWithoutOriginalStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOriginalStoriesInput
    upsert?: UserUpsertWithoutOriginalStoriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOriginalStoriesInput, UserUpdateWithoutOriginalStoriesInput>, UserUncheckedUpdateWithoutOriginalStoriesInput>
  }

  export type CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput = {
    create?: XOR<CreatorProfileCreateWithoutStoriesSubmittedInput, CreatorProfileUncheckedCreateWithoutStoriesSubmittedInput>
    connectOrCreate?: CreatorProfileCreateOrConnectWithoutStoriesSubmittedInput
    upsert?: CreatorProfileUpsertWithoutStoriesSubmittedInput
    disconnect?: CreatorProfileWhereInput | boolean
    delete?: CreatorProfileWhereInput | boolean
    connect?: CreatorProfileWhereUniqueInput
    update?: XOR<XOR<CreatorProfileUpdateToOneWithWhereWithoutStoriesSubmittedInput, CreatorProfileUpdateWithoutStoriesSubmittedInput>, CreatorProfileUncheckedUpdateWithoutStoriesSubmittedInput>
  }

  export type UserUpdateOneWithoutApprovedStoriesNestedInput = {
    create?: XOR<UserCreateWithoutApprovedStoriesInput, UserUncheckedCreateWithoutApprovedStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedStoriesInput
    upsert?: UserUpsertWithoutApprovedStoriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedStoriesInput, UserUpdateWithoutApprovedStoriesInput>, UserUncheckedUpdateWithoutApprovedStoriesInput>
  }

  export type StoryVersionUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryVersionCreateWithoutStoryInput, StoryVersionUncheckedCreateWithoutStoryInput> | StoryVersionCreateWithoutStoryInput[] | StoryVersionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutStoryInput | StoryVersionCreateOrConnectWithoutStoryInput[]
    upsert?: StoryVersionUpsertWithWhereUniqueWithoutStoryInput | StoryVersionUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryVersionCreateManyStoryInputEnvelope
    set?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    disconnect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    delete?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    update?: StoryVersionUpdateWithWhereUniqueWithoutStoryInput | StoryVersionUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryVersionUpdateManyWithWhereWithoutStoryInput | StoryVersionUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryVersionScalarWhereInput | StoryVersionScalarWhereInput[]
  }

  export type StoryVersionUpdateOneWithoutFeaturedInNestedInput = {
    create?: XOR<StoryVersionCreateWithoutFeaturedInInput, StoryVersionUncheckedCreateWithoutFeaturedInInput>
    connectOrCreate?: StoryVersionCreateOrConnectWithoutFeaturedInInput
    upsert?: StoryVersionUpsertWithoutFeaturedInInput
    disconnect?: StoryVersionWhereInput | boolean
    delete?: StoryVersionWhereInput | boolean
    connect?: StoryVersionWhereUniqueInput
    update?: XOR<XOR<StoryVersionUpdateToOneWithWhereWithoutFeaturedInInput, StoryVersionUpdateWithoutFeaturedInInput>, StoryVersionUncheckedUpdateWithoutFeaturedInInput>
  }

  export type StoryPlaySessionUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryPlaySessionCreateWithoutStoryInput, StoryPlaySessionUncheckedCreateWithoutStoryInput> | StoryPlaySessionCreateWithoutStoryInput[] | StoryPlaySessionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutStoryInput | StoryPlaySessionCreateOrConnectWithoutStoryInput[]
    upsert?: StoryPlaySessionUpsertWithWhereUniqueWithoutStoryInput | StoryPlaySessionUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryPlaySessionCreateManyStoryInputEnvelope
    set?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    disconnect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    delete?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    update?: StoryPlaySessionUpdateWithWhereUniqueWithoutStoryInput | StoryPlaySessionUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryPlaySessionUpdateManyWithWhereWithoutStoryInput | StoryPlaySessionUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryPlaySessionScalarWhereInput | StoryPlaySessionScalarWhereInput[]
  }

  export type StoryNodeUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryNodeCreateWithoutStoryInput, StoryNodeUncheckedCreateWithoutStoryInput> | StoryNodeCreateWithoutStoryInput[] | StoryNodeUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryNodeCreateOrConnectWithoutStoryInput | StoryNodeCreateOrConnectWithoutStoryInput[]
    upsert?: StoryNodeUpsertWithWhereUniqueWithoutStoryInput | StoryNodeUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryNodeCreateManyStoryInputEnvelope
    set?: StoryNodeWhereUniqueInput | StoryNodeWhereUniqueInput[]
    disconnect?: StoryNodeWhereUniqueInput | StoryNodeWhereUniqueInput[]
    delete?: StoryNodeWhereUniqueInput | StoryNodeWhereUniqueInput[]
    connect?: StoryNodeWhereUniqueInput | StoryNodeWhereUniqueInput[]
    update?: StoryNodeUpdateWithWhereUniqueWithoutStoryInput | StoryNodeUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryNodeUpdateManyWithWhereWithoutStoryInput | StoryNodeUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryNodeScalarWhereInput | StoryNodeScalarWhereInput[]
  }

  export type StoryPathUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryPathCreateWithoutStoryInput, StoryPathUncheckedCreateWithoutStoryInput> | StoryPathCreateWithoutStoryInput[] | StoryPathUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryPathCreateOrConnectWithoutStoryInput | StoryPathCreateOrConnectWithoutStoryInput[]
    upsert?: StoryPathUpsertWithWhereUniqueWithoutStoryInput | StoryPathUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryPathCreateManyStoryInputEnvelope
    set?: StoryPathWhereUniqueInput | StoryPathWhereUniqueInput[]
    disconnect?: StoryPathWhereUniqueInput | StoryPathWhereUniqueInput[]
    delete?: StoryPathWhereUniqueInput | StoryPathWhereUniqueInput[]
    connect?: StoryPathWhereUniqueInput | StoryPathWhereUniqueInput[]
    update?: StoryPathUpdateWithWhereUniqueWithoutStoryInput | StoryPathUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryPathUpdateManyWithWhereWithoutStoryInput | StoryPathUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryPathScalarWhereInput | StoryPathScalarWhereInput[]
  }

  export type StoryTransitionUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryTransitionCreateWithoutStoryInput, StoryTransitionUncheckedCreateWithoutStoryInput> | StoryTransitionCreateWithoutStoryInput[] | StoryTransitionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutStoryInput | StoryTransitionCreateOrConnectWithoutStoryInput[]
    upsert?: StoryTransitionUpsertWithWhereUniqueWithoutStoryInput | StoryTransitionUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryTransitionCreateManyStoryInputEnvelope
    set?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    disconnect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    delete?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    update?: StoryTransitionUpdateWithWhereUniqueWithoutStoryInput | StoryTransitionUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryTransitionUpdateManyWithWhereWithoutStoryInput | StoryTransitionUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryTransitionScalarWhereInput | StoryTransitionScalarWhereInput[]
  }

  export type AvatarProfileUpdateManyWithoutStoryNestedInput = {
    create?: XOR<AvatarProfileCreateWithoutStoryInput, AvatarProfileUncheckedCreateWithoutStoryInput> | AvatarProfileCreateWithoutStoryInput[] | AvatarProfileUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: AvatarProfileCreateOrConnectWithoutStoryInput | AvatarProfileCreateOrConnectWithoutStoryInput[]
    upsert?: AvatarProfileUpsertWithWhereUniqueWithoutStoryInput | AvatarProfileUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: AvatarProfileCreateManyStoryInputEnvelope
    set?: AvatarProfileWhereUniqueInput | AvatarProfileWhereUniqueInput[]
    disconnect?: AvatarProfileWhereUniqueInput | AvatarProfileWhereUniqueInput[]
    delete?: AvatarProfileWhereUniqueInput | AvatarProfileWhereUniqueInput[]
    connect?: AvatarProfileWhereUniqueInput | AvatarProfileWhereUniqueInput[]
    update?: AvatarProfileUpdateWithWhereUniqueWithoutStoryInput | AvatarProfileUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: AvatarProfileUpdateManyWithWhereWithoutStoryInput | AvatarProfileUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: AvatarProfileScalarWhereInput | AvatarProfileScalarWhereInput[]
  }

  export type StoryAuditLogUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryAuditLogCreateWithoutStoryInput, StoryAuditLogUncheckedCreateWithoutStoryInput> | StoryAuditLogCreateWithoutStoryInput[] | StoryAuditLogUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryAuditLogCreateOrConnectWithoutStoryInput | StoryAuditLogCreateOrConnectWithoutStoryInput[]
    upsert?: StoryAuditLogUpsertWithWhereUniqueWithoutStoryInput | StoryAuditLogUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryAuditLogCreateManyStoryInputEnvelope
    set?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    disconnect?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    delete?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    connect?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    update?: StoryAuditLogUpdateWithWhereUniqueWithoutStoryInput | StoryAuditLogUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryAuditLogUpdateManyWithWhereWithoutStoryInput | StoryAuditLogUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryAuditLogScalarWhereInput | StoryAuditLogScalarWhereInput[]
  }

  export type StoryInteractionUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryInteractionCreateWithoutStoryInput, StoryInteractionUncheckedCreateWithoutStoryInput> | StoryInteractionCreateWithoutStoryInput[] | StoryInteractionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutStoryInput | StoryInteractionCreateOrConnectWithoutStoryInput[]
    upsert?: StoryInteractionUpsertWithWhereUniqueWithoutStoryInput | StoryInteractionUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryInteractionCreateManyStoryInputEnvelope
    set?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    disconnect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    delete?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    update?: StoryInteractionUpdateWithWhereUniqueWithoutStoryInput | StoryInteractionUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryInteractionUpdateManyWithWhereWithoutStoryInput | StoryInteractionUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryInteractionScalarWhereInput | StoryInteractionScalarWhereInput[]
  }

  export type StoryVersionUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryVersionCreateWithoutStoryInput, StoryVersionUncheckedCreateWithoutStoryInput> | StoryVersionCreateWithoutStoryInput[] | StoryVersionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutStoryInput | StoryVersionCreateOrConnectWithoutStoryInput[]
    upsert?: StoryVersionUpsertWithWhereUniqueWithoutStoryInput | StoryVersionUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryVersionCreateManyStoryInputEnvelope
    set?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    disconnect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    delete?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    update?: StoryVersionUpdateWithWhereUniqueWithoutStoryInput | StoryVersionUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryVersionUpdateManyWithWhereWithoutStoryInput | StoryVersionUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryVersionScalarWhereInput | StoryVersionScalarWhereInput[]
  }

  export type StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryPlaySessionCreateWithoutStoryInput, StoryPlaySessionUncheckedCreateWithoutStoryInput> | StoryPlaySessionCreateWithoutStoryInput[] | StoryPlaySessionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutStoryInput | StoryPlaySessionCreateOrConnectWithoutStoryInput[]
    upsert?: StoryPlaySessionUpsertWithWhereUniqueWithoutStoryInput | StoryPlaySessionUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryPlaySessionCreateManyStoryInputEnvelope
    set?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    disconnect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    delete?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    update?: StoryPlaySessionUpdateWithWhereUniqueWithoutStoryInput | StoryPlaySessionUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryPlaySessionUpdateManyWithWhereWithoutStoryInput | StoryPlaySessionUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryPlaySessionScalarWhereInput | StoryPlaySessionScalarWhereInput[]
  }

  export type StoryNodeUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryNodeCreateWithoutStoryInput, StoryNodeUncheckedCreateWithoutStoryInput> | StoryNodeCreateWithoutStoryInput[] | StoryNodeUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryNodeCreateOrConnectWithoutStoryInput | StoryNodeCreateOrConnectWithoutStoryInput[]
    upsert?: StoryNodeUpsertWithWhereUniqueWithoutStoryInput | StoryNodeUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryNodeCreateManyStoryInputEnvelope
    set?: StoryNodeWhereUniqueInput | StoryNodeWhereUniqueInput[]
    disconnect?: StoryNodeWhereUniqueInput | StoryNodeWhereUniqueInput[]
    delete?: StoryNodeWhereUniqueInput | StoryNodeWhereUniqueInput[]
    connect?: StoryNodeWhereUniqueInput | StoryNodeWhereUniqueInput[]
    update?: StoryNodeUpdateWithWhereUniqueWithoutStoryInput | StoryNodeUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryNodeUpdateManyWithWhereWithoutStoryInput | StoryNodeUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryNodeScalarWhereInput | StoryNodeScalarWhereInput[]
  }

  export type StoryPathUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryPathCreateWithoutStoryInput, StoryPathUncheckedCreateWithoutStoryInput> | StoryPathCreateWithoutStoryInput[] | StoryPathUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryPathCreateOrConnectWithoutStoryInput | StoryPathCreateOrConnectWithoutStoryInput[]
    upsert?: StoryPathUpsertWithWhereUniqueWithoutStoryInput | StoryPathUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryPathCreateManyStoryInputEnvelope
    set?: StoryPathWhereUniqueInput | StoryPathWhereUniqueInput[]
    disconnect?: StoryPathWhereUniqueInput | StoryPathWhereUniqueInput[]
    delete?: StoryPathWhereUniqueInput | StoryPathWhereUniqueInput[]
    connect?: StoryPathWhereUniqueInput | StoryPathWhereUniqueInput[]
    update?: StoryPathUpdateWithWhereUniqueWithoutStoryInput | StoryPathUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryPathUpdateManyWithWhereWithoutStoryInput | StoryPathUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryPathScalarWhereInput | StoryPathScalarWhereInput[]
  }

  export type StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryTransitionCreateWithoutStoryInput, StoryTransitionUncheckedCreateWithoutStoryInput> | StoryTransitionCreateWithoutStoryInput[] | StoryTransitionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutStoryInput | StoryTransitionCreateOrConnectWithoutStoryInput[]
    upsert?: StoryTransitionUpsertWithWhereUniqueWithoutStoryInput | StoryTransitionUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryTransitionCreateManyStoryInputEnvelope
    set?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    disconnect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    delete?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    update?: StoryTransitionUpdateWithWhereUniqueWithoutStoryInput | StoryTransitionUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryTransitionUpdateManyWithWhereWithoutStoryInput | StoryTransitionUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryTransitionScalarWhereInput | StoryTransitionScalarWhereInput[]
  }

  export type AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<AvatarProfileCreateWithoutStoryInput, AvatarProfileUncheckedCreateWithoutStoryInput> | AvatarProfileCreateWithoutStoryInput[] | AvatarProfileUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: AvatarProfileCreateOrConnectWithoutStoryInput | AvatarProfileCreateOrConnectWithoutStoryInput[]
    upsert?: AvatarProfileUpsertWithWhereUniqueWithoutStoryInput | AvatarProfileUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: AvatarProfileCreateManyStoryInputEnvelope
    set?: AvatarProfileWhereUniqueInput | AvatarProfileWhereUniqueInput[]
    disconnect?: AvatarProfileWhereUniqueInput | AvatarProfileWhereUniqueInput[]
    delete?: AvatarProfileWhereUniqueInput | AvatarProfileWhereUniqueInput[]
    connect?: AvatarProfileWhereUniqueInput | AvatarProfileWhereUniqueInput[]
    update?: AvatarProfileUpdateWithWhereUniqueWithoutStoryInput | AvatarProfileUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: AvatarProfileUpdateManyWithWhereWithoutStoryInput | AvatarProfileUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: AvatarProfileScalarWhereInput | AvatarProfileScalarWhereInput[]
  }

  export type StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryAuditLogCreateWithoutStoryInput, StoryAuditLogUncheckedCreateWithoutStoryInput> | StoryAuditLogCreateWithoutStoryInput[] | StoryAuditLogUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryAuditLogCreateOrConnectWithoutStoryInput | StoryAuditLogCreateOrConnectWithoutStoryInput[]
    upsert?: StoryAuditLogUpsertWithWhereUniqueWithoutStoryInput | StoryAuditLogUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryAuditLogCreateManyStoryInputEnvelope
    set?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    disconnect?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    delete?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    connect?: StoryAuditLogWhereUniqueInput | StoryAuditLogWhereUniqueInput[]
    update?: StoryAuditLogUpdateWithWhereUniqueWithoutStoryInput | StoryAuditLogUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryAuditLogUpdateManyWithWhereWithoutStoryInput | StoryAuditLogUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryAuditLogScalarWhereInput | StoryAuditLogScalarWhereInput[]
  }

  export type StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryInteractionCreateWithoutStoryInput, StoryInteractionUncheckedCreateWithoutStoryInput> | StoryInteractionCreateWithoutStoryInput[] | StoryInteractionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutStoryInput | StoryInteractionCreateOrConnectWithoutStoryInput[]
    upsert?: StoryInteractionUpsertWithWhereUniqueWithoutStoryInput | StoryInteractionUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryInteractionCreateManyStoryInputEnvelope
    set?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    disconnect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    delete?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    update?: StoryInteractionUpdateWithWhereUniqueWithoutStoryInput | StoryInteractionUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryInteractionUpdateManyWithWhereWithoutStoryInput | StoryInteractionUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryInteractionScalarWhereInput | StoryInteractionScalarWhereInput[]
  }

  export type TwineStoryCreateNestedOneWithoutVersionsInput = {
    create?: XOR<TwineStoryCreateWithoutVersionsInput, TwineStoryUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutVersionsInput
    connect?: TwineStoryWhereUniqueInput
  }

  export type TwineStoryCreateNestedOneWithoutLatestVersionInput = {
    create?: XOR<TwineStoryCreateWithoutLatestVersionInput, TwineStoryUncheckedCreateWithoutLatestVersionInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutLatestVersionInput
    connect?: TwineStoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuthoredVersionsInput = {
    create?: XOR<UserCreateWithoutAuthoredVersionsInput, UserUncheckedCreateWithoutAuthoredVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthoredVersionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedVersionsInput = {
    create?: XOR<UserCreateWithoutReviewedVersionsInput, UserUncheckedCreateWithoutReviewedVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedVersionsInput
    connect?: UserWhereUniqueInput
  }

  export type StoryReviewCreateNestedManyWithoutVersionInput = {
    create?: XOR<StoryReviewCreateWithoutVersionInput, StoryReviewUncheckedCreateWithoutVersionInput> | StoryReviewCreateWithoutVersionInput[] | StoryReviewUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: StoryReviewCreateOrConnectWithoutVersionInput | StoryReviewCreateOrConnectWithoutVersionInput[]
    createMany?: StoryReviewCreateManyVersionInputEnvelope
    connect?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
  }

  export type StoryPlaySessionCreateNestedManyWithoutVersionInput = {
    create?: XOR<StoryPlaySessionCreateWithoutVersionInput, StoryPlaySessionUncheckedCreateWithoutVersionInput> | StoryPlaySessionCreateWithoutVersionInput[] | StoryPlaySessionUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutVersionInput | StoryPlaySessionCreateOrConnectWithoutVersionInput[]
    createMany?: StoryPlaySessionCreateManyVersionInputEnvelope
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
  }

  export type TwineStoryUncheckedCreateNestedOneWithoutLatestVersionInput = {
    create?: XOR<TwineStoryCreateWithoutLatestVersionInput, TwineStoryUncheckedCreateWithoutLatestVersionInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutLatestVersionInput
    connect?: TwineStoryWhereUniqueInput
  }

  export type StoryReviewUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<StoryReviewCreateWithoutVersionInput, StoryReviewUncheckedCreateWithoutVersionInput> | StoryReviewCreateWithoutVersionInput[] | StoryReviewUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: StoryReviewCreateOrConnectWithoutVersionInput | StoryReviewCreateOrConnectWithoutVersionInput[]
    createMany?: StoryReviewCreateManyVersionInputEnvelope
    connect?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
  }

  export type StoryPlaySessionUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<StoryPlaySessionCreateWithoutVersionInput, StoryPlaySessionUncheckedCreateWithoutVersionInput> | StoryPlaySessionCreateWithoutVersionInput[] | StoryPlaySessionUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutVersionInput | StoryPlaySessionCreateOrConnectWithoutVersionInput[]
    createMany?: StoryPlaySessionCreateManyVersionInputEnvelope
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
  }

  export type EnumStoryStatusFieldUpdateOperationsInput = {
    set?: $Enums.StoryStatus
  }

  export type TwineStoryUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<TwineStoryCreateWithoutVersionsInput, TwineStoryUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutVersionsInput
    upsert?: TwineStoryUpsertWithoutVersionsInput
    connect?: TwineStoryWhereUniqueInput
    update?: XOR<XOR<TwineStoryUpdateToOneWithWhereWithoutVersionsInput, TwineStoryUpdateWithoutVersionsInput>, TwineStoryUncheckedUpdateWithoutVersionsInput>
  }

  export type TwineStoryUpdateOneWithoutLatestVersionNestedInput = {
    create?: XOR<TwineStoryCreateWithoutLatestVersionInput, TwineStoryUncheckedCreateWithoutLatestVersionInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutLatestVersionInput
    upsert?: TwineStoryUpsertWithoutLatestVersionInput
    disconnect?: TwineStoryWhereInput | boolean
    delete?: TwineStoryWhereInput | boolean
    connect?: TwineStoryWhereUniqueInput
    update?: XOR<XOR<TwineStoryUpdateToOneWithWhereWithoutLatestVersionInput, TwineStoryUpdateWithoutLatestVersionInput>, TwineStoryUncheckedUpdateWithoutLatestVersionInput>
  }

  export type UserUpdateOneWithoutAuthoredVersionsNestedInput = {
    create?: XOR<UserCreateWithoutAuthoredVersionsInput, UserUncheckedCreateWithoutAuthoredVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthoredVersionsInput
    upsert?: UserUpsertWithoutAuthoredVersionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthoredVersionsInput, UserUpdateWithoutAuthoredVersionsInput>, UserUncheckedUpdateWithoutAuthoredVersionsInput>
  }

  export type UserUpdateOneWithoutReviewedVersionsNestedInput = {
    create?: XOR<UserCreateWithoutReviewedVersionsInput, UserUncheckedCreateWithoutReviewedVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedVersionsInput
    upsert?: UserUpsertWithoutReviewedVersionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedVersionsInput, UserUpdateWithoutReviewedVersionsInput>, UserUncheckedUpdateWithoutReviewedVersionsInput>
  }

  export type StoryReviewUpdateManyWithoutVersionNestedInput = {
    create?: XOR<StoryReviewCreateWithoutVersionInput, StoryReviewUncheckedCreateWithoutVersionInput> | StoryReviewCreateWithoutVersionInput[] | StoryReviewUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: StoryReviewCreateOrConnectWithoutVersionInput | StoryReviewCreateOrConnectWithoutVersionInput[]
    upsert?: StoryReviewUpsertWithWhereUniqueWithoutVersionInput | StoryReviewUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: StoryReviewCreateManyVersionInputEnvelope
    set?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    disconnect?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    delete?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    connect?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    update?: StoryReviewUpdateWithWhereUniqueWithoutVersionInput | StoryReviewUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: StoryReviewUpdateManyWithWhereWithoutVersionInput | StoryReviewUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: StoryReviewScalarWhereInput | StoryReviewScalarWhereInput[]
  }

  export type StoryPlaySessionUpdateManyWithoutVersionNestedInput = {
    create?: XOR<StoryPlaySessionCreateWithoutVersionInput, StoryPlaySessionUncheckedCreateWithoutVersionInput> | StoryPlaySessionCreateWithoutVersionInput[] | StoryPlaySessionUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutVersionInput | StoryPlaySessionCreateOrConnectWithoutVersionInput[]
    upsert?: StoryPlaySessionUpsertWithWhereUniqueWithoutVersionInput | StoryPlaySessionUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: StoryPlaySessionCreateManyVersionInputEnvelope
    set?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    disconnect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    delete?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    update?: StoryPlaySessionUpdateWithWhereUniqueWithoutVersionInput | StoryPlaySessionUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: StoryPlaySessionUpdateManyWithWhereWithoutVersionInput | StoryPlaySessionUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: StoryPlaySessionScalarWhereInput | StoryPlaySessionScalarWhereInput[]
  }

  export type TwineStoryUncheckedUpdateOneWithoutLatestVersionNestedInput = {
    create?: XOR<TwineStoryCreateWithoutLatestVersionInput, TwineStoryUncheckedCreateWithoutLatestVersionInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutLatestVersionInput
    upsert?: TwineStoryUpsertWithoutLatestVersionInput
    disconnect?: TwineStoryWhereInput | boolean
    delete?: TwineStoryWhereInput | boolean
    connect?: TwineStoryWhereUniqueInput
    update?: XOR<XOR<TwineStoryUpdateToOneWithWhereWithoutLatestVersionInput, TwineStoryUpdateWithoutLatestVersionInput>, TwineStoryUncheckedUpdateWithoutLatestVersionInput>
  }

  export type StoryReviewUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<StoryReviewCreateWithoutVersionInput, StoryReviewUncheckedCreateWithoutVersionInput> | StoryReviewCreateWithoutVersionInput[] | StoryReviewUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: StoryReviewCreateOrConnectWithoutVersionInput | StoryReviewCreateOrConnectWithoutVersionInput[]
    upsert?: StoryReviewUpsertWithWhereUniqueWithoutVersionInput | StoryReviewUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: StoryReviewCreateManyVersionInputEnvelope
    set?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    disconnect?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    delete?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    connect?: StoryReviewWhereUniqueInput | StoryReviewWhereUniqueInput[]
    update?: StoryReviewUpdateWithWhereUniqueWithoutVersionInput | StoryReviewUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: StoryReviewUpdateManyWithWhereWithoutVersionInput | StoryReviewUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: StoryReviewScalarWhereInput | StoryReviewScalarWhereInput[]
  }

  export type StoryPlaySessionUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<StoryPlaySessionCreateWithoutVersionInput, StoryPlaySessionUncheckedCreateWithoutVersionInput> | StoryPlaySessionCreateWithoutVersionInput[] | StoryPlaySessionUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: StoryPlaySessionCreateOrConnectWithoutVersionInput | StoryPlaySessionCreateOrConnectWithoutVersionInput[]
    upsert?: StoryPlaySessionUpsertWithWhereUniqueWithoutVersionInput | StoryPlaySessionUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: StoryPlaySessionCreateManyVersionInputEnvelope
    set?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    disconnect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    delete?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    connect?: StoryPlaySessionWhereUniqueInput | StoryPlaySessionWhereUniqueInput[]
    update?: StoryPlaySessionUpdateWithWhereUniqueWithoutVersionInput | StoryPlaySessionUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: StoryPlaySessionUpdateManyWithWhereWithoutVersionInput | StoryPlaySessionUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: StoryPlaySessionScalarWhereInput | StoryPlaySessionScalarWhereInput[]
  }

  export type TwineStoryCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<TwineStoryCreateWithoutAuditLogsInput, TwineStoryUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutAuditLogsInput
    connect?: TwineStoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStoryAuditLogsInput = {
    create?: XOR<UserCreateWithoutStoryAuditLogsInput, UserUncheckedCreateWithoutStoryAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoryAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type TwineStoryUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<TwineStoryCreateWithoutAuditLogsInput, TwineStoryUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutAuditLogsInput
    upsert?: TwineStoryUpsertWithoutAuditLogsInput
    connect?: TwineStoryWhereUniqueInput
    update?: XOR<XOR<TwineStoryUpdateToOneWithWhereWithoutAuditLogsInput, TwineStoryUpdateWithoutAuditLogsInput>, TwineStoryUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneWithoutStoryAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutStoryAuditLogsInput, UserUncheckedCreateWithoutStoryAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoryAuditLogsInput
    upsert?: UserUpsertWithoutStoryAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoryAuditLogsInput, UserUpdateWithoutStoryAuditLogsInput>, UserUncheckedUpdateWithoutStoryAuditLogsInput>
  }

  export type StoryVersionCreateNestedOneWithoutReviewsInput = {
    create?: XOR<StoryVersionCreateWithoutReviewsInput, StoryVersionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: StoryVersionCreateOrConnectWithoutReviewsInput
    connect?: StoryVersionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type StoryVersionUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<StoryVersionCreateWithoutReviewsInput, StoryVersionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: StoryVersionCreateOrConnectWithoutReviewsInput
    upsert?: StoryVersionUpsertWithoutReviewsInput
    connect?: StoryVersionWhereUniqueInput
    update?: XOR<XOR<StoryVersionUpdateToOneWithWhereWithoutReviewsInput, StoryVersionUpdateWithoutReviewsInput>, StoryVersionUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type TwineStoryCreateNestedOneWithoutPlaySessionsInput = {
    create?: XOR<TwineStoryCreateWithoutPlaySessionsInput, TwineStoryUncheckedCreateWithoutPlaySessionsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutPlaySessionsInput
    connect?: TwineStoryWhereUniqueInput
  }

  export type StoryVersionCreateNestedOneWithoutPlaySessionsInput = {
    create?: XOR<StoryVersionCreateWithoutPlaySessionsInput, StoryVersionUncheckedCreateWithoutPlaySessionsInput>
    connectOrCreate?: StoryVersionCreateOrConnectWithoutPlaySessionsInput
    connect?: StoryVersionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStoryPlaysInput = {
    create?: XOR<UserCreateWithoutStoryPlaysInput, UserUncheckedCreateWithoutStoryPlaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoryPlaysInput
    connect?: UserWhereUniqueInput
  }

  export type UserSessionCreateNestedOneWithoutStoryPlaysInput = {
    create?: XOR<UserSessionCreateWithoutStoryPlaysInput, UserSessionUncheckedCreateWithoutStoryPlaysInput>
    connectOrCreate?: UserSessionCreateOrConnectWithoutStoryPlaysInput
    connect?: UserSessionWhereUniqueInput
  }

  export type TwineStoryUpdateOneRequiredWithoutPlaySessionsNestedInput = {
    create?: XOR<TwineStoryCreateWithoutPlaySessionsInput, TwineStoryUncheckedCreateWithoutPlaySessionsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutPlaySessionsInput
    upsert?: TwineStoryUpsertWithoutPlaySessionsInput
    connect?: TwineStoryWhereUniqueInput
    update?: XOR<XOR<TwineStoryUpdateToOneWithWhereWithoutPlaySessionsInput, TwineStoryUpdateWithoutPlaySessionsInput>, TwineStoryUncheckedUpdateWithoutPlaySessionsInput>
  }

  export type StoryVersionUpdateOneWithoutPlaySessionsNestedInput = {
    create?: XOR<StoryVersionCreateWithoutPlaySessionsInput, StoryVersionUncheckedCreateWithoutPlaySessionsInput>
    connectOrCreate?: StoryVersionCreateOrConnectWithoutPlaySessionsInput
    upsert?: StoryVersionUpsertWithoutPlaySessionsInput
    disconnect?: StoryVersionWhereInput | boolean
    delete?: StoryVersionWhereInput | boolean
    connect?: StoryVersionWhereUniqueInput
    update?: XOR<XOR<StoryVersionUpdateToOneWithWhereWithoutPlaySessionsInput, StoryVersionUpdateWithoutPlaySessionsInput>, StoryVersionUncheckedUpdateWithoutPlaySessionsInput>
  }

  export type UserUpdateOneWithoutStoryPlaysNestedInput = {
    create?: XOR<UserCreateWithoutStoryPlaysInput, UserUncheckedCreateWithoutStoryPlaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoryPlaysInput
    upsert?: UserUpsertWithoutStoryPlaysInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoryPlaysInput, UserUpdateWithoutStoryPlaysInput>, UserUncheckedUpdateWithoutStoryPlaysInput>
  }

  export type UserSessionUpdateOneWithoutStoryPlaysNestedInput = {
    create?: XOR<UserSessionCreateWithoutStoryPlaysInput, UserSessionUncheckedCreateWithoutStoryPlaysInput>
    connectOrCreate?: UserSessionCreateOrConnectWithoutStoryPlaysInput
    upsert?: UserSessionUpsertWithoutStoryPlaysInput
    disconnect?: UserSessionWhereInput | boolean
    delete?: UserSessionWhereInput | boolean
    connect?: UserSessionWhereUniqueInput
    update?: XOR<XOR<UserSessionUpdateToOneWithWhereWithoutStoryPlaysInput, UserSessionUpdateWithoutStoryPlaysInput>, UserSessionUncheckedUpdateWithoutStoryPlaysInput>
  }

  export type TwineStoryCreateNestedOneWithoutNodesInput = {
    create?: XOR<TwineStoryCreateWithoutNodesInput, TwineStoryUncheckedCreateWithoutNodesInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutNodesInput
    connect?: TwineStoryWhereUniqueInput
  }

  export type StoryTransitionCreateNestedManyWithoutFromNodeInput = {
    create?: XOR<StoryTransitionCreateWithoutFromNodeInput, StoryTransitionUncheckedCreateWithoutFromNodeInput> | StoryTransitionCreateWithoutFromNodeInput[] | StoryTransitionUncheckedCreateWithoutFromNodeInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutFromNodeInput | StoryTransitionCreateOrConnectWithoutFromNodeInput[]
    createMany?: StoryTransitionCreateManyFromNodeInputEnvelope
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
  }

  export type StoryTransitionCreateNestedManyWithoutToNodeInput = {
    create?: XOR<StoryTransitionCreateWithoutToNodeInput, StoryTransitionUncheckedCreateWithoutToNodeInput> | StoryTransitionCreateWithoutToNodeInput[] | StoryTransitionUncheckedCreateWithoutToNodeInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutToNodeInput | StoryTransitionCreateOrConnectWithoutToNodeInput[]
    createMany?: StoryTransitionCreateManyToNodeInputEnvelope
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
  }

  export type StoryTransitionUncheckedCreateNestedManyWithoutFromNodeInput = {
    create?: XOR<StoryTransitionCreateWithoutFromNodeInput, StoryTransitionUncheckedCreateWithoutFromNodeInput> | StoryTransitionCreateWithoutFromNodeInput[] | StoryTransitionUncheckedCreateWithoutFromNodeInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutFromNodeInput | StoryTransitionCreateOrConnectWithoutFromNodeInput[]
    createMany?: StoryTransitionCreateManyFromNodeInputEnvelope
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
  }

  export type StoryTransitionUncheckedCreateNestedManyWithoutToNodeInput = {
    create?: XOR<StoryTransitionCreateWithoutToNodeInput, StoryTransitionUncheckedCreateWithoutToNodeInput> | StoryTransitionCreateWithoutToNodeInput[] | StoryTransitionUncheckedCreateWithoutToNodeInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutToNodeInput | StoryTransitionCreateOrConnectWithoutToNodeInput[]
    createMany?: StoryTransitionCreateManyToNodeInputEnvelope
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
  }

  export type EnumStoryNodeTypeFieldUpdateOperationsInput = {
    set?: $Enums.StoryNodeType
  }

  export type TwineStoryUpdateOneRequiredWithoutNodesNestedInput = {
    create?: XOR<TwineStoryCreateWithoutNodesInput, TwineStoryUncheckedCreateWithoutNodesInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutNodesInput
    upsert?: TwineStoryUpsertWithoutNodesInput
    connect?: TwineStoryWhereUniqueInput
    update?: XOR<XOR<TwineStoryUpdateToOneWithWhereWithoutNodesInput, TwineStoryUpdateWithoutNodesInput>, TwineStoryUncheckedUpdateWithoutNodesInput>
  }

  export type StoryTransitionUpdateManyWithoutFromNodeNestedInput = {
    create?: XOR<StoryTransitionCreateWithoutFromNodeInput, StoryTransitionUncheckedCreateWithoutFromNodeInput> | StoryTransitionCreateWithoutFromNodeInput[] | StoryTransitionUncheckedCreateWithoutFromNodeInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutFromNodeInput | StoryTransitionCreateOrConnectWithoutFromNodeInput[]
    upsert?: StoryTransitionUpsertWithWhereUniqueWithoutFromNodeInput | StoryTransitionUpsertWithWhereUniqueWithoutFromNodeInput[]
    createMany?: StoryTransitionCreateManyFromNodeInputEnvelope
    set?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    disconnect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    delete?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    update?: StoryTransitionUpdateWithWhereUniqueWithoutFromNodeInput | StoryTransitionUpdateWithWhereUniqueWithoutFromNodeInput[]
    updateMany?: StoryTransitionUpdateManyWithWhereWithoutFromNodeInput | StoryTransitionUpdateManyWithWhereWithoutFromNodeInput[]
    deleteMany?: StoryTransitionScalarWhereInput | StoryTransitionScalarWhereInput[]
  }

  export type StoryTransitionUpdateManyWithoutToNodeNestedInput = {
    create?: XOR<StoryTransitionCreateWithoutToNodeInput, StoryTransitionUncheckedCreateWithoutToNodeInput> | StoryTransitionCreateWithoutToNodeInput[] | StoryTransitionUncheckedCreateWithoutToNodeInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutToNodeInput | StoryTransitionCreateOrConnectWithoutToNodeInput[]
    upsert?: StoryTransitionUpsertWithWhereUniqueWithoutToNodeInput | StoryTransitionUpsertWithWhereUniqueWithoutToNodeInput[]
    createMany?: StoryTransitionCreateManyToNodeInputEnvelope
    set?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    disconnect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    delete?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    update?: StoryTransitionUpdateWithWhereUniqueWithoutToNodeInput | StoryTransitionUpdateWithWhereUniqueWithoutToNodeInput[]
    updateMany?: StoryTransitionUpdateManyWithWhereWithoutToNodeInput | StoryTransitionUpdateManyWithWhereWithoutToNodeInput[]
    deleteMany?: StoryTransitionScalarWhereInput | StoryTransitionScalarWhereInput[]
  }

  export type StoryTransitionUncheckedUpdateManyWithoutFromNodeNestedInput = {
    create?: XOR<StoryTransitionCreateWithoutFromNodeInput, StoryTransitionUncheckedCreateWithoutFromNodeInput> | StoryTransitionCreateWithoutFromNodeInput[] | StoryTransitionUncheckedCreateWithoutFromNodeInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutFromNodeInput | StoryTransitionCreateOrConnectWithoutFromNodeInput[]
    upsert?: StoryTransitionUpsertWithWhereUniqueWithoutFromNodeInput | StoryTransitionUpsertWithWhereUniqueWithoutFromNodeInput[]
    createMany?: StoryTransitionCreateManyFromNodeInputEnvelope
    set?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    disconnect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    delete?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    update?: StoryTransitionUpdateWithWhereUniqueWithoutFromNodeInput | StoryTransitionUpdateWithWhereUniqueWithoutFromNodeInput[]
    updateMany?: StoryTransitionUpdateManyWithWhereWithoutFromNodeInput | StoryTransitionUpdateManyWithWhereWithoutFromNodeInput[]
    deleteMany?: StoryTransitionScalarWhereInput | StoryTransitionScalarWhereInput[]
  }

  export type StoryTransitionUncheckedUpdateManyWithoutToNodeNestedInput = {
    create?: XOR<StoryTransitionCreateWithoutToNodeInput, StoryTransitionUncheckedCreateWithoutToNodeInput> | StoryTransitionCreateWithoutToNodeInput[] | StoryTransitionUncheckedCreateWithoutToNodeInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutToNodeInput | StoryTransitionCreateOrConnectWithoutToNodeInput[]
    upsert?: StoryTransitionUpsertWithWhereUniqueWithoutToNodeInput | StoryTransitionUpsertWithWhereUniqueWithoutToNodeInput[]
    createMany?: StoryTransitionCreateManyToNodeInputEnvelope
    set?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    disconnect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    delete?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    update?: StoryTransitionUpdateWithWhereUniqueWithoutToNodeInput | StoryTransitionUpdateWithWhereUniqueWithoutToNodeInput[]
    updateMany?: StoryTransitionUpdateManyWithWhereWithoutToNodeInput | StoryTransitionUpdateManyWithWhereWithoutToNodeInput[]
    deleteMany?: StoryTransitionScalarWhereInput | StoryTransitionScalarWhereInput[]
  }

  export type TwineStoryCreateNestedOneWithoutPathsInput = {
    create?: XOR<TwineStoryCreateWithoutPathsInput, TwineStoryUncheckedCreateWithoutPathsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutPathsInput
    connect?: TwineStoryWhereUniqueInput
  }

  export type StoryTransitionCreateNestedManyWithoutPathInput = {
    create?: XOR<StoryTransitionCreateWithoutPathInput, StoryTransitionUncheckedCreateWithoutPathInput> | StoryTransitionCreateWithoutPathInput[] | StoryTransitionUncheckedCreateWithoutPathInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutPathInput | StoryTransitionCreateOrConnectWithoutPathInput[]
    createMany?: StoryTransitionCreateManyPathInputEnvelope
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
  }

  export type StoryTransitionUncheckedCreateNestedManyWithoutPathInput = {
    create?: XOR<StoryTransitionCreateWithoutPathInput, StoryTransitionUncheckedCreateWithoutPathInput> | StoryTransitionCreateWithoutPathInput[] | StoryTransitionUncheckedCreateWithoutPathInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutPathInput | StoryTransitionCreateOrConnectWithoutPathInput[]
    createMany?: StoryTransitionCreateManyPathInputEnvelope
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
  }

  export type TwineStoryUpdateOneRequiredWithoutPathsNestedInput = {
    create?: XOR<TwineStoryCreateWithoutPathsInput, TwineStoryUncheckedCreateWithoutPathsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutPathsInput
    upsert?: TwineStoryUpsertWithoutPathsInput
    connect?: TwineStoryWhereUniqueInput
    update?: XOR<XOR<TwineStoryUpdateToOneWithWhereWithoutPathsInput, TwineStoryUpdateWithoutPathsInput>, TwineStoryUncheckedUpdateWithoutPathsInput>
  }

  export type StoryTransitionUpdateManyWithoutPathNestedInput = {
    create?: XOR<StoryTransitionCreateWithoutPathInput, StoryTransitionUncheckedCreateWithoutPathInput> | StoryTransitionCreateWithoutPathInput[] | StoryTransitionUncheckedCreateWithoutPathInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutPathInput | StoryTransitionCreateOrConnectWithoutPathInput[]
    upsert?: StoryTransitionUpsertWithWhereUniqueWithoutPathInput | StoryTransitionUpsertWithWhereUniqueWithoutPathInput[]
    createMany?: StoryTransitionCreateManyPathInputEnvelope
    set?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    disconnect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    delete?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    update?: StoryTransitionUpdateWithWhereUniqueWithoutPathInput | StoryTransitionUpdateWithWhereUniqueWithoutPathInput[]
    updateMany?: StoryTransitionUpdateManyWithWhereWithoutPathInput | StoryTransitionUpdateManyWithWhereWithoutPathInput[]
    deleteMany?: StoryTransitionScalarWhereInput | StoryTransitionScalarWhereInput[]
  }

  export type StoryTransitionUncheckedUpdateManyWithoutPathNestedInput = {
    create?: XOR<StoryTransitionCreateWithoutPathInput, StoryTransitionUncheckedCreateWithoutPathInput> | StoryTransitionCreateWithoutPathInput[] | StoryTransitionUncheckedCreateWithoutPathInput[]
    connectOrCreate?: StoryTransitionCreateOrConnectWithoutPathInput | StoryTransitionCreateOrConnectWithoutPathInput[]
    upsert?: StoryTransitionUpsertWithWhereUniqueWithoutPathInput | StoryTransitionUpsertWithWhereUniqueWithoutPathInput[]
    createMany?: StoryTransitionCreateManyPathInputEnvelope
    set?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    disconnect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    delete?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    connect?: StoryTransitionWhereUniqueInput | StoryTransitionWhereUniqueInput[]
    update?: StoryTransitionUpdateWithWhereUniqueWithoutPathInput | StoryTransitionUpdateWithWhereUniqueWithoutPathInput[]
    updateMany?: StoryTransitionUpdateManyWithWhereWithoutPathInput | StoryTransitionUpdateManyWithWhereWithoutPathInput[]
    deleteMany?: StoryTransitionScalarWhereInput | StoryTransitionScalarWhereInput[]
  }

  export type TwineStoryCreateNestedOneWithoutTransitionsInput = {
    create?: XOR<TwineStoryCreateWithoutTransitionsInput, TwineStoryUncheckedCreateWithoutTransitionsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutTransitionsInput
    connect?: TwineStoryWhereUniqueInput
  }

  export type StoryNodeCreateNestedOneWithoutOutgoingInput = {
    create?: XOR<StoryNodeCreateWithoutOutgoingInput, StoryNodeUncheckedCreateWithoutOutgoingInput>
    connectOrCreate?: StoryNodeCreateOrConnectWithoutOutgoingInput
    connect?: StoryNodeWhereUniqueInput
  }

  export type StoryNodeCreateNestedOneWithoutIncomingInput = {
    create?: XOR<StoryNodeCreateWithoutIncomingInput, StoryNodeUncheckedCreateWithoutIncomingInput>
    connectOrCreate?: StoryNodeCreateOrConnectWithoutIncomingInput
    connect?: StoryNodeWhereUniqueInput
  }

  export type StoryPathCreateNestedOneWithoutTransitionsInput = {
    create?: XOR<StoryPathCreateWithoutTransitionsInput, StoryPathUncheckedCreateWithoutTransitionsInput>
    connectOrCreate?: StoryPathCreateOrConnectWithoutTransitionsInput
    connect?: StoryPathWhereUniqueInput
  }

  export type TwineStoryUpdateOneRequiredWithoutTransitionsNestedInput = {
    create?: XOR<TwineStoryCreateWithoutTransitionsInput, TwineStoryUncheckedCreateWithoutTransitionsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutTransitionsInput
    upsert?: TwineStoryUpsertWithoutTransitionsInput
    connect?: TwineStoryWhereUniqueInput
    update?: XOR<XOR<TwineStoryUpdateToOneWithWhereWithoutTransitionsInput, TwineStoryUpdateWithoutTransitionsInput>, TwineStoryUncheckedUpdateWithoutTransitionsInput>
  }

  export type StoryNodeUpdateOneRequiredWithoutOutgoingNestedInput = {
    create?: XOR<StoryNodeCreateWithoutOutgoingInput, StoryNodeUncheckedCreateWithoutOutgoingInput>
    connectOrCreate?: StoryNodeCreateOrConnectWithoutOutgoingInput
    upsert?: StoryNodeUpsertWithoutOutgoingInput
    connect?: StoryNodeWhereUniqueInput
    update?: XOR<XOR<StoryNodeUpdateToOneWithWhereWithoutOutgoingInput, StoryNodeUpdateWithoutOutgoingInput>, StoryNodeUncheckedUpdateWithoutOutgoingInput>
  }

  export type StoryNodeUpdateOneWithoutIncomingNestedInput = {
    create?: XOR<StoryNodeCreateWithoutIncomingInput, StoryNodeUncheckedCreateWithoutIncomingInput>
    connectOrCreate?: StoryNodeCreateOrConnectWithoutIncomingInput
    upsert?: StoryNodeUpsertWithoutIncomingInput
    disconnect?: StoryNodeWhereInput | boolean
    delete?: StoryNodeWhereInput | boolean
    connect?: StoryNodeWhereUniqueInput
    update?: XOR<XOR<StoryNodeUpdateToOneWithWhereWithoutIncomingInput, StoryNodeUpdateWithoutIncomingInput>, StoryNodeUncheckedUpdateWithoutIncomingInput>
  }

  export type StoryPathUpdateOneRequiredWithoutTransitionsNestedInput = {
    create?: XOR<StoryPathCreateWithoutTransitionsInput, StoryPathUncheckedCreateWithoutTransitionsInput>
    connectOrCreate?: StoryPathCreateOrConnectWithoutTransitionsInput
    upsert?: StoryPathUpsertWithoutTransitionsInput
    connect?: StoryPathWhereUniqueInput
    update?: XOR<XOR<StoryPathUpdateToOneWithWhereWithoutTransitionsInput, StoryPathUpdateWithoutTransitionsInput>, StoryPathUncheckedUpdateWithoutTransitionsInput>
  }

  export type TwineStoryCreateNestedOneWithoutAvatarsInput = {
    create?: XOR<TwineStoryCreateWithoutAvatarsInput, TwineStoryUncheckedCreateWithoutAvatarsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutAvatarsInput
    connect?: TwineStoryWhereUniqueInput
  }

  export type StoryInteractionCreateNestedManyWithoutAvatarInput = {
    create?: XOR<StoryInteractionCreateWithoutAvatarInput, StoryInteractionUncheckedCreateWithoutAvatarInput> | StoryInteractionCreateWithoutAvatarInput[] | StoryInteractionUncheckedCreateWithoutAvatarInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutAvatarInput | StoryInteractionCreateOrConnectWithoutAvatarInput[]
    createMany?: StoryInteractionCreateManyAvatarInputEnvelope
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
  }

  export type StoryInteractionUncheckedCreateNestedManyWithoutAvatarInput = {
    create?: XOR<StoryInteractionCreateWithoutAvatarInput, StoryInteractionUncheckedCreateWithoutAvatarInput> | StoryInteractionCreateWithoutAvatarInput[] | StoryInteractionUncheckedCreateWithoutAvatarInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutAvatarInput | StoryInteractionCreateOrConnectWithoutAvatarInput[]
    createMany?: StoryInteractionCreateManyAvatarInputEnvelope
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
  }

  export type TwineStoryUpdateOneWithoutAvatarsNestedInput = {
    create?: XOR<TwineStoryCreateWithoutAvatarsInput, TwineStoryUncheckedCreateWithoutAvatarsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutAvatarsInput
    upsert?: TwineStoryUpsertWithoutAvatarsInput
    disconnect?: TwineStoryWhereInput | boolean
    delete?: TwineStoryWhereInput | boolean
    connect?: TwineStoryWhereUniqueInput
    update?: XOR<XOR<TwineStoryUpdateToOneWithWhereWithoutAvatarsInput, TwineStoryUpdateWithoutAvatarsInput>, TwineStoryUncheckedUpdateWithoutAvatarsInput>
  }

  export type StoryInteractionUpdateManyWithoutAvatarNestedInput = {
    create?: XOR<StoryInteractionCreateWithoutAvatarInput, StoryInteractionUncheckedCreateWithoutAvatarInput> | StoryInteractionCreateWithoutAvatarInput[] | StoryInteractionUncheckedCreateWithoutAvatarInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutAvatarInput | StoryInteractionCreateOrConnectWithoutAvatarInput[]
    upsert?: StoryInteractionUpsertWithWhereUniqueWithoutAvatarInput | StoryInteractionUpsertWithWhereUniqueWithoutAvatarInput[]
    createMany?: StoryInteractionCreateManyAvatarInputEnvelope
    set?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    disconnect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    delete?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    update?: StoryInteractionUpdateWithWhereUniqueWithoutAvatarInput | StoryInteractionUpdateWithWhereUniqueWithoutAvatarInput[]
    updateMany?: StoryInteractionUpdateManyWithWhereWithoutAvatarInput | StoryInteractionUpdateManyWithWhereWithoutAvatarInput[]
    deleteMany?: StoryInteractionScalarWhereInput | StoryInteractionScalarWhereInput[]
  }

  export type StoryInteractionUncheckedUpdateManyWithoutAvatarNestedInput = {
    create?: XOR<StoryInteractionCreateWithoutAvatarInput, StoryInteractionUncheckedCreateWithoutAvatarInput> | StoryInteractionCreateWithoutAvatarInput[] | StoryInteractionUncheckedCreateWithoutAvatarInput[]
    connectOrCreate?: StoryInteractionCreateOrConnectWithoutAvatarInput | StoryInteractionCreateOrConnectWithoutAvatarInput[]
    upsert?: StoryInteractionUpsertWithWhereUniqueWithoutAvatarInput | StoryInteractionUpsertWithWhereUniqueWithoutAvatarInput[]
    createMany?: StoryInteractionCreateManyAvatarInputEnvelope
    set?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    disconnect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    delete?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    connect?: StoryInteractionWhereUniqueInput | StoryInteractionWhereUniqueInput[]
    update?: StoryInteractionUpdateWithWhereUniqueWithoutAvatarInput | StoryInteractionUpdateWithWhereUniqueWithoutAvatarInput[]
    updateMany?: StoryInteractionUpdateManyWithWhereWithoutAvatarInput | StoryInteractionUpdateManyWithWhereWithoutAvatarInput[]
    deleteMany?: StoryInteractionScalarWhereInput | StoryInteractionScalarWhereInput[]
  }

  export type AvatarProfileCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<AvatarProfileCreateWithoutInteractionsInput, AvatarProfileUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: AvatarProfileCreateOrConnectWithoutInteractionsInput
    connect?: AvatarProfileWhereUniqueInput
  }

  export type TwineStoryCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<TwineStoryCreateWithoutInteractionsInput, TwineStoryUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutInteractionsInput
    connect?: TwineStoryWhereUniqueInput
  }

  export type UserSessionCreateNestedOneWithoutStoryInteractionsInput = {
    create?: XOR<UserSessionCreateWithoutStoryInteractionsInput, UserSessionUncheckedCreateWithoutStoryInteractionsInput>
    connectOrCreate?: UserSessionCreateOrConnectWithoutStoryInteractionsInput
    connect?: UserSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStoryInteractionsInput = {
    create?: XOR<UserCreateWithoutStoryInteractionsInput, UserUncheckedCreateWithoutStoryInteractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoryInteractionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStoryInteractionKindFieldUpdateOperationsInput = {
    set?: $Enums.StoryInteractionKind
  }

  export type AvatarProfileUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<AvatarProfileCreateWithoutInteractionsInput, AvatarProfileUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: AvatarProfileCreateOrConnectWithoutInteractionsInput
    upsert?: AvatarProfileUpsertWithoutInteractionsInput
    connect?: AvatarProfileWhereUniqueInput
    update?: XOR<XOR<AvatarProfileUpdateToOneWithWhereWithoutInteractionsInput, AvatarProfileUpdateWithoutInteractionsInput>, AvatarProfileUncheckedUpdateWithoutInteractionsInput>
  }

  export type TwineStoryUpdateOneWithoutInteractionsNestedInput = {
    create?: XOR<TwineStoryCreateWithoutInteractionsInput, TwineStoryUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: TwineStoryCreateOrConnectWithoutInteractionsInput
    upsert?: TwineStoryUpsertWithoutInteractionsInput
    disconnect?: TwineStoryWhereInput | boolean
    delete?: TwineStoryWhereInput | boolean
    connect?: TwineStoryWhereUniqueInput
    update?: XOR<XOR<TwineStoryUpdateToOneWithWhereWithoutInteractionsInput, TwineStoryUpdateWithoutInteractionsInput>, TwineStoryUncheckedUpdateWithoutInteractionsInput>
  }

  export type UserSessionUpdateOneWithoutStoryInteractionsNestedInput = {
    create?: XOR<UserSessionCreateWithoutStoryInteractionsInput, UserSessionUncheckedCreateWithoutStoryInteractionsInput>
    connectOrCreate?: UserSessionCreateOrConnectWithoutStoryInteractionsInput
    upsert?: UserSessionUpsertWithoutStoryInteractionsInput
    disconnect?: UserSessionWhereInput | boolean
    delete?: UserSessionWhereInput | boolean
    connect?: UserSessionWhereUniqueInput
    update?: XOR<XOR<UserSessionUpdateToOneWithWhereWithoutStoryInteractionsInput, UserSessionUpdateWithoutStoryInteractionsInput>, UserSessionUncheckedUpdateWithoutStoryInteractionsInput>
  }

  export type UserUpdateOneWithoutStoryInteractionsNestedInput = {
    create?: XOR<UserCreateWithoutStoryInteractionsInput, UserUncheckedCreateWithoutStoryInteractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoryInteractionsInput
    upsert?: UserUpsertWithoutStoryInteractionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoryInteractionsInput, UserUpdateWithoutStoryInteractionsInput>, UserUncheckedUpdateWithoutStoryInteractionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCreatorProfileStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatorProfileStatus | EnumCreatorProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreatorProfileStatus[] | ListEnumCreatorProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatorProfileStatus[] | ListEnumCreatorProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatorProfileStatusFilter<$PrismaModel> | $Enums.CreatorProfileStatus
  }

  export type NestedEnumCreatorProfileStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatorProfileStatus | EnumCreatorProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreatorProfileStatus[] | ListEnumCreatorProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatorProfileStatus[] | ListEnumCreatorProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatorProfileStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreatorProfileStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreatorProfileStatusFilter<$PrismaModel>
    _max?: NestedEnumCreatorProfileStatusFilter<$PrismaModel>
  }

  export type NestedEnumSessionKindFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionKind | EnumSessionKindFieldRefInput<$PrismaModel>
    in?: $Enums.SessionKind[] | ListEnumSessionKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionKind[] | ListEnumSessionKindFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionKindFilter<$PrismaModel> | $Enums.SessionKind
  }

  export type NestedEnumSessionKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionKind | EnumSessionKindFieldRefInput<$PrismaModel>
    in?: $Enums.SessionKind[] | ListEnumSessionKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionKind[] | ListEnumSessionKindFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionKindWithAggregatesFilter<$PrismaModel> | $Enums.SessionKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionKindFilter<$PrismaModel>
    _max?: NestedEnumSessionKindFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumJourneyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JourneyStatus | EnumJourneyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJourneyStatusFilter<$PrismaModel> | $Enums.JourneyStatus
  }

  export type NestedEnumJourneyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JourneyStatus | EnumJourneyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJourneyStatusWithAggregatesFilter<$PrismaModel> | $Enums.JourneyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJourneyStatusFilter<$PrismaModel>
    _max?: NestedEnumJourneyStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumStoryVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryVisibility | EnumStoryVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.StoryVisibility[] | ListEnumStoryVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryVisibility[] | ListEnumStoryVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryVisibilityFilter<$PrismaModel> | $Enums.StoryVisibility
  }

  export type NestedEnumStoryOwnershipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryOwnershipStatus | EnumStoryOwnershipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoryOwnershipStatus[] | ListEnumStoryOwnershipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryOwnershipStatus[] | ListEnumStoryOwnershipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryOwnershipStatusFilter<$PrismaModel> | $Enums.StoryOwnershipStatus
  }

  export type NestedEnumStoryVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryVisibility | EnumStoryVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.StoryVisibility[] | ListEnumStoryVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryVisibility[] | ListEnumStoryVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.StoryVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryVisibilityFilter<$PrismaModel>
    _max?: NestedEnumStoryVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumStoryOwnershipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryOwnershipStatus | EnumStoryOwnershipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoryOwnershipStatus[] | ListEnumStoryOwnershipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryOwnershipStatus[] | ListEnumStoryOwnershipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryOwnershipStatusWithAggregatesFilter<$PrismaModel> | $Enums.StoryOwnershipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryOwnershipStatusFilter<$PrismaModel>
    _max?: NestedEnumStoryOwnershipStatusFilter<$PrismaModel>
  }

  export type NestedEnumStoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryStatus | EnumStoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryStatusFilter<$PrismaModel> | $Enums.StoryStatus
  }

  export type NestedEnumStoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryStatus | EnumStoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.StoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryStatusFilter<$PrismaModel>
    _max?: NestedEnumStoryStatusFilter<$PrismaModel>
  }

  export type NestedEnumStoryNodeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryNodeType | EnumStoryNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoryNodeType[] | ListEnumStoryNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryNodeType[] | ListEnumStoryNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryNodeTypeFilter<$PrismaModel> | $Enums.StoryNodeType
  }

  export type NestedEnumStoryNodeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryNodeType | EnumStoryNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoryNodeType[] | ListEnumStoryNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryNodeType[] | ListEnumStoryNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryNodeTypeWithAggregatesFilter<$PrismaModel> | $Enums.StoryNodeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryNodeTypeFilter<$PrismaModel>
    _max?: NestedEnumStoryNodeTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumStoryInteractionKindFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryInteractionKind | EnumStoryInteractionKindFieldRefInput<$PrismaModel>
    in?: $Enums.StoryInteractionKind[] | ListEnumStoryInteractionKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryInteractionKind[] | ListEnumStoryInteractionKindFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryInteractionKindFilter<$PrismaModel> | $Enums.StoryInteractionKind
  }

  export type NestedEnumStoryInteractionKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryInteractionKind | EnumStoryInteractionKindFieldRefInput<$PrismaModel>
    in?: $Enums.StoryInteractionKind[] | ListEnumStoryInteractionKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryInteractionKind[] | ListEnumStoryInteractionKindFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryInteractionKindWithAggregatesFilter<$PrismaModel> | $Enums.StoryInteractionKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryInteractionKindFilter<$PrismaModel>
    _max?: NestedEnumStoryInteractionKindFilter<$PrismaModel>
  }

  export type UserProfileCreateWithoutUserInput = {
    id?: string
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    timezone?: string | null
    pronouns?: string | null
    location?: string | null
    publicEmail?: string | null
    websiteUrl?: string | null
    linkedinUrl?: string | null
    twitterHandle?: string | null
    instagramHandle?: string | null
    tiktokHandle?: string | null
    expertiseTags?: UserProfileCreateexpertiseTagsInput | string[]
    customLinks?: NullableJsonNullValueInput | InputJsonValue
    consentAcceptedAt?: Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: string
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    timezone?: string | null
    pronouns?: string | null
    location?: string | null
    publicEmail?: string | null
    websiteUrl?: string | null
    linkedinUrl?: string | null
    twitterHandle?: string | null
    instagramHandle?: string | null
    tiktokHandle?: string | null
    expertiseTags?: UserProfileCreateexpertiseTagsInput | string[]
    customLinks?: NullableJsonNullValueInput | InputJsonValue
    consentAcceptedAt?: Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    journeys?: JourneyProgressCreateNestedManyWithoutSessionInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutSessionInput
    achievements?: UserAchievementCreateNestedManyWithoutSessionInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutSessionInput
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutSessionInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutSessionInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutSessionInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type JourneyProgressCreateWithoutUserInput = {
    id?: string
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    scenario: ScenarioCreateNestedOneWithoutJourneysInput
    session?: UserSessionCreateNestedOneWithoutJourneysInput
    achievements?: UserAchievementCreateNestedManyWithoutJourneyInput
  }

  export type JourneyProgressUncheckedCreateWithoutUserInput = {
    id?: string
    scenarioId: string
    sessionId?: string | null
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutJourneyInput
  }

  export type JourneyProgressCreateOrConnectWithoutUserInput = {
    where: JourneyProgressWhereUniqueInput
    create: XOR<JourneyProgressCreateWithoutUserInput, JourneyProgressUncheckedCreateWithoutUserInput>
  }

  export type JourneyProgressCreateManyUserInputEnvelope = {
    data: JourneyProgressCreateManyUserInput | JourneyProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    achievement: AchievementCreateNestedOneWithoutUserAwardsInput
    session?: UserSessionCreateNestedOneWithoutAchievementsInput
    journey?: JourneyProgressCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    achievementId: string
    sessionId?: string | null
    journeyId?: string | null
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StoryPlaySessionCreateWithoutUserInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
    story: TwineStoryCreateNestedOneWithoutPlaySessionsInput
    version?: StoryVersionCreateNestedOneWithoutPlaySessionsInput
    session?: UserSessionCreateNestedOneWithoutStoryPlaysInput
  }

  export type StoryPlaySessionUncheckedCreateWithoutUserInput = {
    id?: string
    storyId: string
    versionId?: string | null
    sessionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
  }

  export type StoryPlaySessionCreateOrConnectWithoutUserInput = {
    where: StoryPlaySessionWhereUniqueInput
    create: XOR<StoryPlaySessionCreateWithoutUserInput, StoryPlaySessionUncheckedCreateWithoutUserInput>
  }

  export type StoryPlaySessionCreateManyUserInputEnvelope = {
    data: StoryPlaySessionCreateManyUserInput | StoryPlaySessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TwineStoryCreateWithoutOwnerInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutOwnerInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutOwnerInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutOwnerInput, TwineStoryUncheckedCreateWithoutOwnerInput>
  }

  export type TwineStoryCreateManyOwnerInputEnvelope = {
    data: TwineStoryCreateManyOwnerInput | TwineStoryCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type StoryVersionCreateWithoutAuthorInput = {
    id?: string
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    story: TwineStoryCreateNestedOneWithoutVersionsInput
    featuredIn?: TwineStoryCreateNestedOneWithoutLatestVersionInput
    reviewer?: UserCreateNestedOneWithoutReviewedVersionsInput
    reviews?: StoryReviewCreateNestedManyWithoutVersionInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionUncheckedCreateWithoutAuthorInput = {
    id?: string
    storyId: string
    reviewerId?: string | null
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    featuredIn?: TwineStoryUncheckedCreateNestedOneWithoutLatestVersionInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutVersionInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionCreateOrConnectWithoutAuthorInput = {
    where: StoryVersionWhereUniqueInput
    create: XOR<StoryVersionCreateWithoutAuthorInput, StoryVersionUncheckedCreateWithoutAuthorInput>
  }

  export type StoryVersionCreateManyAuthorInputEnvelope = {
    data: StoryVersionCreateManyAuthorInput | StoryVersionCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type StoryVersionCreateWithoutReviewerInput = {
    id?: string
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    story: TwineStoryCreateNestedOneWithoutVersionsInput
    featuredIn?: TwineStoryCreateNestedOneWithoutLatestVersionInput
    author?: UserCreateNestedOneWithoutAuthoredVersionsInput
    reviews?: StoryReviewCreateNestedManyWithoutVersionInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionUncheckedCreateWithoutReviewerInput = {
    id?: string
    storyId: string
    authorId?: string | null
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    featuredIn?: TwineStoryUncheckedCreateNestedOneWithoutLatestVersionInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutVersionInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionCreateOrConnectWithoutReviewerInput = {
    where: StoryVersionWhereUniqueInput
    create: XOR<StoryVersionCreateWithoutReviewerInput, StoryVersionUncheckedCreateWithoutReviewerInput>
  }

  export type StoryVersionCreateManyReviewerInputEnvelope = {
    data: StoryVersionCreateManyReviewerInput | StoryVersionCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type StoryReviewCreateWithoutReviewerInput = {
    id?: string
    status: $Enums.StoryStatus
    feedback?: string | null
    createdAt?: Date | string
    version: StoryVersionCreateNestedOneWithoutReviewsInput
  }

  export type StoryReviewUncheckedCreateWithoutReviewerInput = {
    id?: string
    versionId: string
    status: $Enums.StoryStatus
    feedback?: string | null
    createdAt?: Date | string
  }

  export type StoryReviewCreateOrConnectWithoutReviewerInput = {
    where: StoryReviewWhereUniqueInput
    create: XOR<StoryReviewCreateWithoutReviewerInput, StoryReviewUncheckedCreateWithoutReviewerInput>
  }

  export type StoryReviewCreateManyReviewerInputEnvelope = {
    data: StoryReviewCreateManyReviewerInput | StoryReviewCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type CreatorProfileCreateWithoutUserInput = {
    id?: string
    penName?: string | null
    headline?: string | null
    expertiseTags?: CreatorProfileCreateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileCreatefocusAreasInput | string[]
    languages?: CreatorProfileCreatelanguagesInput | string[]
    tagline?: string | null
    biography?: string | null
    websiteUrl?: string | null
    portfolioUrl?: string | null
    contactEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: Date | string | null
    termsAcceptedAt?: Date | string | null
    consentAcceptedAt?: Date | string | null
    consentStatement?: string | null
    status?: $Enums.CreatorProfileStatus
    completedAt?: Date | string | null
    lastReviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastReviewer?: UserCreateNestedOneWithoutReviewedCreatorProfilesInput
    storiesSubmitted?: TwineStoryCreateNestedManyWithoutOriginalCreatorProfileInput
  }

  export type CreatorProfileUncheckedCreateWithoutUserInput = {
    id?: string
    penName?: string | null
    headline?: string | null
    expertiseTags?: CreatorProfileCreateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileCreatefocusAreasInput | string[]
    languages?: CreatorProfileCreatelanguagesInput | string[]
    tagline?: string | null
    biography?: string | null
    websiteUrl?: string | null
    portfolioUrl?: string | null
    contactEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: Date | string | null
    termsAcceptedAt?: Date | string | null
    consentAcceptedAt?: Date | string | null
    consentStatement?: string | null
    status?: $Enums.CreatorProfileStatus
    completedAt?: Date | string | null
    lastReviewedAt?: Date | string | null
    lastReviewerId?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    storiesSubmitted?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorProfileInput
  }

  export type CreatorProfileCreateOrConnectWithoutUserInput = {
    where: CreatorProfileWhereUniqueInput
    create: XOR<CreatorProfileCreateWithoutUserInput, CreatorProfileUncheckedCreateWithoutUserInput>
  }

  export type TwineStoryCreateWithoutApprovedByInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutApprovedByInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutApprovedByInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutApprovedByInput, TwineStoryUncheckedCreateWithoutApprovedByInput>
  }

  export type TwineStoryCreateManyApprovedByInputEnvelope = {
    data: TwineStoryCreateManyApprovedByInput | TwineStoryCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type TwineStoryCreateWithoutOriginalCreatorInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutOriginalCreatorInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutOriginalCreatorInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutOriginalCreatorInput, TwineStoryUncheckedCreateWithoutOriginalCreatorInput>
  }

  export type TwineStoryCreateManyOriginalCreatorInputEnvelope = {
    data: TwineStoryCreateManyOriginalCreatorInput | TwineStoryCreateManyOriginalCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CreatorProfileCreateWithoutLastReviewerInput = {
    id?: string
    penName?: string | null
    headline?: string | null
    expertiseTags?: CreatorProfileCreateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileCreatefocusAreasInput | string[]
    languages?: CreatorProfileCreatelanguagesInput | string[]
    tagline?: string | null
    biography?: string | null
    websiteUrl?: string | null
    portfolioUrl?: string | null
    contactEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: Date | string | null
    termsAcceptedAt?: Date | string | null
    consentAcceptedAt?: Date | string | null
    consentStatement?: string | null
    status?: $Enums.CreatorProfileStatus
    completedAt?: Date | string | null
    lastReviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCreatorProfileInput
    storiesSubmitted?: TwineStoryCreateNestedManyWithoutOriginalCreatorProfileInput
  }

  export type CreatorProfileUncheckedCreateWithoutLastReviewerInput = {
    id?: string
    userId: string
    penName?: string | null
    headline?: string | null
    expertiseTags?: CreatorProfileCreateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileCreatefocusAreasInput | string[]
    languages?: CreatorProfileCreatelanguagesInput | string[]
    tagline?: string | null
    biography?: string | null
    websiteUrl?: string | null
    portfolioUrl?: string | null
    contactEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: Date | string | null
    termsAcceptedAt?: Date | string | null
    consentAcceptedAt?: Date | string | null
    consentStatement?: string | null
    status?: $Enums.CreatorProfileStatus
    completedAt?: Date | string | null
    lastReviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    storiesSubmitted?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorProfileInput
  }

  export type CreatorProfileCreateOrConnectWithoutLastReviewerInput = {
    where: CreatorProfileWhereUniqueInput
    create: XOR<CreatorProfileCreateWithoutLastReviewerInput, CreatorProfileUncheckedCreateWithoutLastReviewerInput>
  }

  export type CreatorProfileCreateManyLastReviewerInputEnvelope = {
    data: CreatorProfileCreateManyLastReviewerInput | CreatorProfileCreateManyLastReviewerInput[]
    skipDuplicates?: boolean
  }

  export type StoryAuditLogCreateWithoutActorInput = {
    id?: string
    action: string
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    story: TwineStoryCreateNestedOneWithoutAuditLogsInput
  }

  export type StoryAuditLogUncheckedCreateWithoutActorInput = {
    id?: string
    storyId: string
    action: string
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryAuditLogCreateOrConnectWithoutActorInput = {
    where: StoryAuditLogWhereUniqueInput
    create: XOR<StoryAuditLogCreateWithoutActorInput, StoryAuditLogUncheckedCreateWithoutActorInput>
  }

  export type StoryAuditLogCreateManyActorInputEnvelope = {
    data: StoryAuditLogCreateManyActorInput | StoryAuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type StoryInteractionCreateWithoutUserInput = {
    id?: string
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    avatar: AvatarProfileCreateNestedOneWithoutInteractionsInput
    story?: TwineStoryCreateNestedOneWithoutInteractionsInput
    session?: UserSessionCreateNestedOneWithoutStoryInteractionsInput
  }

  export type StoryInteractionUncheckedCreateWithoutUserInput = {
    id?: string
    avatarId: string
    storyId?: string | null
    sessionId?: string | null
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryInteractionCreateOrConnectWithoutUserInput = {
    where: StoryInteractionWhereUniqueInput
    create: XOR<StoryInteractionCreateWithoutUserInput, StoryInteractionUncheckedCreateWithoutUserInput>
  }

  export type StoryInteractionCreateManyUserInputEnvelope = {
    data: StoryInteractionCreateManyUserInput | StoryInteractionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    publicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    instagramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokHandle?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: UserProfileUpdateexpertiseTagsInput | string[]
    customLinks?: NullableJsonNullValueInput | InputJsonValue
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    publicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    instagramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokHandle?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: UserProfileUpdateexpertiseTagsInput | string[]
    customLinks?: NullableJsonNullValueInput | InputJsonValue
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    kind?: EnumSessionKindFilter<"UserSession"> | $Enums.SessionKind
    userId?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type JourneyProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: JourneyProgressWhereUniqueInput
    update: XOR<JourneyProgressUpdateWithoutUserInput, JourneyProgressUncheckedUpdateWithoutUserInput>
    create: XOR<JourneyProgressCreateWithoutUserInput, JourneyProgressUncheckedCreateWithoutUserInput>
  }

  export type JourneyProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: JourneyProgressWhereUniqueInput
    data: XOR<JourneyProgressUpdateWithoutUserInput, JourneyProgressUncheckedUpdateWithoutUserInput>
  }

  export type JourneyProgressUpdateManyWithWhereWithoutUserInput = {
    where: JourneyProgressScalarWhereInput
    data: XOR<JourneyProgressUpdateManyMutationInput, JourneyProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type JourneyProgressScalarWhereInput = {
    AND?: JourneyProgressScalarWhereInput | JourneyProgressScalarWhereInput[]
    OR?: JourneyProgressScalarWhereInput[]
    NOT?: JourneyProgressScalarWhereInput | JourneyProgressScalarWhereInput[]
    id?: StringFilter<"JourneyProgress"> | string
    scenarioId?: StringFilter<"JourneyProgress"> | string
    userId?: StringNullableFilter<"JourneyProgress"> | string | null
    sessionId?: StringNullableFilter<"JourneyProgress"> | string | null
    status?: EnumJourneyStatusFilter<"JourneyProgress"> | $Enums.JourneyStatus
    currentNode?: StringNullableFilter<"JourneyProgress"> | string | null
    checkpoints?: JsonNullableFilter<"JourneyProgress">
    resources?: JsonNullableFilter<"JourneyProgress">
    notes?: StringNullableFilter<"JourneyProgress"> | string | null
    startedAt?: DateTimeFilter<"JourneyProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"JourneyProgress"> | Date | string | null
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    userId?: StringNullableFilter<"UserAchievement"> | string | null
    sessionId?: StringNullableFilter<"UserAchievement"> | string | null
    journeyId?: StringNullableFilter<"UserAchievement"> | string | null
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    metadata?: JsonNullableFilter<"UserAchievement">
  }

  export type StoryPlaySessionUpsertWithWhereUniqueWithoutUserInput = {
    where: StoryPlaySessionWhereUniqueInput
    update: XOR<StoryPlaySessionUpdateWithoutUserInput, StoryPlaySessionUncheckedUpdateWithoutUserInput>
    create: XOR<StoryPlaySessionCreateWithoutUserInput, StoryPlaySessionUncheckedCreateWithoutUserInput>
  }

  export type StoryPlaySessionUpdateWithWhereUniqueWithoutUserInput = {
    where: StoryPlaySessionWhereUniqueInput
    data: XOR<StoryPlaySessionUpdateWithoutUserInput, StoryPlaySessionUncheckedUpdateWithoutUserInput>
  }

  export type StoryPlaySessionUpdateManyWithWhereWithoutUserInput = {
    where: StoryPlaySessionScalarWhereInput
    data: XOR<StoryPlaySessionUpdateManyMutationInput, StoryPlaySessionUncheckedUpdateManyWithoutUserInput>
  }

  export type StoryPlaySessionScalarWhereInput = {
    AND?: StoryPlaySessionScalarWhereInput | StoryPlaySessionScalarWhereInput[]
    OR?: StoryPlaySessionScalarWhereInput[]
    NOT?: StoryPlaySessionScalarWhereInput | StoryPlaySessionScalarWhereInput[]
    id?: StringFilter<"StoryPlaySession"> | string
    storyId?: StringFilter<"StoryPlaySession"> | string
    versionId?: StringNullableFilter<"StoryPlaySession"> | string | null
    userId?: StringNullableFilter<"StoryPlaySession"> | string | null
    sessionId?: StringNullableFilter<"StoryPlaySession"> | string | null
    startedAt?: DateTimeFilter<"StoryPlaySession"> | Date | string
    completedAt?: DateTimeNullableFilter<"StoryPlaySession"> | Date | string | null
    progress?: JsonNullableFilter<"StoryPlaySession">
    rating?: IntNullableFilter<"StoryPlaySession"> | number | null
    feedback?: StringNullableFilter<"StoryPlaySession"> | string | null
  }

  export type TwineStoryUpsertWithWhereUniqueWithoutOwnerInput = {
    where: TwineStoryWhereUniqueInput
    update: XOR<TwineStoryUpdateWithoutOwnerInput, TwineStoryUncheckedUpdateWithoutOwnerInput>
    create: XOR<TwineStoryCreateWithoutOwnerInput, TwineStoryUncheckedCreateWithoutOwnerInput>
  }

  export type TwineStoryUpdateWithWhereUniqueWithoutOwnerInput = {
    where: TwineStoryWhereUniqueInput
    data: XOR<TwineStoryUpdateWithoutOwnerInput, TwineStoryUncheckedUpdateWithoutOwnerInput>
  }

  export type TwineStoryUpdateManyWithWhereWithoutOwnerInput = {
    where: TwineStoryScalarWhereInput
    data: XOR<TwineStoryUpdateManyMutationInput, TwineStoryUncheckedUpdateManyWithoutOwnerInput>
  }

  export type TwineStoryScalarWhereInput = {
    AND?: TwineStoryScalarWhereInput | TwineStoryScalarWhereInput[]
    OR?: TwineStoryScalarWhereInput[]
    NOT?: TwineStoryScalarWhereInput | TwineStoryScalarWhereInput[]
    id?: StringFilter<"TwineStory"> | string
    slug?: StringFilter<"TwineStory"> | string
    title?: StringFilter<"TwineStory"> | string
    summary?: StringNullableFilter<"TwineStory"> | string | null
    tags?: StringNullableListFilter<"TwineStory">
    visibility?: EnumStoryVisibilityFilter<"TwineStory"> | $Enums.StoryVisibility
    ownerId?: StringNullableFilter<"TwineStory"> | string | null
    originalCreatorId?: StringNullableFilter<"TwineStory"> | string | null
    originalCreatorProfileId?: StringNullableFilter<"TwineStory"> | string | null
    approvedById?: StringNullableFilter<"TwineStory"> | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFilter<"TwineStory"> | $Enums.StoryOwnershipStatus
    submittedAt?: DateTimeNullableFilter<"TwineStory"> | Date | string | null
    transferConsentAt?: DateTimeNullableFilter<"TwineStory"> | Date | string | null
    transferConsentIp?: StringNullableFilter<"TwineStory"> | string | null
    transferConsentUserAgent?: StringNullableFilter<"TwineStory"> | string | null
    approvalToken?: StringNullableFilter<"TwineStory"> | string | null
    approvalTokenExpiresAt?: DateTimeNullableFilter<"TwineStory"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"TwineStory"> | Date | string | null
    reviewComment?: StringNullableFilter<"TwineStory"> | string | null
    creditText?: StringNullableFilter<"TwineStory"> | string | null
    latestVersionId?: StringNullableFilter<"TwineStory"> | string | null
    createdAt?: DateTimeFilter<"TwineStory"> | Date | string
    updatedAt?: DateTimeFilter<"TwineStory"> | Date | string
  }

  export type StoryVersionUpsertWithWhereUniqueWithoutAuthorInput = {
    where: StoryVersionWhereUniqueInput
    update: XOR<StoryVersionUpdateWithoutAuthorInput, StoryVersionUncheckedUpdateWithoutAuthorInput>
    create: XOR<StoryVersionCreateWithoutAuthorInput, StoryVersionUncheckedCreateWithoutAuthorInput>
  }

  export type StoryVersionUpdateWithWhereUniqueWithoutAuthorInput = {
    where: StoryVersionWhereUniqueInput
    data: XOR<StoryVersionUpdateWithoutAuthorInput, StoryVersionUncheckedUpdateWithoutAuthorInput>
  }

  export type StoryVersionUpdateManyWithWhereWithoutAuthorInput = {
    where: StoryVersionScalarWhereInput
    data: XOR<StoryVersionUpdateManyMutationInput, StoryVersionUncheckedUpdateManyWithoutAuthorInput>
  }

  export type StoryVersionScalarWhereInput = {
    AND?: StoryVersionScalarWhereInput | StoryVersionScalarWhereInput[]
    OR?: StoryVersionScalarWhereInput[]
    NOT?: StoryVersionScalarWhereInput | StoryVersionScalarWhereInput[]
    id?: StringFilter<"StoryVersion"> | string
    storyId?: StringFilter<"StoryVersion"> | string
    authorId?: StringNullableFilter<"StoryVersion"> | string | null
    reviewerId?: StringNullableFilter<"StoryVersion"> | string | null
    versionNumber?: IntFilter<"StoryVersion"> | number
    status?: EnumStoryStatusFilter<"StoryVersion"> | $Enums.StoryStatus
    changelog?: StringNullableFilter<"StoryVersion"> | string | null
    content?: JsonNullableFilter<"StoryVersion">
    sourceUrl?: StringNullableFilter<"StoryVersion"> | string | null
    assetPath?: StringNullableFilter<"StoryVersion"> | string | null
    metadata?: JsonNullableFilter<"StoryVersion">
    submittedAt?: DateTimeNullableFilter<"StoryVersion"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"StoryVersion"> | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFilter<"StoryVersion"> | $Enums.StoryOwnershipStatus
    consentSnapshot?: JsonNullableFilter<"StoryVersion">
    createdAt?: DateTimeFilter<"StoryVersion"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StoryVersion"> | Date | string | null
  }

  export type StoryVersionUpsertWithWhereUniqueWithoutReviewerInput = {
    where: StoryVersionWhereUniqueInput
    update: XOR<StoryVersionUpdateWithoutReviewerInput, StoryVersionUncheckedUpdateWithoutReviewerInput>
    create: XOR<StoryVersionCreateWithoutReviewerInput, StoryVersionUncheckedCreateWithoutReviewerInput>
  }

  export type StoryVersionUpdateWithWhereUniqueWithoutReviewerInput = {
    where: StoryVersionWhereUniqueInput
    data: XOR<StoryVersionUpdateWithoutReviewerInput, StoryVersionUncheckedUpdateWithoutReviewerInput>
  }

  export type StoryVersionUpdateManyWithWhereWithoutReviewerInput = {
    where: StoryVersionScalarWhereInput
    data: XOR<StoryVersionUpdateManyMutationInput, StoryVersionUncheckedUpdateManyWithoutReviewerInput>
  }

  export type StoryReviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: StoryReviewWhereUniqueInput
    update: XOR<StoryReviewUpdateWithoutReviewerInput, StoryReviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<StoryReviewCreateWithoutReviewerInput, StoryReviewUncheckedCreateWithoutReviewerInput>
  }

  export type StoryReviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: StoryReviewWhereUniqueInput
    data: XOR<StoryReviewUpdateWithoutReviewerInput, StoryReviewUncheckedUpdateWithoutReviewerInput>
  }

  export type StoryReviewUpdateManyWithWhereWithoutReviewerInput = {
    where: StoryReviewScalarWhereInput
    data: XOR<StoryReviewUpdateManyMutationInput, StoryReviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type StoryReviewScalarWhereInput = {
    AND?: StoryReviewScalarWhereInput | StoryReviewScalarWhereInput[]
    OR?: StoryReviewScalarWhereInput[]
    NOT?: StoryReviewScalarWhereInput | StoryReviewScalarWhereInput[]
    id?: StringFilter<"StoryReview"> | string
    versionId?: StringFilter<"StoryReview"> | string
    reviewerId?: StringFilter<"StoryReview"> | string
    status?: EnumStoryStatusFilter<"StoryReview"> | $Enums.StoryStatus
    feedback?: StringNullableFilter<"StoryReview"> | string | null
    createdAt?: DateTimeFilter<"StoryReview"> | Date | string
  }

  export type CreatorProfileUpsertWithoutUserInput = {
    update: XOR<CreatorProfileUpdateWithoutUserInput, CreatorProfileUncheckedUpdateWithoutUserInput>
    create: XOR<CreatorProfileCreateWithoutUserInput, CreatorProfileUncheckedCreateWithoutUserInput>
    where?: CreatorProfileWhereInput
  }

  export type CreatorProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: CreatorProfileWhereInput
    data: XOR<CreatorProfileUpdateWithoutUserInput, CreatorProfileUncheckedUpdateWithoutUserInput>
  }

  export type CreatorProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    penName?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: CreatorProfileUpdateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileUpdatefocusAreasInput | string[]
    languages?: CreatorProfileUpdatelanguagesInput | string[]
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentStatement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCreatorProfileStatusFieldUpdateOperationsInput | $Enums.CreatorProfileStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewer?: UserUpdateOneWithoutReviewedCreatorProfilesNestedInput
    storiesSubmitted?: TwineStoryUpdateManyWithoutOriginalCreatorProfileNestedInput
  }

  export type CreatorProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    penName?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: CreatorProfileUpdateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileUpdatefocusAreasInput | string[]
    languages?: CreatorProfileUpdatelanguagesInput | string[]
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentStatement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCreatorProfileStatusFieldUpdateOperationsInput | $Enums.CreatorProfileStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storiesSubmitted?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorProfileNestedInput
  }

  export type TwineStoryUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: TwineStoryWhereUniqueInput
    update: XOR<TwineStoryUpdateWithoutApprovedByInput, TwineStoryUncheckedUpdateWithoutApprovedByInput>
    create: XOR<TwineStoryCreateWithoutApprovedByInput, TwineStoryUncheckedCreateWithoutApprovedByInput>
  }

  export type TwineStoryUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: TwineStoryWhereUniqueInput
    data: XOR<TwineStoryUpdateWithoutApprovedByInput, TwineStoryUncheckedUpdateWithoutApprovedByInput>
  }

  export type TwineStoryUpdateManyWithWhereWithoutApprovedByInput = {
    where: TwineStoryScalarWhereInput
    data: XOR<TwineStoryUpdateManyMutationInput, TwineStoryUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type TwineStoryUpsertWithWhereUniqueWithoutOriginalCreatorInput = {
    where: TwineStoryWhereUniqueInput
    update: XOR<TwineStoryUpdateWithoutOriginalCreatorInput, TwineStoryUncheckedUpdateWithoutOriginalCreatorInput>
    create: XOR<TwineStoryCreateWithoutOriginalCreatorInput, TwineStoryUncheckedCreateWithoutOriginalCreatorInput>
  }

  export type TwineStoryUpdateWithWhereUniqueWithoutOriginalCreatorInput = {
    where: TwineStoryWhereUniqueInput
    data: XOR<TwineStoryUpdateWithoutOriginalCreatorInput, TwineStoryUncheckedUpdateWithoutOriginalCreatorInput>
  }

  export type TwineStoryUpdateManyWithWhereWithoutOriginalCreatorInput = {
    where: TwineStoryScalarWhereInput
    data: XOR<TwineStoryUpdateManyMutationInput, TwineStoryUncheckedUpdateManyWithoutOriginalCreatorInput>
  }

  export type CreatorProfileUpsertWithWhereUniqueWithoutLastReviewerInput = {
    where: CreatorProfileWhereUniqueInput
    update: XOR<CreatorProfileUpdateWithoutLastReviewerInput, CreatorProfileUncheckedUpdateWithoutLastReviewerInput>
    create: XOR<CreatorProfileCreateWithoutLastReviewerInput, CreatorProfileUncheckedCreateWithoutLastReviewerInput>
  }

  export type CreatorProfileUpdateWithWhereUniqueWithoutLastReviewerInput = {
    where: CreatorProfileWhereUniqueInput
    data: XOR<CreatorProfileUpdateWithoutLastReviewerInput, CreatorProfileUncheckedUpdateWithoutLastReviewerInput>
  }

  export type CreatorProfileUpdateManyWithWhereWithoutLastReviewerInput = {
    where: CreatorProfileScalarWhereInput
    data: XOR<CreatorProfileUpdateManyMutationInput, CreatorProfileUncheckedUpdateManyWithoutLastReviewerInput>
  }

  export type CreatorProfileScalarWhereInput = {
    AND?: CreatorProfileScalarWhereInput | CreatorProfileScalarWhereInput[]
    OR?: CreatorProfileScalarWhereInput[]
    NOT?: CreatorProfileScalarWhereInput | CreatorProfileScalarWhereInput[]
    id?: StringFilter<"CreatorProfile"> | string
    userId?: StringFilter<"CreatorProfile"> | string
    penName?: StringNullableFilter<"CreatorProfile"> | string | null
    headline?: StringNullableFilter<"CreatorProfile"> | string | null
    expertiseTags?: StringNullableListFilter<"CreatorProfile">
    focusAreas?: StringNullableListFilter<"CreatorProfile">
    languages?: StringNullableListFilter<"CreatorProfile">
    tagline?: StringNullableFilter<"CreatorProfile"> | string | null
    biography?: StringNullableFilter<"CreatorProfile"> | string | null
    websiteUrl?: StringNullableFilter<"CreatorProfile"> | string | null
    portfolioUrl?: StringNullableFilter<"CreatorProfile"> | string | null
    contactEmail?: StringNullableFilter<"CreatorProfile"> | string | null
    socialLinks?: JsonNullableFilter<"CreatorProfile">
    payoutDetails?: JsonNullableFilter<"CreatorProfile">
    guidelinesAcceptedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    termsAcceptedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    consentAcceptedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    consentStatement?: StringNullableFilter<"CreatorProfile"> | string | null
    status?: EnumCreatorProfileStatusFilter<"CreatorProfile"> | $Enums.CreatorProfileStatus
    completedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    lastReviewedAt?: DateTimeNullableFilter<"CreatorProfile"> | Date | string | null
    lastReviewerId?: StringNullableFilter<"CreatorProfile"> | string | null
    rejectionReason?: StringNullableFilter<"CreatorProfile"> | string | null
    createdAt?: DateTimeFilter<"CreatorProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CreatorProfile"> | Date | string
  }

  export type StoryAuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: StoryAuditLogWhereUniqueInput
    update: XOR<StoryAuditLogUpdateWithoutActorInput, StoryAuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<StoryAuditLogCreateWithoutActorInput, StoryAuditLogUncheckedCreateWithoutActorInput>
  }

  export type StoryAuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: StoryAuditLogWhereUniqueInput
    data: XOR<StoryAuditLogUpdateWithoutActorInput, StoryAuditLogUncheckedUpdateWithoutActorInput>
  }

  export type StoryAuditLogUpdateManyWithWhereWithoutActorInput = {
    where: StoryAuditLogScalarWhereInput
    data: XOR<StoryAuditLogUpdateManyMutationInput, StoryAuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type StoryAuditLogScalarWhereInput = {
    AND?: StoryAuditLogScalarWhereInput | StoryAuditLogScalarWhereInput[]
    OR?: StoryAuditLogScalarWhereInput[]
    NOT?: StoryAuditLogScalarWhereInput | StoryAuditLogScalarWhereInput[]
    id?: StringFilter<"StoryAuditLog"> | string
    storyId?: StringFilter<"StoryAuditLog"> | string
    actorId?: StringNullableFilter<"StoryAuditLog"> | string | null
    action?: StringFilter<"StoryAuditLog"> | string
    note?: StringNullableFilter<"StoryAuditLog"> | string | null
    metadata?: JsonNullableFilter<"StoryAuditLog">
    createdAt?: DateTimeFilter<"StoryAuditLog"> | Date | string
  }

  export type StoryInteractionUpsertWithWhereUniqueWithoutUserInput = {
    where: StoryInteractionWhereUniqueInput
    update: XOR<StoryInteractionUpdateWithoutUserInput, StoryInteractionUncheckedUpdateWithoutUserInput>
    create: XOR<StoryInteractionCreateWithoutUserInput, StoryInteractionUncheckedCreateWithoutUserInput>
  }

  export type StoryInteractionUpdateWithWhereUniqueWithoutUserInput = {
    where: StoryInteractionWhereUniqueInput
    data: XOR<StoryInteractionUpdateWithoutUserInput, StoryInteractionUncheckedUpdateWithoutUserInput>
  }

  export type StoryInteractionUpdateManyWithWhereWithoutUserInput = {
    where: StoryInteractionScalarWhereInput
    data: XOR<StoryInteractionUpdateManyMutationInput, StoryInteractionUncheckedUpdateManyWithoutUserInput>
  }

  export type StoryInteractionScalarWhereInput = {
    AND?: StoryInteractionScalarWhereInput | StoryInteractionScalarWhereInput[]
    OR?: StoryInteractionScalarWhereInput[]
    NOT?: StoryInteractionScalarWhereInput | StoryInteractionScalarWhereInput[]
    id?: StringFilter<"StoryInteraction"> | string
    avatarId?: StringFilter<"StoryInteraction"> | string
    storyId?: StringNullableFilter<"StoryInteraction"> | string | null
    sessionId?: StringNullableFilter<"StoryInteraction"> | string | null
    userId?: StringNullableFilter<"StoryInteraction"> | string | null
    kind?: EnumStoryInteractionKindFilter<"StoryInteraction"> | $Enums.StoryInteractionKind
    metadata?: JsonNullableFilter<"StoryInteraction">
    createdAt?: DateTimeFilter<"StoryInteraction"> | Date | string
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatorProfileInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatorProfileInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatorProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatorProfileInput, UserUncheckedCreateWithoutCreatorProfileInput>
  }

  export type UserCreateWithoutReviewedCreatorProfilesInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewedCreatorProfilesInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewedCreatorProfilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedCreatorProfilesInput, UserUncheckedCreateWithoutReviewedCreatorProfilesInput>
  }

  export type TwineStoryCreateWithoutOriginalCreatorProfileInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutOriginalCreatorProfileInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutOriginalCreatorProfileInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutOriginalCreatorProfileInput, TwineStoryUncheckedCreateWithoutOriginalCreatorProfileInput>
  }

  export type TwineStoryCreateManyOriginalCreatorProfileInputEnvelope = {
    data: TwineStoryCreateManyOriginalCreatorProfileInput | TwineStoryCreateManyOriginalCreatorProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatorProfileInput = {
    update: XOR<UserUpdateWithoutCreatorProfileInput, UserUncheckedUpdateWithoutCreatorProfileInput>
    create: XOR<UserCreateWithoutCreatorProfileInput, UserUncheckedCreateWithoutCreatorProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatorProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatorProfileInput, UserUncheckedUpdateWithoutCreatorProfileInput>
  }

  export type UserUpdateWithoutCreatorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReviewedCreatorProfilesInput = {
    update: XOR<UserUpdateWithoutReviewedCreatorProfilesInput, UserUncheckedUpdateWithoutReviewedCreatorProfilesInput>
    create: XOR<UserCreateWithoutReviewedCreatorProfilesInput, UserUncheckedCreateWithoutReviewedCreatorProfilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedCreatorProfilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedCreatorProfilesInput, UserUncheckedUpdateWithoutReviewedCreatorProfilesInput>
  }

  export type UserUpdateWithoutReviewedCreatorProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedCreatorProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TwineStoryUpsertWithWhereUniqueWithoutOriginalCreatorProfileInput = {
    where: TwineStoryWhereUniqueInput
    update: XOR<TwineStoryUpdateWithoutOriginalCreatorProfileInput, TwineStoryUncheckedUpdateWithoutOriginalCreatorProfileInput>
    create: XOR<TwineStoryCreateWithoutOriginalCreatorProfileInput, TwineStoryUncheckedCreateWithoutOriginalCreatorProfileInput>
  }

  export type TwineStoryUpdateWithWhereUniqueWithoutOriginalCreatorProfileInput = {
    where: TwineStoryWhereUniqueInput
    data: XOR<TwineStoryUpdateWithoutOriginalCreatorProfileInput, TwineStoryUncheckedUpdateWithoutOriginalCreatorProfileInput>
  }

  export type TwineStoryUpdateManyWithWhereWithoutOriginalCreatorProfileInput = {
    where: TwineStoryScalarWhereInput
    data: XOR<TwineStoryUpdateManyMutationInput, TwineStoryUncheckedUpdateManyWithoutOriginalCreatorProfileInput>
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type JourneyProgressCreateWithoutSessionInput = {
    id?: string
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    scenario: ScenarioCreateNestedOneWithoutJourneysInput
    user?: UserCreateNestedOneWithoutJourneysInput
    achievements?: UserAchievementCreateNestedManyWithoutJourneyInput
  }

  export type JourneyProgressUncheckedCreateWithoutSessionInput = {
    id?: string
    scenarioId: string
    userId?: string | null
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutJourneyInput
  }

  export type JourneyProgressCreateOrConnectWithoutSessionInput = {
    where: JourneyProgressWhereUniqueInput
    create: XOR<JourneyProgressCreateWithoutSessionInput, JourneyProgressUncheckedCreateWithoutSessionInput>
  }

  export type JourneyProgressCreateManySessionInputEnvelope = {
    data: JourneyProgressCreateManySessionInput | JourneyProgressCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type StoryPlaySessionCreateWithoutSessionInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
    story: TwineStoryCreateNestedOneWithoutPlaySessionsInput
    version?: StoryVersionCreateNestedOneWithoutPlaySessionsInput
    user?: UserCreateNestedOneWithoutStoryPlaysInput
  }

  export type StoryPlaySessionUncheckedCreateWithoutSessionInput = {
    id?: string
    storyId: string
    versionId?: string | null
    userId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
  }

  export type StoryPlaySessionCreateOrConnectWithoutSessionInput = {
    where: StoryPlaySessionWhereUniqueInput
    create: XOR<StoryPlaySessionCreateWithoutSessionInput, StoryPlaySessionUncheckedCreateWithoutSessionInput>
  }

  export type StoryPlaySessionCreateManySessionInputEnvelope = {
    data: StoryPlaySessionCreateManySessionInput | StoryPlaySessionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementCreateWithoutSessionInput = {
    id?: string
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    achievement: AchievementCreateNestedOneWithoutUserAwardsInput
    user?: UserCreateNestedOneWithoutAchievementsInput
    journey?: JourneyProgressCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutSessionInput = {
    id?: string
    achievementId: string
    userId?: string | null
    journeyId?: string | null
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementCreateOrConnectWithoutSessionInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutSessionInput, UserAchievementUncheckedCreateWithoutSessionInput>
  }

  export type UserAchievementCreateManySessionInputEnvelope = {
    data: UserAchievementCreateManySessionInput | UserAchievementCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type StoryInteractionCreateWithoutSessionInput = {
    id?: string
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    avatar: AvatarProfileCreateNestedOneWithoutInteractionsInput
    story?: TwineStoryCreateNestedOneWithoutInteractionsInput
    user?: UserCreateNestedOneWithoutStoryInteractionsInput
  }

  export type StoryInteractionUncheckedCreateWithoutSessionInput = {
    id?: string
    avatarId: string
    storyId?: string | null
    userId?: string | null
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryInteractionCreateOrConnectWithoutSessionInput = {
    where: StoryInteractionWhereUniqueInput
    create: XOR<StoryInteractionCreateWithoutSessionInput, StoryInteractionUncheckedCreateWithoutSessionInput>
  }

  export type StoryInteractionCreateManySessionInputEnvelope = {
    data: StoryInteractionCreateManySessionInput | StoryInteractionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JourneyProgressUpsertWithWhereUniqueWithoutSessionInput = {
    where: JourneyProgressWhereUniqueInput
    update: XOR<JourneyProgressUpdateWithoutSessionInput, JourneyProgressUncheckedUpdateWithoutSessionInput>
    create: XOR<JourneyProgressCreateWithoutSessionInput, JourneyProgressUncheckedCreateWithoutSessionInput>
  }

  export type JourneyProgressUpdateWithWhereUniqueWithoutSessionInput = {
    where: JourneyProgressWhereUniqueInput
    data: XOR<JourneyProgressUpdateWithoutSessionInput, JourneyProgressUncheckedUpdateWithoutSessionInput>
  }

  export type JourneyProgressUpdateManyWithWhereWithoutSessionInput = {
    where: JourneyProgressScalarWhereInput
    data: XOR<JourneyProgressUpdateManyMutationInput, JourneyProgressUncheckedUpdateManyWithoutSessionInput>
  }

  export type StoryPlaySessionUpsertWithWhereUniqueWithoutSessionInput = {
    where: StoryPlaySessionWhereUniqueInput
    update: XOR<StoryPlaySessionUpdateWithoutSessionInput, StoryPlaySessionUncheckedUpdateWithoutSessionInput>
    create: XOR<StoryPlaySessionCreateWithoutSessionInput, StoryPlaySessionUncheckedCreateWithoutSessionInput>
  }

  export type StoryPlaySessionUpdateWithWhereUniqueWithoutSessionInput = {
    where: StoryPlaySessionWhereUniqueInput
    data: XOR<StoryPlaySessionUpdateWithoutSessionInput, StoryPlaySessionUncheckedUpdateWithoutSessionInput>
  }

  export type StoryPlaySessionUpdateManyWithWhereWithoutSessionInput = {
    where: StoryPlaySessionScalarWhereInput
    data: XOR<StoryPlaySessionUpdateManyMutationInput, StoryPlaySessionUncheckedUpdateManyWithoutSessionInput>
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutSessionInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutSessionInput, UserAchievementUncheckedUpdateWithoutSessionInput>
    create: XOR<UserAchievementCreateWithoutSessionInput, UserAchievementUncheckedCreateWithoutSessionInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutSessionInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutSessionInput, UserAchievementUncheckedUpdateWithoutSessionInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutSessionInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutSessionInput>
  }

  export type StoryInteractionUpsertWithWhereUniqueWithoutSessionInput = {
    where: StoryInteractionWhereUniqueInput
    update: XOR<StoryInteractionUpdateWithoutSessionInput, StoryInteractionUncheckedUpdateWithoutSessionInput>
    create: XOR<StoryInteractionCreateWithoutSessionInput, StoryInteractionUncheckedCreateWithoutSessionInput>
  }

  export type StoryInteractionUpdateWithWhereUniqueWithoutSessionInput = {
    where: StoryInteractionWhereUniqueInput
    data: XOR<StoryInteractionUpdateWithoutSessionInput, StoryInteractionUncheckedUpdateWithoutSessionInput>
  }

  export type StoryInteractionUpdateManyWithWhereWithoutSessionInput = {
    where: StoryInteractionScalarWhereInput
    data: XOR<StoryInteractionUpdateManyMutationInput, StoryInteractionUncheckedUpdateManyWithoutSessionInput>
  }

  export type JourneyProgressCreateWithoutScenarioInput = {
    id?: string
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutJourneysInput
    session?: UserSessionCreateNestedOneWithoutJourneysInput
    achievements?: UserAchievementCreateNestedManyWithoutJourneyInput
  }

  export type JourneyProgressUncheckedCreateWithoutScenarioInput = {
    id?: string
    userId?: string | null
    sessionId?: string | null
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutJourneyInput
  }

  export type JourneyProgressCreateOrConnectWithoutScenarioInput = {
    where: JourneyProgressWhereUniqueInput
    create: XOR<JourneyProgressCreateWithoutScenarioInput, JourneyProgressUncheckedCreateWithoutScenarioInput>
  }

  export type JourneyProgressCreateManyScenarioInputEnvelope = {
    data: JourneyProgressCreateManyScenarioInput | JourneyProgressCreateManyScenarioInput[]
    skipDuplicates?: boolean
  }

  export type JourneyProgressUpsertWithWhereUniqueWithoutScenarioInput = {
    where: JourneyProgressWhereUniqueInput
    update: XOR<JourneyProgressUpdateWithoutScenarioInput, JourneyProgressUncheckedUpdateWithoutScenarioInput>
    create: XOR<JourneyProgressCreateWithoutScenarioInput, JourneyProgressUncheckedCreateWithoutScenarioInput>
  }

  export type JourneyProgressUpdateWithWhereUniqueWithoutScenarioInput = {
    where: JourneyProgressWhereUniqueInput
    data: XOR<JourneyProgressUpdateWithoutScenarioInput, JourneyProgressUncheckedUpdateWithoutScenarioInput>
  }

  export type JourneyProgressUpdateManyWithWhereWithoutScenarioInput = {
    where: JourneyProgressScalarWhereInput
    data: XOR<JourneyProgressUpdateManyMutationInput, JourneyProgressUncheckedUpdateManyWithoutScenarioInput>
  }

  export type ScenarioCreateWithoutJourneysInput = {
    id: string
    title: string
    summary?: string | null
    issueTag?: string | null
    difficulty?: string | null
    estimatedMinutes?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioUncheckedCreateWithoutJourneysInput = {
    id: string
    title: string
    summary?: string | null
    issueTag?: string | null
    difficulty?: string | null
    estimatedMinutes?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioCreateOrConnectWithoutJourneysInput = {
    where: ScenarioWhereUniqueInput
    create: XOR<ScenarioCreateWithoutJourneysInput, ScenarioUncheckedCreateWithoutJourneysInput>
  }

  export type UserCreateWithoutJourneysInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJourneysInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJourneysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJourneysInput, UserUncheckedCreateWithoutJourneysInput>
  }

  export type UserSessionCreateWithoutJourneysInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSessionsInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutSessionInput
    achievements?: UserAchievementCreateNestedManyWithoutSessionInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutSessionInput
  }

  export type UserSessionUncheckedCreateWithoutJourneysInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    userId?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutSessionInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutSessionInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type UserSessionCreateOrConnectWithoutJourneysInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutJourneysInput, UserSessionUncheckedCreateWithoutJourneysInput>
  }

  export type UserAchievementCreateWithoutJourneyInput = {
    id?: string
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    achievement: AchievementCreateNestedOneWithoutUserAwardsInput
    user?: UserCreateNestedOneWithoutAchievementsInput
    session?: UserSessionCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutJourneyInput = {
    id?: string
    achievementId: string
    userId?: string | null
    sessionId?: string | null
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementCreateOrConnectWithoutJourneyInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutJourneyInput, UserAchievementUncheckedCreateWithoutJourneyInput>
  }

  export type UserAchievementCreateManyJourneyInputEnvelope = {
    data: UserAchievementCreateManyJourneyInput | UserAchievementCreateManyJourneyInput[]
    skipDuplicates?: boolean
  }

  export type ScenarioUpsertWithoutJourneysInput = {
    update: XOR<ScenarioUpdateWithoutJourneysInput, ScenarioUncheckedUpdateWithoutJourneysInput>
    create: XOR<ScenarioCreateWithoutJourneysInput, ScenarioUncheckedCreateWithoutJourneysInput>
    where?: ScenarioWhereInput
  }

  export type ScenarioUpdateToOneWithWhereWithoutJourneysInput = {
    where?: ScenarioWhereInput
    data: XOR<ScenarioUpdateWithoutJourneysInput, ScenarioUncheckedUpdateWithoutJourneysInput>
  }

  export type ScenarioUpdateWithoutJourneysInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    issueTag?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUncheckedUpdateWithoutJourneysInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    issueTag?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutJourneysInput = {
    update: XOR<UserUpdateWithoutJourneysInput, UserUncheckedUpdateWithoutJourneysInput>
    create: XOR<UserCreateWithoutJourneysInput, UserUncheckedCreateWithoutJourneysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJourneysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJourneysInput, UserUncheckedUpdateWithoutJourneysInput>
  }

  export type UserUpdateWithoutJourneysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJourneysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserSessionUpsertWithoutJourneysInput = {
    update: XOR<UserSessionUpdateWithoutJourneysInput, UserSessionUncheckedUpdateWithoutJourneysInput>
    create: XOR<UserSessionCreateWithoutJourneysInput, UserSessionUncheckedCreateWithoutJourneysInput>
    where?: UserSessionWhereInput
  }

  export type UserSessionUpdateToOneWithWhereWithoutJourneysInput = {
    where?: UserSessionWhereInput
    data: XOR<UserSessionUpdateWithoutJourneysInput, UserSessionUncheckedUpdateWithoutJourneysInput>
  }

  export type UserSessionUpdateWithoutJourneysInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSessionsNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutSessionNestedInput
    achievements?: UserAchievementUpdateManyWithoutSessionNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutSessionNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutJourneysInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutSessionNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutSessionNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutJourneyInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutJourneyInput, UserAchievementUncheckedUpdateWithoutJourneyInput>
    create: XOR<UserAchievementCreateWithoutJourneyInput, UserAchievementUncheckedCreateWithoutJourneyInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutJourneyInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutJourneyInput, UserAchievementUncheckedUpdateWithoutJourneyInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutJourneyInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutJourneyInput>
  }

  export type UserAchievementCreateWithoutAchievementInput = {
    id?: string
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserCreateNestedOneWithoutAchievementsInput
    session?: UserSessionCreateNestedOneWithoutAchievementsInput
    journey?: JourneyProgressCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    userId?: string | null
    sessionId?: string | null
    journeyId?: string | null
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementCreateOrConnectWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementCreateManyAchievementInputEnvelope = {
    data: UserAchievementCreateManyAchievementInput | UserAchievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutAchievementInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type AchievementCreateWithoutUserAwardsInput = {
    id?: string
    code: string
    title: string
    description: string
    points?: number
    icon?: string | null
    unlockHint?: string | null
    unlockLogic?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutUserAwardsInput = {
    id?: string
    code: string
    title: string
    description: string
    points?: number
    icon?: string | null
    unlockHint?: string | null
    unlockLogic?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutUserAwardsInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserAwardsInput, AchievementUncheckedCreateWithoutUserAwardsInput>
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type UserSessionCreateWithoutAchievementsInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSessionsInput
    journeys?: JourneyProgressCreateNestedManyWithoutSessionInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutSessionInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutSessionInput
  }

  export type UserSessionUncheckedCreateWithoutAchievementsInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    userId?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutSessionInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutSessionInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type UserSessionCreateOrConnectWithoutAchievementsInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutAchievementsInput, UserSessionUncheckedCreateWithoutAchievementsInput>
  }

  export type JourneyProgressCreateWithoutAchievementsInput = {
    id?: string
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    scenario: ScenarioCreateNestedOneWithoutJourneysInput
    user?: UserCreateNestedOneWithoutJourneysInput
    session?: UserSessionCreateNestedOneWithoutJourneysInput
  }

  export type JourneyProgressUncheckedCreateWithoutAchievementsInput = {
    id?: string
    scenarioId: string
    userId?: string | null
    sessionId?: string | null
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type JourneyProgressCreateOrConnectWithoutAchievementsInput = {
    where: JourneyProgressWhereUniqueInput
    create: XOR<JourneyProgressCreateWithoutAchievementsInput, JourneyProgressUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementUpsertWithoutUserAwardsInput = {
    update: XOR<AchievementUpdateWithoutUserAwardsInput, AchievementUncheckedUpdateWithoutUserAwardsInput>
    create: XOR<AchievementCreateWithoutUserAwardsInput, AchievementUncheckedCreateWithoutUserAwardsInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUserAwardsInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUserAwardsInput, AchievementUncheckedUpdateWithoutUserAwardsInput>
  }

  export type AchievementUpdateWithoutUserAwardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockHint?: NullableStringFieldUpdateOperationsInput | string | null
    unlockLogic?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutUserAwardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockHint?: NullableStringFieldUpdateOperationsInput | string | null
    unlockLogic?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserSessionUpsertWithoutAchievementsInput = {
    update: XOR<UserSessionUpdateWithoutAchievementsInput, UserSessionUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserSessionCreateWithoutAchievementsInput, UserSessionUncheckedCreateWithoutAchievementsInput>
    where?: UserSessionWhereInput
  }

  export type UserSessionUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserSessionWhereInput
    data: XOR<UserSessionUpdateWithoutAchievementsInput, UserSessionUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserSessionUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSessionsNestedInput
    journeys?: JourneyProgressUpdateManyWithoutSessionNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutSessionNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutSessionNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journeys?: JourneyProgressUncheckedUpdateManyWithoutSessionNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutSessionNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type JourneyProgressUpsertWithoutAchievementsInput = {
    update: XOR<JourneyProgressUpdateWithoutAchievementsInput, JourneyProgressUncheckedUpdateWithoutAchievementsInput>
    create: XOR<JourneyProgressCreateWithoutAchievementsInput, JourneyProgressUncheckedCreateWithoutAchievementsInput>
    where?: JourneyProgressWhereInput
  }

  export type JourneyProgressUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: JourneyProgressWhereInput
    data: XOR<JourneyProgressUpdateWithoutAchievementsInput, JourneyProgressUncheckedUpdateWithoutAchievementsInput>
  }

  export type JourneyProgressUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scenario?: ScenarioUpdateOneRequiredWithoutJourneysNestedInput
    user?: UserUpdateOneWithoutJourneysNestedInput
    session?: UserSessionUpdateOneWithoutJourneysNestedInput
  }

  export type JourneyProgressUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutStoriesInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStoriesInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
  }

  export type UserCreateWithoutOriginalStoriesInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOriginalStoriesInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOriginalStoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOriginalStoriesInput, UserUncheckedCreateWithoutOriginalStoriesInput>
  }

  export type CreatorProfileCreateWithoutStoriesSubmittedInput = {
    id?: string
    penName?: string | null
    headline?: string | null
    expertiseTags?: CreatorProfileCreateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileCreatefocusAreasInput | string[]
    languages?: CreatorProfileCreatelanguagesInput | string[]
    tagline?: string | null
    biography?: string | null
    websiteUrl?: string | null
    portfolioUrl?: string | null
    contactEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: Date | string | null
    termsAcceptedAt?: Date | string | null
    consentAcceptedAt?: Date | string | null
    consentStatement?: string | null
    status?: $Enums.CreatorProfileStatus
    completedAt?: Date | string | null
    lastReviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCreatorProfileInput
    lastReviewer?: UserCreateNestedOneWithoutReviewedCreatorProfilesInput
  }

  export type CreatorProfileUncheckedCreateWithoutStoriesSubmittedInput = {
    id?: string
    userId: string
    penName?: string | null
    headline?: string | null
    expertiseTags?: CreatorProfileCreateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileCreatefocusAreasInput | string[]
    languages?: CreatorProfileCreatelanguagesInput | string[]
    tagline?: string | null
    biography?: string | null
    websiteUrl?: string | null
    portfolioUrl?: string | null
    contactEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: Date | string | null
    termsAcceptedAt?: Date | string | null
    consentAcceptedAt?: Date | string | null
    consentStatement?: string | null
    status?: $Enums.CreatorProfileStatus
    completedAt?: Date | string | null
    lastReviewedAt?: Date | string | null
    lastReviewerId?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreatorProfileCreateOrConnectWithoutStoriesSubmittedInput = {
    where: CreatorProfileWhereUniqueInput
    create: XOR<CreatorProfileCreateWithoutStoriesSubmittedInput, CreatorProfileUncheckedCreateWithoutStoriesSubmittedInput>
  }

  export type UserCreateWithoutApprovedStoriesInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApprovedStoriesInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApprovedStoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedStoriesInput, UserUncheckedCreateWithoutApprovedStoriesInput>
  }

  export type StoryVersionCreateWithoutStoryInput = {
    id?: string
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    featuredIn?: TwineStoryCreateNestedOneWithoutLatestVersionInput
    author?: UserCreateNestedOneWithoutAuthoredVersionsInput
    reviewer?: UserCreateNestedOneWithoutReviewedVersionsInput
    reviews?: StoryReviewCreateNestedManyWithoutVersionInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionUncheckedCreateWithoutStoryInput = {
    id?: string
    authorId?: string | null
    reviewerId?: string | null
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    featuredIn?: TwineStoryUncheckedCreateNestedOneWithoutLatestVersionInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutVersionInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionCreateOrConnectWithoutStoryInput = {
    where: StoryVersionWhereUniqueInput
    create: XOR<StoryVersionCreateWithoutStoryInput, StoryVersionUncheckedCreateWithoutStoryInput>
  }

  export type StoryVersionCreateManyStoryInputEnvelope = {
    data: StoryVersionCreateManyStoryInput | StoryVersionCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type StoryVersionCreateWithoutFeaturedInInput = {
    id?: string
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    story: TwineStoryCreateNestedOneWithoutVersionsInput
    author?: UserCreateNestedOneWithoutAuthoredVersionsInput
    reviewer?: UserCreateNestedOneWithoutReviewedVersionsInput
    reviews?: StoryReviewCreateNestedManyWithoutVersionInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionUncheckedCreateWithoutFeaturedInInput = {
    id?: string
    storyId: string
    authorId?: string | null
    reviewerId?: string | null
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutVersionInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionCreateOrConnectWithoutFeaturedInInput = {
    where: StoryVersionWhereUniqueInput
    create: XOR<StoryVersionCreateWithoutFeaturedInInput, StoryVersionUncheckedCreateWithoutFeaturedInInput>
  }

  export type StoryPlaySessionCreateWithoutStoryInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
    version?: StoryVersionCreateNestedOneWithoutPlaySessionsInput
    user?: UserCreateNestedOneWithoutStoryPlaysInput
    session?: UserSessionCreateNestedOneWithoutStoryPlaysInput
  }

  export type StoryPlaySessionUncheckedCreateWithoutStoryInput = {
    id?: string
    versionId?: string | null
    userId?: string | null
    sessionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
  }

  export type StoryPlaySessionCreateOrConnectWithoutStoryInput = {
    where: StoryPlaySessionWhereUniqueInput
    create: XOR<StoryPlaySessionCreateWithoutStoryInput, StoryPlaySessionUncheckedCreateWithoutStoryInput>
  }

  export type StoryPlaySessionCreateManyStoryInputEnvelope = {
    data: StoryPlaySessionCreateManyStoryInput | StoryPlaySessionCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type StoryNodeCreateWithoutStoryInput = {
    id?: string
    key: string
    title?: string | null
    synopsis?: string | null
    type?: $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    outgoing?: StoryTransitionCreateNestedManyWithoutFromNodeInput
    incoming?: StoryTransitionCreateNestedManyWithoutToNodeInput
  }

  export type StoryNodeUncheckedCreateWithoutStoryInput = {
    id?: string
    key: string
    title?: string | null
    synopsis?: string | null
    type?: $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    outgoing?: StoryTransitionUncheckedCreateNestedManyWithoutFromNodeInput
    incoming?: StoryTransitionUncheckedCreateNestedManyWithoutToNodeInput
  }

  export type StoryNodeCreateOrConnectWithoutStoryInput = {
    where: StoryNodeWhereUniqueInput
    create: XOR<StoryNodeCreateWithoutStoryInput, StoryNodeUncheckedCreateWithoutStoryInput>
  }

  export type StoryNodeCreateManyStoryInputEnvelope = {
    data: StoryNodeCreateManyStoryInput | StoryNodeCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type StoryPathCreateWithoutStoryInput = {
    id?: string
    key: string
    label: string
    summary?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transitions?: StoryTransitionCreateNestedManyWithoutPathInput
  }

  export type StoryPathUncheckedCreateWithoutStoryInput = {
    id?: string
    key: string
    label: string
    summary?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutPathInput
  }

  export type StoryPathCreateOrConnectWithoutStoryInput = {
    where: StoryPathWhereUniqueInput
    create: XOR<StoryPathCreateWithoutStoryInput, StoryPathUncheckedCreateWithoutStoryInput>
  }

  export type StoryPathCreateManyStoryInputEnvelope = {
    data: StoryPathCreateManyStoryInput | StoryPathCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type StoryTransitionCreateWithoutStoryInput = {
    id?: string
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    fromNode: StoryNodeCreateNestedOneWithoutOutgoingInput
    toNode?: StoryNodeCreateNestedOneWithoutIncomingInput
    path: StoryPathCreateNestedOneWithoutTransitionsInput
  }

  export type StoryTransitionUncheckedCreateWithoutStoryInput = {
    id?: string
    fromNodeId: string
    pathId: string
    toNodeId?: string | null
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryTransitionCreateOrConnectWithoutStoryInput = {
    where: StoryTransitionWhereUniqueInput
    create: XOR<StoryTransitionCreateWithoutStoryInput, StoryTransitionUncheckedCreateWithoutStoryInput>
  }

  export type StoryTransitionCreateManyStoryInputEnvelope = {
    data: StoryTransitionCreateManyStoryInput | StoryTransitionCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type AvatarProfileCreateWithoutStoryInput = {
    id: string
    name: string
    age?: number | null
    background?: string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: boolean
    experienceClicks?: number
    experienceStarts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: StoryInteractionCreateNestedManyWithoutAvatarInput
  }

  export type AvatarProfileUncheckedCreateWithoutStoryInput = {
    id: string
    name: string
    age?: number | null
    background?: string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: boolean
    experienceClicks?: number
    experienceStarts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutAvatarInput
  }

  export type AvatarProfileCreateOrConnectWithoutStoryInput = {
    where: AvatarProfileWhereUniqueInput
    create: XOR<AvatarProfileCreateWithoutStoryInput, AvatarProfileUncheckedCreateWithoutStoryInput>
  }

  export type AvatarProfileCreateManyStoryInputEnvelope = {
    data: AvatarProfileCreateManyStoryInput | AvatarProfileCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type StoryAuditLogCreateWithoutStoryInput = {
    id?: string
    action: string
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutStoryAuditLogsInput
  }

  export type StoryAuditLogUncheckedCreateWithoutStoryInput = {
    id?: string
    actorId?: string | null
    action: string
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryAuditLogCreateOrConnectWithoutStoryInput = {
    where: StoryAuditLogWhereUniqueInput
    create: XOR<StoryAuditLogCreateWithoutStoryInput, StoryAuditLogUncheckedCreateWithoutStoryInput>
  }

  export type StoryAuditLogCreateManyStoryInputEnvelope = {
    data: StoryAuditLogCreateManyStoryInput | StoryAuditLogCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type StoryInteractionCreateWithoutStoryInput = {
    id?: string
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    avatar: AvatarProfileCreateNestedOneWithoutInteractionsInput
    session?: UserSessionCreateNestedOneWithoutStoryInteractionsInput
    user?: UserCreateNestedOneWithoutStoryInteractionsInput
  }

  export type StoryInteractionUncheckedCreateWithoutStoryInput = {
    id?: string
    avatarId: string
    sessionId?: string | null
    userId?: string | null
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryInteractionCreateOrConnectWithoutStoryInput = {
    where: StoryInteractionWhereUniqueInput
    create: XOR<StoryInteractionCreateWithoutStoryInput, StoryInteractionUncheckedCreateWithoutStoryInput>
  }

  export type StoryInteractionCreateManyStoryInputEnvelope = {
    data: StoryInteractionCreateManyStoryInput | StoryInteractionCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStoriesInput = {
    update: XOR<UserUpdateWithoutStoriesInput, UserUncheckedUpdateWithoutStoriesInput>
    create: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoriesInput, UserUncheckedUpdateWithoutStoriesInput>
  }

  export type UserUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutOriginalStoriesInput = {
    update: XOR<UserUpdateWithoutOriginalStoriesInput, UserUncheckedUpdateWithoutOriginalStoriesInput>
    create: XOR<UserCreateWithoutOriginalStoriesInput, UserUncheckedCreateWithoutOriginalStoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOriginalStoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOriginalStoriesInput, UserUncheckedUpdateWithoutOriginalStoriesInput>
  }

  export type UserUpdateWithoutOriginalStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOriginalStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CreatorProfileUpsertWithoutStoriesSubmittedInput = {
    update: XOR<CreatorProfileUpdateWithoutStoriesSubmittedInput, CreatorProfileUncheckedUpdateWithoutStoriesSubmittedInput>
    create: XOR<CreatorProfileCreateWithoutStoriesSubmittedInput, CreatorProfileUncheckedCreateWithoutStoriesSubmittedInput>
    where?: CreatorProfileWhereInput
  }

  export type CreatorProfileUpdateToOneWithWhereWithoutStoriesSubmittedInput = {
    where?: CreatorProfileWhereInput
    data: XOR<CreatorProfileUpdateWithoutStoriesSubmittedInput, CreatorProfileUncheckedUpdateWithoutStoriesSubmittedInput>
  }

  export type CreatorProfileUpdateWithoutStoriesSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    penName?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: CreatorProfileUpdateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileUpdatefocusAreasInput | string[]
    languages?: CreatorProfileUpdatelanguagesInput | string[]
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentStatement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCreatorProfileStatusFieldUpdateOperationsInput | $Enums.CreatorProfileStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCreatorProfileNestedInput
    lastReviewer?: UserUpdateOneWithoutReviewedCreatorProfilesNestedInput
  }

  export type CreatorProfileUncheckedUpdateWithoutStoriesSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    penName?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: CreatorProfileUpdateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileUpdatefocusAreasInput | string[]
    languages?: CreatorProfileUpdatelanguagesInput | string[]
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentStatement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCreatorProfileStatusFieldUpdateOperationsInput | $Enums.CreatorProfileStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutApprovedStoriesInput = {
    update: XOR<UserUpdateWithoutApprovedStoriesInput, UserUncheckedUpdateWithoutApprovedStoriesInput>
    create: XOR<UserCreateWithoutApprovedStoriesInput, UserUncheckedCreateWithoutApprovedStoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedStoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedStoriesInput, UserUncheckedUpdateWithoutApprovedStoriesInput>
  }

  export type UserUpdateWithoutApprovedStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StoryVersionUpsertWithWhereUniqueWithoutStoryInput = {
    where: StoryVersionWhereUniqueInput
    update: XOR<StoryVersionUpdateWithoutStoryInput, StoryVersionUncheckedUpdateWithoutStoryInput>
    create: XOR<StoryVersionCreateWithoutStoryInput, StoryVersionUncheckedCreateWithoutStoryInput>
  }

  export type StoryVersionUpdateWithWhereUniqueWithoutStoryInput = {
    where: StoryVersionWhereUniqueInput
    data: XOR<StoryVersionUpdateWithoutStoryInput, StoryVersionUncheckedUpdateWithoutStoryInput>
  }

  export type StoryVersionUpdateManyWithWhereWithoutStoryInput = {
    where: StoryVersionScalarWhereInput
    data: XOR<StoryVersionUpdateManyMutationInput, StoryVersionUncheckedUpdateManyWithoutStoryInput>
  }

  export type StoryVersionUpsertWithoutFeaturedInInput = {
    update: XOR<StoryVersionUpdateWithoutFeaturedInInput, StoryVersionUncheckedUpdateWithoutFeaturedInInput>
    create: XOR<StoryVersionCreateWithoutFeaturedInInput, StoryVersionUncheckedCreateWithoutFeaturedInInput>
    where?: StoryVersionWhereInput
  }

  export type StoryVersionUpdateToOneWithWhereWithoutFeaturedInInput = {
    where?: StoryVersionWhereInput
    data: XOR<StoryVersionUpdateWithoutFeaturedInInput, StoryVersionUncheckedUpdateWithoutFeaturedInInput>
  }

  export type StoryVersionUpdateWithoutFeaturedInInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    story?: TwineStoryUpdateOneRequiredWithoutVersionsNestedInput
    author?: UserUpdateOneWithoutAuthoredVersionsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedVersionsNestedInput
    reviews?: StoryReviewUpdateManyWithoutVersionNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutVersionNestedInput
  }

  export type StoryVersionUncheckedUpdateWithoutFeaturedInInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: StoryReviewUncheckedUpdateManyWithoutVersionNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type StoryPlaySessionUpsertWithWhereUniqueWithoutStoryInput = {
    where: StoryPlaySessionWhereUniqueInput
    update: XOR<StoryPlaySessionUpdateWithoutStoryInput, StoryPlaySessionUncheckedUpdateWithoutStoryInput>
    create: XOR<StoryPlaySessionCreateWithoutStoryInput, StoryPlaySessionUncheckedCreateWithoutStoryInput>
  }

  export type StoryPlaySessionUpdateWithWhereUniqueWithoutStoryInput = {
    where: StoryPlaySessionWhereUniqueInput
    data: XOR<StoryPlaySessionUpdateWithoutStoryInput, StoryPlaySessionUncheckedUpdateWithoutStoryInput>
  }

  export type StoryPlaySessionUpdateManyWithWhereWithoutStoryInput = {
    where: StoryPlaySessionScalarWhereInput
    data: XOR<StoryPlaySessionUpdateManyMutationInput, StoryPlaySessionUncheckedUpdateManyWithoutStoryInput>
  }

  export type StoryNodeUpsertWithWhereUniqueWithoutStoryInput = {
    where: StoryNodeWhereUniqueInput
    update: XOR<StoryNodeUpdateWithoutStoryInput, StoryNodeUncheckedUpdateWithoutStoryInput>
    create: XOR<StoryNodeCreateWithoutStoryInput, StoryNodeUncheckedCreateWithoutStoryInput>
  }

  export type StoryNodeUpdateWithWhereUniqueWithoutStoryInput = {
    where: StoryNodeWhereUniqueInput
    data: XOR<StoryNodeUpdateWithoutStoryInput, StoryNodeUncheckedUpdateWithoutStoryInput>
  }

  export type StoryNodeUpdateManyWithWhereWithoutStoryInput = {
    where: StoryNodeScalarWhereInput
    data: XOR<StoryNodeUpdateManyMutationInput, StoryNodeUncheckedUpdateManyWithoutStoryInput>
  }

  export type StoryNodeScalarWhereInput = {
    AND?: StoryNodeScalarWhereInput | StoryNodeScalarWhereInput[]
    OR?: StoryNodeScalarWhereInput[]
    NOT?: StoryNodeScalarWhereInput | StoryNodeScalarWhereInput[]
    id?: StringFilter<"StoryNode"> | string
    storyId?: StringFilter<"StoryNode"> | string
    key?: StringFilter<"StoryNode"> | string
    title?: StringNullableFilter<"StoryNode"> | string | null
    synopsis?: StringNullableFilter<"StoryNode"> | string | null
    type?: EnumStoryNodeTypeFilter<"StoryNode"> | $Enums.StoryNodeType
    content?: JsonNullableFilter<"StoryNode">
    media?: JsonNullableFilter<"StoryNode">
    createdAt?: DateTimeFilter<"StoryNode"> | Date | string
    updatedAt?: DateTimeFilter<"StoryNode"> | Date | string
  }

  export type StoryPathUpsertWithWhereUniqueWithoutStoryInput = {
    where: StoryPathWhereUniqueInput
    update: XOR<StoryPathUpdateWithoutStoryInput, StoryPathUncheckedUpdateWithoutStoryInput>
    create: XOR<StoryPathCreateWithoutStoryInput, StoryPathUncheckedCreateWithoutStoryInput>
  }

  export type StoryPathUpdateWithWhereUniqueWithoutStoryInput = {
    where: StoryPathWhereUniqueInput
    data: XOR<StoryPathUpdateWithoutStoryInput, StoryPathUncheckedUpdateWithoutStoryInput>
  }

  export type StoryPathUpdateManyWithWhereWithoutStoryInput = {
    where: StoryPathScalarWhereInput
    data: XOR<StoryPathUpdateManyMutationInput, StoryPathUncheckedUpdateManyWithoutStoryInput>
  }

  export type StoryPathScalarWhereInput = {
    AND?: StoryPathScalarWhereInput | StoryPathScalarWhereInput[]
    OR?: StoryPathScalarWhereInput[]
    NOT?: StoryPathScalarWhereInput | StoryPathScalarWhereInput[]
    id?: StringFilter<"StoryPath"> | string
    storyId?: StringFilter<"StoryPath"> | string
    key?: StringFilter<"StoryPath"> | string
    label?: StringFilter<"StoryPath"> | string
    summary?: StringNullableFilter<"StoryPath"> | string | null
    metadata?: JsonNullableFilter<"StoryPath">
    createdAt?: DateTimeFilter<"StoryPath"> | Date | string
    updatedAt?: DateTimeFilter<"StoryPath"> | Date | string
  }

  export type StoryTransitionUpsertWithWhereUniqueWithoutStoryInput = {
    where: StoryTransitionWhereUniqueInput
    update: XOR<StoryTransitionUpdateWithoutStoryInput, StoryTransitionUncheckedUpdateWithoutStoryInput>
    create: XOR<StoryTransitionCreateWithoutStoryInput, StoryTransitionUncheckedCreateWithoutStoryInput>
  }

  export type StoryTransitionUpdateWithWhereUniqueWithoutStoryInput = {
    where: StoryTransitionWhereUniqueInput
    data: XOR<StoryTransitionUpdateWithoutStoryInput, StoryTransitionUncheckedUpdateWithoutStoryInput>
  }

  export type StoryTransitionUpdateManyWithWhereWithoutStoryInput = {
    where: StoryTransitionScalarWhereInput
    data: XOR<StoryTransitionUpdateManyMutationInput, StoryTransitionUncheckedUpdateManyWithoutStoryInput>
  }

  export type StoryTransitionScalarWhereInput = {
    AND?: StoryTransitionScalarWhereInput | StoryTransitionScalarWhereInput[]
    OR?: StoryTransitionScalarWhereInput[]
    NOT?: StoryTransitionScalarWhereInput | StoryTransitionScalarWhereInput[]
    id?: StringFilter<"StoryTransition"> | string
    storyId?: StringFilter<"StoryTransition"> | string
    fromNodeId?: StringFilter<"StoryTransition"> | string
    pathId?: StringFilter<"StoryTransition"> | string
    toNodeId?: StringNullableFilter<"StoryTransition"> | string | null
    ordering?: IntNullableFilter<"StoryTransition"> | number | null
    condition?: JsonNullableFilter<"StoryTransition">
    effect?: JsonNullableFilter<"StoryTransition">
    createdAt?: DateTimeFilter<"StoryTransition"> | Date | string
    updatedAt?: DateTimeFilter<"StoryTransition"> | Date | string
  }

  export type AvatarProfileUpsertWithWhereUniqueWithoutStoryInput = {
    where: AvatarProfileWhereUniqueInput
    update: XOR<AvatarProfileUpdateWithoutStoryInput, AvatarProfileUncheckedUpdateWithoutStoryInput>
    create: XOR<AvatarProfileCreateWithoutStoryInput, AvatarProfileUncheckedCreateWithoutStoryInput>
  }

  export type AvatarProfileUpdateWithWhereUniqueWithoutStoryInput = {
    where: AvatarProfileWhereUniqueInput
    data: XOR<AvatarProfileUpdateWithoutStoryInput, AvatarProfileUncheckedUpdateWithoutStoryInput>
  }

  export type AvatarProfileUpdateManyWithWhereWithoutStoryInput = {
    where: AvatarProfileScalarWhereInput
    data: XOR<AvatarProfileUpdateManyMutationInput, AvatarProfileUncheckedUpdateManyWithoutStoryInput>
  }

  export type AvatarProfileScalarWhereInput = {
    AND?: AvatarProfileScalarWhereInput | AvatarProfileScalarWhereInput[]
    OR?: AvatarProfileScalarWhereInput[]
    NOT?: AvatarProfileScalarWhereInput | AvatarProfileScalarWhereInput[]
    id?: StringFilter<"AvatarProfile"> | string
    name?: StringFilter<"AvatarProfile"> | string
    age?: IntNullableFilter<"AvatarProfile"> | number | null
    background?: StringNullableFilter<"AvatarProfile"> | string | null
    appearance?: JsonNullableFilter<"AvatarProfile">
    initialResources?: JsonFilter<"AvatarProfile">
    socialContext?: JsonNullableFilter<"AvatarProfile">
    isPlayable?: BoolFilter<"AvatarProfile"> | boolean
    storyId?: StringNullableFilter<"AvatarProfile"> | string | null
    experienceClicks?: IntFilter<"AvatarProfile"> | number
    experienceStarts?: IntFilter<"AvatarProfile"> | number
    createdAt?: DateTimeFilter<"AvatarProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AvatarProfile"> | Date | string
  }

  export type StoryAuditLogUpsertWithWhereUniqueWithoutStoryInput = {
    where: StoryAuditLogWhereUniqueInput
    update: XOR<StoryAuditLogUpdateWithoutStoryInput, StoryAuditLogUncheckedUpdateWithoutStoryInput>
    create: XOR<StoryAuditLogCreateWithoutStoryInput, StoryAuditLogUncheckedCreateWithoutStoryInput>
  }

  export type StoryAuditLogUpdateWithWhereUniqueWithoutStoryInput = {
    where: StoryAuditLogWhereUniqueInput
    data: XOR<StoryAuditLogUpdateWithoutStoryInput, StoryAuditLogUncheckedUpdateWithoutStoryInput>
  }

  export type StoryAuditLogUpdateManyWithWhereWithoutStoryInput = {
    where: StoryAuditLogScalarWhereInput
    data: XOR<StoryAuditLogUpdateManyMutationInput, StoryAuditLogUncheckedUpdateManyWithoutStoryInput>
  }

  export type StoryInteractionUpsertWithWhereUniqueWithoutStoryInput = {
    where: StoryInteractionWhereUniqueInput
    update: XOR<StoryInteractionUpdateWithoutStoryInput, StoryInteractionUncheckedUpdateWithoutStoryInput>
    create: XOR<StoryInteractionCreateWithoutStoryInput, StoryInteractionUncheckedCreateWithoutStoryInput>
  }

  export type StoryInteractionUpdateWithWhereUniqueWithoutStoryInput = {
    where: StoryInteractionWhereUniqueInput
    data: XOR<StoryInteractionUpdateWithoutStoryInput, StoryInteractionUncheckedUpdateWithoutStoryInput>
  }

  export type StoryInteractionUpdateManyWithWhereWithoutStoryInput = {
    where: StoryInteractionScalarWhereInput
    data: XOR<StoryInteractionUpdateManyMutationInput, StoryInteractionUncheckedUpdateManyWithoutStoryInput>
  }

  export type TwineStoryCreateWithoutVersionsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutVersionsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutVersionsInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutVersionsInput, TwineStoryUncheckedCreateWithoutVersionsInput>
  }

  export type TwineStoryCreateWithoutLatestVersionInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutLatestVersionInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutLatestVersionInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutLatestVersionInput, TwineStoryUncheckedCreateWithoutLatestVersionInput>
  }

  export type UserCreateWithoutAuthoredVersionsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthoredVersionsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthoredVersionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthoredVersionsInput, UserUncheckedCreateWithoutAuthoredVersionsInput>
  }

  export type UserCreateWithoutReviewedVersionsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewedVersionsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewedVersionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedVersionsInput, UserUncheckedCreateWithoutReviewedVersionsInput>
  }

  export type StoryReviewCreateWithoutVersionInput = {
    id?: string
    status: $Enums.StoryStatus
    feedback?: string | null
    createdAt?: Date | string
    reviewer: UserCreateNestedOneWithoutReviewsInput
  }

  export type StoryReviewUncheckedCreateWithoutVersionInput = {
    id?: string
    reviewerId: string
    status: $Enums.StoryStatus
    feedback?: string | null
    createdAt?: Date | string
  }

  export type StoryReviewCreateOrConnectWithoutVersionInput = {
    where: StoryReviewWhereUniqueInput
    create: XOR<StoryReviewCreateWithoutVersionInput, StoryReviewUncheckedCreateWithoutVersionInput>
  }

  export type StoryReviewCreateManyVersionInputEnvelope = {
    data: StoryReviewCreateManyVersionInput | StoryReviewCreateManyVersionInput[]
    skipDuplicates?: boolean
  }

  export type StoryPlaySessionCreateWithoutVersionInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
    story: TwineStoryCreateNestedOneWithoutPlaySessionsInput
    user?: UserCreateNestedOneWithoutStoryPlaysInput
    session?: UserSessionCreateNestedOneWithoutStoryPlaysInput
  }

  export type StoryPlaySessionUncheckedCreateWithoutVersionInput = {
    id?: string
    storyId: string
    userId?: string | null
    sessionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
  }

  export type StoryPlaySessionCreateOrConnectWithoutVersionInput = {
    where: StoryPlaySessionWhereUniqueInput
    create: XOR<StoryPlaySessionCreateWithoutVersionInput, StoryPlaySessionUncheckedCreateWithoutVersionInput>
  }

  export type StoryPlaySessionCreateManyVersionInputEnvelope = {
    data: StoryPlaySessionCreateManyVersionInput | StoryPlaySessionCreateManyVersionInput[]
    skipDuplicates?: boolean
  }

  export type TwineStoryUpsertWithoutVersionsInput = {
    update: XOR<TwineStoryUpdateWithoutVersionsInput, TwineStoryUncheckedUpdateWithoutVersionsInput>
    create: XOR<TwineStoryCreateWithoutVersionsInput, TwineStoryUncheckedCreateWithoutVersionsInput>
    where?: TwineStoryWhereInput
  }

  export type TwineStoryUpdateToOneWithWhereWithoutVersionsInput = {
    where?: TwineStoryWhereInput
    data: XOR<TwineStoryUpdateWithoutVersionsInput, TwineStoryUncheckedUpdateWithoutVersionsInput>
  }

  export type TwineStoryUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUpsertWithoutLatestVersionInput = {
    update: XOR<TwineStoryUpdateWithoutLatestVersionInput, TwineStoryUncheckedUpdateWithoutLatestVersionInput>
    create: XOR<TwineStoryCreateWithoutLatestVersionInput, TwineStoryUncheckedCreateWithoutLatestVersionInput>
    where?: TwineStoryWhereInput
  }

  export type TwineStoryUpdateToOneWithWhereWithoutLatestVersionInput = {
    where?: TwineStoryWhereInput
    data: XOR<TwineStoryUpdateWithoutLatestVersionInput, TwineStoryUncheckedUpdateWithoutLatestVersionInput>
  }

  export type TwineStoryUpdateWithoutLatestVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutLatestVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type UserUpsertWithoutAuthoredVersionsInput = {
    update: XOR<UserUpdateWithoutAuthoredVersionsInput, UserUncheckedUpdateWithoutAuthoredVersionsInput>
    create: XOR<UserCreateWithoutAuthoredVersionsInput, UserUncheckedCreateWithoutAuthoredVersionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthoredVersionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthoredVersionsInput, UserUncheckedUpdateWithoutAuthoredVersionsInput>
  }

  export type UserUpdateWithoutAuthoredVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthoredVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReviewedVersionsInput = {
    update: XOR<UserUpdateWithoutReviewedVersionsInput, UserUncheckedUpdateWithoutReviewedVersionsInput>
    create: XOR<UserCreateWithoutReviewedVersionsInput, UserUncheckedCreateWithoutReviewedVersionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedVersionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedVersionsInput, UserUncheckedUpdateWithoutReviewedVersionsInput>
  }

  export type UserUpdateWithoutReviewedVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StoryReviewUpsertWithWhereUniqueWithoutVersionInput = {
    where: StoryReviewWhereUniqueInput
    update: XOR<StoryReviewUpdateWithoutVersionInput, StoryReviewUncheckedUpdateWithoutVersionInput>
    create: XOR<StoryReviewCreateWithoutVersionInput, StoryReviewUncheckedCreateWithoutVersionInput>
  }

  export type StoryReviewUpdateWithWhereUniqueWithoutVersionInput = {
    where: StoryReviewWhereUniqueInput
    data: XOR<StoryReviewUpdateWithoutVersionInput, StoryReviewUncheckedUpdateWithoutVersionInput>
  }

  export type StoryReviewUpdateManyWithWhereWithoutVersionInput = {
    where: StoryReviewScalarWhereInput
    data: XOR<StoryReviewUpdateManyMutationInput, StoryReviewUncheckedUpdateManyWithoutVersionInput>
  }

  export type StoryPlaySessionUpsertWithWhereUniqueWithoutVersionInput = {
    where: StoryPlaySessionWhereUniqueInput
    update: XOR<StoryPlaySessionUpdateWithoutVersionInput, StoryPlaySessionUncheckedUpdateWithoutVersionInput>
    create: XOR<StoryPlaySessionCreateWithoutVersionInput, StoryPlaySessionUncheckedCreateWithoutVersionInput>
  }

  export type StoryPlaySessionUpdateWithWhereUniqueWithoutVersionInput = {
    where: StoryPlaySessionWhereUniqueInput
    data: XOR<StoryPlaySessionUpdateWithoutVersionInput, StoryPlaySessionUncheckedUpdateWithoutVersionInput>
  }

  export type StoryPlaySessionUpdateManyWithWhereWithoutVersionInput = {
    where: StoryPlaySessionScalarWhereInput
    data: XOR<StoryPlaySessionUpdateManyMutationInput, StoryPlaySessionUncheckedUpdateManyWithoutVersionInput>
  }

  export type TwineStoryCreateWithoutAuditLogsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutAuditLogsInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutAuditLogsInput, TwineStoryUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutStoryAuditLogsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStoryAuditLogsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStoryAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoryAuditLogsInput, UserUncheckedCreateWithoutStoryAuditLogsInput>
  }

  export type TwineStoryUpsertWithoutAuditLogsInput = {
    update: XOR<TwineStoryUpdateWithoutAuditLogsInput, TwineStoryUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<TwineStoryCreateWithoutAuditLogsInput, TwineStoryUncheckedCreateWithoutAuditLogsInput>
    where?: TwineStoryWhereInput
  }

  export type TwineStoryUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TwineStoryWhereInput
    data: XOR<TwineStoryUpdateWithoutAuditLogsInput, TwineStoryUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TwineStoryUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type UserUpsertWithoutStoryAuditLogsInput = {
    update: XOR<UserUpdateWithoutStoryAuditLogsInput, UserUncheckedUpdateWithoutStoryAuditLogsInput>
    create: XOR<UserCreateWithoutStoryAuditLogsInput, UserUncheckedCreateWithoutStoryAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoryAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoryAuditLogsInput, UserUncheckedUpdateWithoutStoryAuditLogsInput>
  }

  export type UserUpdateWithoutStoryAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStoryAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StoryVersionCreateWithoutReviewsInput = {
    id?: string
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    story: TwineStoryCreateNestedOneWithoutVersionsInput
    featuredIn?: TwineStoryCreateNestedOneWithoutLatestVersionInput
    author?: UserCreateNestedOneWithoutAuthoredVersionsInput
    reviewer?: UserCreateNestedOneWithoutReviewedVersionsInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionUncheckedCreateWithoutReviewsInput = {
    id?: string
    storyId: string
    authorId?: string | null
    reviewerId?: string | null
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    featuredIn?: TwineStoryUncheckedCreateNestedOneWithoutLatestVersionInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionCreateOrConnectWithoutReviewsInput = {
    where: StoryVersionWhereUniqueInput
    create: XOR<StoryVersionCreateWithoutReviewsInput, StoryVersionUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type StoryVersionUpsertWithoutReviewsInput = {
    update: XOR<StoryVersionUpdateWithoutReviewsInput, StoryVersionUncheckedUpdateWithoutReviewsInput>
    create: XOR<StoryVersionCreateWithoutReviewsInput, StoryVersionUncheckedCreateWithoutReviewsInput>
    where?: StoryVersionWhereInput
  }

  export type StoryVersionUpdateToOneWithWhereWithoutReviewsInput = {
    where?: StoryVersionWhereInput
    data: XOR<StoryVersionUpdateWithoutReviewsInput, StoryVersionUncheckedUpdateWithoutReviewsInput>
  }

  export type StoryVersionUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    story?: TwineStoryUpdateOneRequiredWithoutVersionsNestedInput
    featuredIn?: TwineStoryUpdateOneWithoutLatestVersionNestedInput
    author?: UserUpdateOneWithoutAuthoredVersionsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedVersionsNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutVersionNestedInput
  }

  export type StoryVersionUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featuredIn?: TwineStoryUncheckedUpdateOneWithoutLatestVersionNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TwineStoryCreateWithoutPlaySessionsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutPlaySessionsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutPlaySessionsInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutPlaySessionsInput, TwineStoryUncheckedCreateWithoutPlaySessionsInput>
  }

  export type StoryVersionCreateWithoutPlaySessionsInput = {
    id?: string
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    story: TwineStoryCreateNestedOneWithoutVersionsInput
    featuredIn?: TwineStoryCreateNestedOneWithoutLatestVersionInput
    author?: UserCreateNestedOneWithoutAuthoredVersionsInput
    reviewer?: UserCreateNestedOneWithoutReviewedVersionsInput
    reviews?: StoryReviewCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionUncheckedCreateWithoutPlaySessionsInput = {
    id?: string
    storyId: string
    authorId?: string | null
    reviewerId?: string | null
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    featuredIn?: TwineStoryUncheckedCreateNestedOneWithoutLatestVersionInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutVersionInput
  }

  export type StoryVersionCreateOrConnectWithoutPlaySessionsInput = {
    where: StoryVersionWhereUniqueInput
    create: XOR<StoryVersionCreateWithoutPlaySessionsInput, StoryVersionUncheckedCreateWithoutPlaySessionsInput>
  }

  export type UserCreateWithoutStoryPlaysInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStoryPlaysInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStoryPlaysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoryPlaysInput, UserUncheckedCreateWithoutStoryPlaysInput>
  }

  export type UserSessionCreateWithoutStoryPlaysInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSessionsInput
    journeys?: JourneyProgressCreateNestedManyWithoutSessionInput
    achievements?: UserAchievementCreateNestedManyWithoutSessionInput
    storyInteractions?: StoryInteractionCreateNestedManyWithoutSessionInput
  }

  export type UserSessionUncheckedCreateWithoutStoryPlaysInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    userId?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutSessionInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutSessionInput
    storyInteractions?: StoryInteractionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type UserSessionCreateOrConnectWithoutStoryPlaysInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutStoryPlaysInput, UserSessionUncheckedCreateWithoutStoryPlaysInput>
  }

  export type TwineStoryUpsertWithoutPlaySessionsInput = {
    update: XOR<TwineStoryUpdateWithoutPlaySessionsInput, TwineStoryUncheckedUpdateWithoutPlaySessionsInput>
    create: XOR<TwineStoryCreateWithoutPlaySessionsInput, TwineStoryUncheckedCreateWithoutPlaySessionsInput>
    where?: TwineStoryWhereInput
  }

  export type TwineStoryUpdateToOneWithWhereWithoutPlaySessionsInput = {
    where?: TwineStoryWhereInput
    data: XOR<TwineStoryUpdateWithoutPlaySessionsInput, TwineStoryUncheckedUpdateWithoutPlaySessionsInput>
  }

  export type TwineStoryUpdateWithoutPlaySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutPlaySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryVersionUpsertWithoutPlaySessionsInput = {
    update: XOR<StoryVersionUpdateWithoutPlaySessionsInput, StoryVersionUncheckedUpdateWithoutPlaySessionsInput>
    create: XOR<StoryVersionCreateWithoutPlaySessionsInput, StoryVersionUncheckedCreateWithoutPlaySessionsInput>
    where?: StoryVersionWhereInput
  }

  export type StoryVersionUpdateToOneWithWhereWithoutPlaySessionsInput = {
    where?: StoryVersionWhereInput
    data: XOR<StoryVersionUpdateWithoutPlaySessionsInput, StoryVersionUncheckedUpdateWithoutPlaySessionsInput>
  }

  export type StoryVersionUpdateWithoutPlaySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    story?: TwineStoryUpdateOneRequiredWithoutVersionsNestedInput
    featuredIn?: TwineStoryUpdateOneWithoutLatestVersionNestedInput
    author?: UserUpdateOneWithoutAuthoredVersionsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedVersionsNestedInput
    reviews?: StoryReviewUpdateManyWithoutVersionNestedInput
  }

  export type StoryVersionUncheckedUpdateWithoutPlaySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featuredIn?: TwineStoryUncheckedUpdateOneWithoutLatestVersionNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type UserUpsertWithoutStoryPlaysInput = {
    update: XOR<UserUpdateWithoutStoryPlaysInput, UserUncheckedUpdateWithoutStoryPlaysInput>
    create: XOR<UserCreateWithoutStoryPlaysInput, UserUncheckedCreateWithoutStoryPlaysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoryPlaysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoryPlaysInput, UserUncheckedUpdateWithoutStoryPlaysInput>
  }

  export type UserUpdateWithoutStoryPlaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStoryPlaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserSessionUpsertWithoutStoryPlaysInput = {
    update: XOR<UserSessionUpdateWithoutStoryPlaysInput, UserSessionUncheckedUpdateWithoutStoryPlaysInput>
    create: XOR<UserSessionCreateWithoutStoryPlaysInput, UserSessionUncheckedCreateWithoutStoryPlaysInput>
    where?: UserSessionWhereInput
  }

  export type UserSessionUpdateToOneWithWhereWithoutStoryPlaysInput = {
    where?: UserSessionWhereInput
    data: XOR<UserSessionUpdateWithoutStoryPlaysInput, UserSessionUncheckedUpdateWithoutStoryPlaysInput>
  }

  export type UserSessionUpdateWithoutStoryPlaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSessionsNestedInput
    journeys?: JourneyProgressUpdateManyWithoutSessionNestedInput
    achievements?: UserAchievementUpdateManyWithoutSessionNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutSessionNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutStoryPlaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journeys?: JourneyProgressUncheckedUpdateManyWithoutSessionNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutSessionNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TwineStoryCreateWithoutNodesInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutNodesInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutNodesInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutNodesInput, TwineStoryUncheckedCreateWithoutNodesInput>
  }

  export type StoryTransitionCreateWithoutFromNodeInput = {
    id?: string
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    story: TwineStoryCreateNestedOneWithoutTransitionsInput
    toNode?: StoryNodeCreateNestedOneWithoutIncomingInput
    path: StoryPathCreateNestedOneWithoutTransitionsInput
  }

  export type StoryTransitionUncheckedCreateWithoutFromNodeInput = {
    id?: string
    storyId: string
    pathId: string
    toNodeId?: string | null
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryTransitionCreateOrConnectWithoutFromNodeInput = {
    where: StoryTransitionWhereUniqueInput
    create: XOR<StoryTransitionCreateWithoutFromNodeInput, StoryTransitionUncheckedCreateWithoutFromNodeInput>
  }

  export type StoryTransitionCreateManyFromNodeInputEnvelope = {
    data: StoryTransitionCreateManyFromNodeInput | StoryTransitionCreateManyFromNodeInput[]
    skipDuplicates?: boolean
  }

  export type StoryTransitionCreateWithoutToNodeInput = {
    id?: string
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    story: TwineStoryCreateNestedOneWithoutTransitionsInput
    fromNode: StoryNodeCreateNestedOneWithoutOutgoingInput
    path: StoryPathCreateNestedOneWithoutTransitionsInput
  }

  export type StoryTransitionUncheckedCreateWithoutToNodeInput = {
    id?: string
    storyId: string
    fromNodeId: string
    pathId: string
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryTransitionCreateOrConnectWithoutToNodeInput = {
    where: StoryTransitionWhereUniqueInput
    create: XOR<StoryTransitionCreateWithoutToNodeInput, StoryTransitionUncheckedCreateWithoutToNodeInput>
  }

  export type StoryTransitionCreateManyToNodeInputEnvelope = {
    data: StoryTransitionCreateManyToNodeInput | StoryTransitionCreateManyToNodeInput[]
    skipDuplicates?: boolean
  }

  export type TwineStoryUpsertWithoutNodesInput = {
    update: XOR<TwineStoryUpdateWithoutNodesInput, TwineStoryUncheckedUpdateWithoutNodesInput>
    create: XOR<TwineStoryCreateWithoutNodesInput, TwineStoryUncheckedCreateWithoutNodesInput>
    where?: TwineStoryWhereInput
  }

  export type TwineStoryUpdateToOneWithWhereWithoutNodesInput = {
    where?: TwineStoryWhereInput
    data: XOR<TwineStoryUpdateWithoutNodesInput, TwineStoryUncheckedUpdateWithoutNodesInput>
  }

  export type TwineStoryUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryTransitionUpsertWithWhereUniqueWithoutFromNodeInput = {
    where: StoryTransitionWhereUniqueInput
    update: XOR<StoryTransitionUpdateWithoutFromNodeInput, StoryTransitionUncheckedUpdateWithoutFromNodeInput>
    create: XOR<StoryTransitionCreateWithoutFromNodeInput, StoryTransitionUncheckedCreateWithoutFromNodeInput>
  }

  export type StoryTransitionUpdateWithWhereUniqueWithoutFromNodeInput = {
    where: StoryTransitionWhereUniqueInput
    data: XOR<StoryTransitionUpdateWithoutFromNodeInput, StoryTransitionUncheckedUpdateWithoutFromNodeInput>
  }

  export type StoryTransitionUpdateManyWithWhereWithoutFromNodeInput = {
    where: StoryTransitionScalarWhereInput
    data: XOR<StoryTransitionUpdateManyMutationInput, StoryTransitionUncheckedUpdateManyWithoutFromNodeInput>
  }

  export type StoryTransitionUpsertWithWhereUniqueWithoutToNodeInput = {
    where: StoryTransitionWhereUniqueInput
    update: XOR<StoryTransitionUpdateWithoutToNodeInput, StoryTransitionUncheckedUpdateWithoutToNodeInput>
    create: XOR<StoryTransitionCreateWithoutToNodeInput, StoryTransitionUncheckedCreateWithoutToNodeInput>
  }

  export type StoryTransitionUpdateWithWhereUniqueWithoutToNodeInput = {
    where: StoryTransitionWhereUniqueInput
    data: XOR<StoryTransitionUpdateWithoutToNodeInput, StoryTransitionUncheckedUpdateWithoutToNodeInput>
  }

  export type StoryTransitionUpdateManyWithWhereWithoutToNodeInput = {
    where: StoryTransitionScalarWhereInput
    data: XOR<StoryTransitionUpdateManyMutationInput, StoryTransitionUncheckedUpdateManyWithoutToNodeInput>
  }

  export type TwineStoryCreateWithoutPathsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutPathsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutPathsInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutPathsInput, TwineStoryUncheckedCreateWithoutPathsInput>
  }

  export type StoryTransitionCreateWithoutPathInput = {
    id?: string
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    story: TwineStoryCreateNestedOneWithoutTransitionsInput
    fromNode: StoryNodeCreateNestedOneWithoutOutgoingInput
    toNode?: StoryNodeCreateNestedOneWithoutIncomingInput
  }

  export type StoryTransitionUncheckedCreateWithoutPathInput = {
    id?: string
    storyId: string
    fromNodeId: string
    toNodeId?: string | null
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryTransitionCreateOrConnectWithoutPathInput = {
    where: StoryTransitionWhereUniqueInput
    create: XOR<StoryTransitionCreateWithoutPathInput, StoryTransitionUncheckedCreateWithoutPathInput>
  }

  export type StoryTransitionCreateManyPathInputEnvelope = {
    data: StoryTransitionCreateManyPathInput | StoryTransitionCreateManyPathInput[]
    skipDuplicates?: boolean
  }

  export type TwineStoryUpsertWithoutPathsInput = {
    update: XOR<TwineStoryUpdateWithoutPathsInput, TwineStoryUncheckedUpdateWithoutPathsInput>
    create: XOR<TwineStoryCreateWithoutPathsInput, TwineStoryUncheckedCreateWithoutPathsInput>
    where?: TwineStoryWhereInput
  }

  export type TwineStoryUpdateToOneWithWhereWithoutPathsInput = {
    where?: TwineStoryWhereInput
    data: XOR<TwineStoryUpdateWithoutPathsInput, TwineStoryUncheckedUpdateWithoutPathsInput>
  }

  export type TwineStoryUpdateWithoutPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryTransitionUpsertWithWhereUniqueWithoutPathInput = {
    where: StoryTransitionWhereUniqueInput
    update: XOR<StoryTransitionUpdateWithoutPathInput, StoryTransitionUncheckedUpdateWithoutPathInput>
    create: XOR<StoryTransitionCreateWithoutPathInput, StoryTransitionUncheckedCreateWithoutPathInput>
  }

  export type StoryTransitionUpdateWithWhereUniqueWithoutPathInput = {
    where: StoryTransitionWhereUniqueInput
    data: XOR<StoryTransitionUpdateWithoutPathInput, StoryTransitionUncheckedUpdateWithoutPathInput>
  }

  export type StoryTransitionUpdateManyWithWhereWithoutPathInput = {
    where: StoryTransitionScalarWhereInput
    data: XOR<StoryTransitionUpdateManyMutationInput, StoryTransitionUncheckedUpdateManyWithoutPathInput>
  }

  export type TwineStoryCreateWithoutTransitionsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutTransitionsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutTransitionsInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutTransitionsInput, TwineStoryUncheckedCreateWithoutTransitionsInput>
  }

  export type StoryNodeCreateWithoutOutgoingInput = {
    id?: string
    key: string
    title?: string | null
    synopsis?: string | null
    type?: $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    story: TwineStoryCreateNestedOneWithoutNodesInput
    incoming?: StoryTransitionCreateNestedManyWithoutToNodeInput
  }

  export type StoryNodeUncheckedCreateWithoutOutgoingInput = {
    id?: string
    storyId: string
    key: string
    title?: string | null
    synopsis?: string | null
    type?: $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    incoming?: StoryTransitionUncheckedCreateNestedManyWithoutToNodeInput
  }

  export type StoryNodeCreateOrConnectWithoutOutgoingInput = {
    where: StoryNodeWhereUniqueInput
    create: XOR<StoryNodeCreateWithoutOutgoingInput, StoryNodeUncheckedCreateWithoutOutgoingInput>
  }

  export type StoryNodeCreateWithoutIncomingInput = {
    id?: string
    key: string
    title?: string | null
    synopsis?: string | null
    type?: $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    story: TwineStoryCreateNestedOneWithoutNodesInput
    outgoing?: StoryTransitionCreateNestedManyWithoutFromNodeInput
  }

  export type StoryNodeUncheckedCreateWithoutIncomingInput = {
    id?: string
    storyId: string
    key: string
    title?: string | null
    synopsis?: string | null
    type?: $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    outgoing?: StoryTransitionUncheckedCreateNestedManyWithoutFromNodeInput
  }

  export type StoryNodeCreateOrConnectWithoutIncomingInput = {
    where: StoryNodeWhereUniqueInput
    create: XOR<StoryNodeCreateWithoutIncomingInput, StoryNodeUncheckedCreateWithoutIncomingInput>
  }

  export type StoryPathCreateWithoutTransitionsInput = {
    id?: string
    key: string
    label: string
    summary?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    story: TwineStoryCreateNestedOneWithoutPathsInput
  }

  export type StoryPathUncheckedCreateWithoutTransitionsInput = {
    id?: string
    storyId: string
    key: string
    label: string
    summary?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryPathCreateOrConnectWithoutTransitionsInput = {
    where: StoryPathWhereUniqueInput
    create: XOR<StoryPathCreateWithoutTransitionsInput, StoryPathUncheckedCreateWithoutTransitionsInput>
  }

  export type TwineStoryUpsertWithoutTransitionsInput = {
    update: XOR<TwineStoryUpdateWithoutTransitionsInput, TwineStoryUncheckedUpdateWithoutTransitionsInput>
    create: XOR<TwineStoryCreateWithoutTransitionsInput, TwineStoryUncheckedCreateWithoutTransitionsInput>
    where?: TwineStoryWhereInput
  }

  export type TwineStoryUpdateToOneWithWhereWithoutTransitionsInput = {
    where?: TwineStoryWhereInput
    data: XOR<TwineStoryUpdateWithoutTransitionsInput, TwineStoryUncheckedUpdateWithoutTransitionsInput>
  }

  export type TwineStoryUpdateWithoutTransitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutTransitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryNodeUpsertWithoutOutgoingInput = {
    update: XOR<StoryNodeUpdateWithoutOutgoingInput, StoryNodeUncheckedUpdateWithoutOutgoingInput>
    create: XOR<StoryNodeCreateWithoutOutgoingInput, StoryNodeUncheckedCreateWithoutOutgoingInput>
    where?: StoryNodeWhereInput
  }

  export type StoryNodeUpdateToOneWithWhereWithoutOutgoingInput = {
    where?: StoryNodeWhereInput
    data: XOR<StoryNodeUpdateWithoutOutgoingInput, StoryNodeUncheckedUpdateWithoutOutgoingInput>
  }

  export type StoryNodeUpdateWithoutOutgoingInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStoryNodeTypeFieldUpdateOperationsInput | $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneRequiredWithoutNodesNestedInput
    incoming?: StoryTransitionUpdateManyWithoutToNodeNestedInput
  }

  export type StoryNodeUncheckedUpdateWithoutOutgoingInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStoryNodeTypeFieldUpdateOperationsInput | $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incoming?: StoryTransitionUncheckedUpdateManyWithoutToNodeNestedInput
  }

  export type StoryNodeUpsertWithoutIncomingInput = {
    update: XOR<StoryNodeUpdateWithoutIncomingInput, StoryNodeUncheckedUpdateWithoutIncomingInput>
    create: XOR<StoryNodeCreateWithoutIncomingInput, StoryNodeUncheckedCreateWithoutIncomingInput>
    where?: StoryNodeWhereInput
  }

  export type StoryNodeUpdateToOneWithWhereWithoutIncomingInput = {
    where?: StoryNodeWhereInput
    data: XOR<StoryNodeUpdateWithoutIncomingInput, StoryNodeUncheckedUpdateWithoutIncomingInput>
  }

  export type StoryNodeUpdateWithoutIncomingInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStoryNodeTypeFieldUpdateOperationsInput | $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneRequiredWithoutNodesNestedInput
    outgoing?: StoryTransitionUpdateManyWithoutFromNodeNestedInput
  }

  export type StoryNodeUncheckedUpdateWithoutIncomingInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStoryNodeTypeFieldUpdateOperationsInput | $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outgoing?: StoryTransitionUncheckedUpdateManyWithoutFromNodeNestedInput
  }

  export type StoryPathUpsertWithoutTransitionsInput = {
    update: XOR<StoryPathUpdateWithoutTransitionsInput, StoryPathUncheckedUpdateWithoutTransitionsInput>
    create: XOR<StoryPathCreateWithoutTransitionsInput, StoryPathUncheckedCreateWithoutTransitionsInput>
    where?: StoryPathWhereInput
  }

  export type StoryPathUpdateToOneWithWhereWithoutTransitionsInput = {
    where?: StoryPathWhereInput
    data: XOR<StoryPathUpdateWithoutTransitionsInput, StoryPathUncheckedUpdateWithoutTransitionsInput>
  }

  export type StoryPathUpdateWithoutTransitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneRequiredWithoutPathsNestedInput
  }

  export type StoryPathUncheckedUpdateWithoutTransitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwineStoryCreateWithoutAvatarsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutAvatarsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
    interactions?: StoryInteractionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutAvatarsInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutAvatarsInput, TwineStoryUncheckedCreateWithoutAvatarsInput>
  }

  export type StoryInteractionCreateWithoutAvatarInput = {
    id?: string
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    story?: TwineStoryCreateNestedOneWithoutInteractionsInput
    session?: UserSessionCreateNestedOneWithoutStoryInteractionsInput
    user?: UserCreateNestedOneWithoutStoryInteractionsInput
  }

  export type StoryInteractionUncheckedCreateWithoutAvatarInput = {
    id?: string
    storyId?: string | null
    sessionId?: string | null
    userId?: string | null
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryInteractionCreateOrConnectWithoutAvatarInput = {
    where: StoryInteractionWhereUniqueInput
    create: XOR<StoryInteractionCreateWithoutAvatarInput, StoryInteractionUncheckedCreateWithoutAvatarInput>
  }

  export type StoryInteractionCreateManyAvatarInputEnvelope = {
    data: StoryInteractionCreateManyAvatarInput | StoryInteractionCreateManyAvatarInput[]
    skipDuplicates?: boolean
  }

  export type TwineStoryUpsertWithoutAvatarsInput = {
    update: XOR<TwineStoryUpdateWithoutAvatarsInput, TwineStoryUncheckedUpdateWithoutAvatarsInput>
    create: XOR<TwineStoryCreateWithoutAvatarsInput, TwineStoryUncheckedCreateWithoutAvatarsInput>
    where?: TwineStoryWhereInput
  }

  export type TwineStoryUpdateToOneWithWhereWithoutAvatarsInput = {
    where?: TwineStoryWhereInput
    data: XOR<TwineStoryUpdateWithoutAvatarsInput, TwineStoryUncheckedUpdateWithoutAvatarsInput>
  }

  export type TwineStoryUpdateWithoutAvatarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutAvatarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryInteractionUpsertWithWhereUniqueWithoutAvatarInput = {
    where: StoryInteractionWhereUniqueInput
    update: XOR<StoryInteractionUpdateWithoutAvatarInput, StoryInteractionUncheckedUpdateWithoutAvatarInput>
    create: XOR<StoryInteractionCreateWithoutAvatarInput, StoryInteractionUncheckedCreateWithoutAvatarInput>
  }

  export type StoryInteractionUpdateWithWhereUniqueWithoutAvatarInput = {
    where: StoryInteractionWhereUniqueInput
    data: XOR<StoryInteractionUpdateWithoutAvatarInput, StoryInteractionUncheckedUpdateWithoutAvatarInput>
  }

  export type StoryInteractionUpdateManyWithWhereWithoutAvatarInput = {
    where: StoryInteractionScalarWhereInput
    data: XOR<StoryInteractionUpdateManyMutationInput, StoryInteractionUncheckedUpdateManyWithoutAvatarInput>
  }

  export type AvatarProfileCreateWithoutInteractionsInput = {
    id: string
    name: string
    age?: number | null
    background?: string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: boolean
    experienceClicks?: number
    experienceStarts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    story?: TwineStoryCreateNestedOneWithoutAvatarsInput
  }

  export type AvatarProfileUncheckedCreateWithoutInteractionsInput = {
    id: string
    name: string
    age?: number | null
    background?: string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: boolean
    storyId?: string | null
    experienceClicks?: number
    experienceStarts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvatarProfileCreateOrConnectWithoutInteractionsInput = {
    where: AvatarProfileWhereUniqueInput
    create: XOR<AvatarProfileCreateWithoutInteractionsInput, AvatarProfileUncheckedCreateWithoutInteractionsInput>
  }

  export type TwineStoryCreateWithoutInteractionsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutStoriesInput
    originalCreator?: UserCreateNestedOneWithoutOriginalStoriesInput
    originalCreatorProfile?: CreatorProfileCreateNestedOneWithoutStoriesSubmittedInput
    approvedBy?: UserCreateNestedOneWithoutApprovedStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    latestVersion?: StoryVersionCreateNestedOneWithoutFeaturedInInput
    playSessions?: StoryPlaySessionCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeCreateNestedManyWithoutStoryInput
    paths?: StoryPathCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryUncheckedCreateWithoutInteractionsInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    playSessions?: StoryPlaySessionUncheckedCreateNestedManyWithoutStoryInput
    nodes?: StoryNodeUncheckedCreateNestedManyWithoutStoryInput
    paths?: StoryPathUncheckedCreateNestedManyWithoutStoryInput
    transitions?: StoryTransitionUncheckedCreateNestedManyWithoutStoryInput
    avatars?: AvatarProfileUncheckedCreateNestedManyWithoutStoryInput
    auditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutStoryInput
  }

  export type TwineStoryCreateOrConnectWithoutInteractionsInput = {
    where: TwineStoryWhereUniqueInput
    create: XOR<TwineStoryCreateWithoutInteractionsInput, TwineStoryUncheckedCreateWithoutInteractionsInput>
  }

  export type UserSessionCreateWithoutStoryInteractionsInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSessionsInput
    journeys?: JourneyProgressCreateNestedManyWithoutSessionInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutSessionInput
    achievements?: UserAchievementCreateNestedManyWithoutSessionInput
  }

  export type UserSessionUncheckedCreateWithoutStoryInteractionsInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    userId?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutSessionInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutSessionInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutSessionInput
  }

  export type UserSessionCreateOrConnectWithoutStoryInteractionsInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutStoryInteractionsInput, UserSessionUncheckedCreateWithoutStoryInteractionsInput>
  }

  export type UserCreateWithoutStoryInteractionsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionCreateNestedManyWithoutUserInput
    stories?: TwineStoryCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutStoryInteractionsInput = {
    id?: string
    email?: string | null
    username?: string | null
    hashedPassword?: string | null
    role?: $Enums.UserRole
    onboardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAdmin?: boolean
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    storyPlays?: StoryPlaySessionUncheckedCreateNestedManyWithoutUserInput
    stories?: TwineStoryUncheckedCreateNestedManyWithoutOwnerInput
    authoredVersions?: StoryVersionUncheckedCreateNestedManyWithoutAuthorInput
    reviewedVersions?: StoryVersionUncheckedCreateNestedManyWithoutReviewerInput
    reviews?: StoryReviewUncheckedCreateNestedManyWithoutReviewerInput
    creatorProfile?: CreatorProfileUncheckedCreateNestedOneWithoutUserInput
    approvedStories?: TwineStoryUncheckedCreateNestedManyWithoutApprovedByInput
    originalStories?: TwineStoryUncheckedCreateNestedManyWithoutOriginalCreatorInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedCreateNestedManyWithoutLastReviewerInput
    storyAuditLogs?: StoryAuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutStoryInteractionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoryInteractionsInput, UserUncheckedCreateWithoutStoryInteractionsInput>
  }

  export type AvatarProfileUpsertWithoutInteractionsInput = {
    update: XOR<AvatarProfileUpdateWithoutInteractionsInput, AvatarProfileUncheckedUpdateWithoutInteractionsInput>
    create: XOR<AvatarProfileCreateWithoutInteractionsInput, AvatarProfileUncheckedCreateWithoutInteractionsInput>
    where?: AvatarProfileWhereInput
  }

  export type AvatarProfileUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: AvatarProfileWhereInput
    data: XOR<AvatarProfileUpdateWithoutInteractionsInput, AvatarProfileUncheckedUpdateWithoutInteractionsInput>
  }

  export type AvatarProfileUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources?: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    experienceClicks?: IntFieldUpdateOperationsInput | number
    experienceStarts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneWithoutAvatarsNestedInput
  }

  export type AvatarProfileUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources?: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    experienceClicks?: IntFieldUpdateOperationsInput | number
    experienceStarts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwineStoryUpsertWithoutInteractionsInput = {
    update: XOR<TwineStoryUpdateWithoutInteractionsInput, TwineStoryUncheckedUpdateWithoutInteractionsInput>
    create: XOR<TwineStoryCreateWithoutInteractionsInput, TwineStoryUncheckedCreateWithoutInteractionsInput>
    where?: TwineStoryWhereInput
  }

  export type TwineStoryUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: TwineStoryWhereInput
    data: XOR<TwineStoryUpdateWithoutInteractionsInput, TwineStoryUncheckedUpdateWithoutInteractionsInput>
  }

  export type TwineStoryUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type UserSessionUpsertWithoutStoryInteractionsInput = {
    update: XOR<UserSessionUpdateWithoutStoryInteractionsInput, UserSessionUncheckedUpdateWithoutStoryInteractionsInput>
    create: XOR<UserSessionCreateWithoutStoryInteractionsInput, UserSessionUncheckedCreateWithoutStoryInteractionsInput>
    where?: UserSessionWhereInput
  }

  export type UserSessionUpdateToOneWithWhereWithoutStoryInteractionsInput = {
    where?: UserSessionWhereInput
    data: XOR<UserSessionUpdateWithoutStoryInteractionsInput, UserSessionUncheckedUpdateWithoutStoryInteractionsInput>
  }

  export type UserSessionUpdateWithoutStoryInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSessionsNestedInput
    journeys?: JourneyProgressUpdateManyWithoutSessionNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutSessionNestedInput
    achievements?: UserAchievementUpdateManyWithoutSessionNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutStoryInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journeys?: JourneyProgressUncheckedUpdateManyWithoutSessionNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutSessionNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserUpsertWithoutStoryInteractionsInput = {
    update: XOR<UserUpdateWithoutStoryInteractionsInput, UserUncheckedUpdateWithoutStoryInteractionsInput>
    create: XOR<UserCreateWithoutStoryInteractionsInput, UserUncheckedCreateWithoutStoryInteractionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoryInteractionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoryInteractionsInput, UserUncheckedUpdateWithoutStoryInteractionsInput>
  }

  export type UserUpdateWithoutStoryInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutStoryInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    onboardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutUserNestedInput
    stories?: TwineStoryUncheckedUpdateManyWithoutOwnerNestedInput
    authoredVersions?: StoryVersionUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedVersions?: StoryVersionUncheckedUpdateManyWithoutReviewerNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutReviewerNestedInput
    creatorProfile?: CreatorProfileUncheckedUpdateOneWithoutUserNestedInput
    approvedStories?: TwineStoryUncheckedUpdateManyWithoutApprovedByNestedInput
    originalStories?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorNestedInput
    reviewedCreatorProfiles?: CreatorProfileUncheckedUpdateManyWithoutLastReviewerNestedInput
    storyAuditLogs?: StoryAuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    token: string
    kind?: $Enums.SessionKind
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JourneyProgressCreateManyUserInput = {
    id?: string
    scenarioId: string
    sessionId?: string | null
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    achievementId: string
    sessionId?: string | null
    journeyId?: string | null
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoryPlaySessionCreateManyUserInput = {
    id?: string
    storyId: string
    versionId?: string | null
    sessionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
  }

  export type TwineStoryCreateManyOwnerInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryVersionCreateManyAuthorInput = {
    id?: string
    storyId: string
    reviewerId?: string | null
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StoryVersionCreateManyReviewerInput = {
    id?: string
    storyId: string
    authorId?: string | null
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StoryReviewCreateManyReviewerInput = {
    id?: string
    versionId: string
    status: $Enums.StoryStatus
    feedback?: string | null
    createdAt?: Date | string
  }

  export type TwineStoryCreateManyApprovedByInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    originalCreatorProfileId?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwineStoryCreateManyOriginalCreatorInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorProfileId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreatorProfileCreateManyLastReviewerInput = {
    id?: string
    userId: string
    penName?: string | null
    headline?: string | null
    expertiseTags?: CreatorProfileCreateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileCreatefocusAreasInput | string[]
    languages?: CreatorProfileCreatelanguagesInput | string[]
    tagline?: string | null
    biography?: string | null
    websiteUrl?: string | null
    portfolioUrl?: string | null
    contactEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: Date | string | null
    termsAcceptedAt?: Date | string | null
    consentAcceptedAt?: Date | string | null
    consentStatement?: string | null
    status?: $Enums.CreatorProfileStatus
    completedAt?: Date | string | null
    lastReviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryAuditLogCreateManyActorInput = {
    id?: string
    storyId: string
    action: string
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryInteractionCreateManyUserInput = {
    id?: string
    avatarId: string
    storyId?: string | null
    sessionId?: string | null
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journeys?: JourneyProgressUpdateManyWithoutSessionNestedInput
    storyPlays?: StoryPlaySessionUpdateManyWithoutSessionNestedInput
    achievements?: UserAchievementUpdateManyWithoutSessionNestedInput
    storyInteractions?: StoryInteractionUpdateManyWithoutSessionNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journeys?: JourneyProgressUncheckedUpdateManyWithoutSessionNestedInput
    storyPlays?: StoryPlaySessionUncheckedUpdateManyWithoutSessionNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutSessionNestedInput
    storyInteractions?: StoryInteractionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    kind?: EnumSessionKindFieldUpdateOperationsInput | $Enums.SessionKind
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JourneyProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scenario?: ScenarioUpdateOneRequiredWithoutJourneysNestedInput
    session?: UserSessionUpdateOneWithoutJourneysNestedInput
    achievements?: UserAchievementUpdateManyWithoutJourneyNestedInput
  }

  export type JourneyProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievements?: UserAchievementUncheckedUpdateManyWithoutJourneyNestedInput
  }

  export type JourneyProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    achievement?: AchievementUpdateOneRequiredWithoutUserAwardsNestedInput
    session?: UserSessionUpdateOneWithoutAchievementsNestedInput
    journey?: JourneyProgressUpdateOneWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    journeyId?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    journeyId?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoryPlaySessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    story?: TwineStoryUpdateOneRequiredWithoutPlaySessionsNestedInput
    version?: StoryVersionUpdateOneWithoutPlaySessionsNestedInput
    session?: UserSessionUpdateOneWithoutStoryPlaysNestedInput
  }

  export type StoryPlaySessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoryPlaySessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TwineStoryUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryVersionUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    story?: TwineStoryUpdateOneRequiredWithoutVersionsNestedInput
    featuredIn?: TwineStoryUpdateOneWithoutLatestVersionNestedInput
    reviewer?: UserUpdateOneWithoutReviewedVersionsNestedInput
    reviews?: StoryReviewUpdateManyWithoutVersionNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutVersionNestedInput
  }

  export type StoryVersionUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featuredIn?: TwineStoryUncheckedUpdateOneWithoutLatestVersionNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutVersionNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type StoryVersionUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StoryVersionUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    story?: TwineStoryUpdateOneRequiredWithoutVersionsNestedInput
    featuredIn?: TwineStoryUpdateOneWithoutLatestVersionNestedInput
    author?: UserUpdateOneWithoutAuthoredVersionsNestedInput
    reviews?: StoryReviewUpdateManyWithoutVersionNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutVersionNestedInput
  }

  export type StoryVersionUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featuredIn?: TwineStoryUncheckedUpdateOneWithoutLatestVersionNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutVersionNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type StoryVersionUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StoryReviewUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StoryVersionUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type StoryReviewUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryReviewUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwineStoryUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwineStoryUpdateWithoutOriginalCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreatorProfile?: CreatorProfileUpdateOneWithoutStoriesSubmittedNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutOriginalCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateManyWithoutOriginalCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorProfileUpdateWithoutLastReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    penName?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: CreatorProfileUpdateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileUpdatefocusAreasInput | string[]
    languages?: CreatorProfileUpdatelanguagesInput | string[]
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentStatement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCreatorProfileStatusFieldUpdateOperationsInput | $Enums.CreatorProfileStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCreatorProfileNestedInput
    storiesSubmitted?: TwineStoryUpdateManyWithoutOriginalCreatorProfileNestedInput
  }

  export type CreatorProfileUncheckedUpdateWithoutLastReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    penName?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: CreatorProfileUpdateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileUpdatefocusAreasInput | string[]
    languages?: CreatorProfileUpdatelanguagesInput | string[]
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentStatement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCreatorProfileStatusFieldUpdateOperationsInput | $Enums.CreatorProfileStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storiesSubmitted?: TwineStoryUncheckedUpdateManyWithoutOriginalCreatorProfileNestedInput
  }

  export type CreatorProfileUncheckedUpdateManyWithoutLastReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    penName?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    expertiseTags?: CreatorProfileUpdateexpertiseTagsInput | string[]
    focusAreas?: CreatorProfileUpdatefocusAreasInput | string[]
    languages?: CreatorProfileUpdatelanguagesInput | string[]
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    payoutDetails?: NullableJsonNullValueInput | InputJsonValue
    guidelinesAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentStatement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCreatorProfileStatusFieldUpdateOperationsInput | $Enums.CreatorProfileStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryAuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type StoryAuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryAuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryInteractionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: AvatarProfileUpdateOneRequiredWithoutInteractionsNestedInput
    story?: TwineStoryUpdateOneWithoutInteractionsNestedInput
    session?: UserSessionUpdateOneWithoutStoryInteractionsNestedInput
  }

  export type StoryInteractionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: StringFieldUpdateOperationsInput | string
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryInteractionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: StringFieldUpdateOperationsInput | string
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwineStoryCreateManyOriginalCreatorProfileInput = {
    id?: string
    slug: string
    title: string
    summary?: string | null
    tags?: TwineStoryCreatetagsInput | string[]
    visibility?: $Enums.StoryVisibility
    ownerId?: string | null
    originalCreatorId?: string | null
    approvedById?: string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    submittedAt?: Date | string | null
    transferConsentAt?: Date | string | null
    transferConsentIp?: string | null
    transferConsentUserAgent?: string | null
    approvalToken?: string | null
    approvalTokenExpiresAt?: Date | string | null
    approvedAt?: Date | string | null
    reviewComment?: string | null
    creditText?: string | null
    latestVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwineStoryUpdateWithoutOriginalCreatorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutStoriesNestedInput
    originalCreator?: UserUpdateOneWithoutOriginalStoriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    latestVersion?: StoryVersionUpdateOneWithoutFeaturedInNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateWithoutOriginalCreatorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutStoryNestedInput
    nodes?: StoryNodeUncheckedUpdateManyWithoutStoryNestedInput
    paths?: StoryPathUncheckedUpdateManyWithoutStoryNestedInput
    transitions?: StoryTransitionUncheckedUpdateManyWithoutStoryNestedInput
    avatars?: AvatarProfileUncheckedUpdateManyWithoutStoryNestedInput
    auditLogs?: StoryAuditLogUncheckedUpdateManyWithoutStoryNestedInput
    interactions?: StoryInteractionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type TwineStoryUncheckedUpdateManyWithoutOriginalCreatorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TwineStoryUpdatetagsInput | string[]
    visibility?: EnumStoryVisibilityFieldUpdateOperationsInput | $Enums.StoryVisibility
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalCreatorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferConsentIp?: NullableStringFieldUpdateOperationsInput | string | null
    transferConsentUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    approvalToken?: NullableStringFieldUpdateOperationsInput | string | null
    approvalTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    creditText?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JourneyProgressCreateManySessionInput = {
    id?: string
    scenarioId: string
    userId?: string | null
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type StoryPlaySessionCreateManySessionInput = {
    id?: string
    storyId: string
    versionId?: string | null
    userId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
  }

  export type UserAchievementCreateManySessionInput = {
    id?: string
    achievementId: string
    userId?: string | null
    journeyId?: string | null
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoryInteractionCreateManySessionInput = {
    id?: string
    avatarId: string
    storyId?: string | null
    userId?: string | null
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type JourneyProgressUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scenario?: ScenarioUpdateOneRequiredWithoutJourneysNestedInput
    user?: UserUpdateOneWithoutJourneysNestedInput
    achievements?: UserAchievementUpdateManyWithoutJourneyNestedInput
  }

  export type JourneyProgressUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievements?: UserAchievementUncheckedUpdateManyWithoutJourneyNestedInput
  }

  export type JourneyProgressUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StoryPlaySessionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    story?: TwineStoryUpdateOneRequiredWithoutPlaySessionsNestedInput
    version?: StoryVersionUpdateOneWithoutPlaySessionsNestedInput
    user?: UserUpdateOneWithoutStoryPlaysNestedInput
  }

  export type StoryPlaySessionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoryPlaySessionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAchievementUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    achievement?: AchievementUpdateOneRequiredWithoutUserAwardsNestedInput
    user?: UserUpdateOneWithoutAchievementsNestedInput
    journey?: JourneyProgressUpdateOneWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    journeyId?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    journeyId?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoryInteractionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: AvatarProfileUpdateOneRequiredWithoutInteractionsNestedInput
    story?: TwineStoryUpdateOneWithoutInteractionsNestedInput
    user?: UserUpdateOneWithoutStoryInteractionsNestedInput
  }

  export type StoryInteractionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: StringFieldUpdateOperationsInput | string
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryInteractionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: StringFieldUpdateOperationsInput | string
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JourneyProgressCreateManyScenarioInput = {
    id?: string
    userId?: string | null
    sessionId?: string | null
    status?: $Enums.JourneyStatus
    currentNode?: string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type JourneyProgressUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutJourneysNestedInput
    session?: UserSessionUpdateOneWithoutJourneysNestedInput
    achievements?: UserAchievementUpdateManyWithoutJourneyNestedInput
  }

  export type JourneyProgressUncheckedUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievements?: UserAchievementUncheckedUpdateManyWithoutJourneyNestedInput
  }

  export type JourneyProgressUncheckedUpdateManyWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    currentNode?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoints?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAchievementCreateManyJourneyInput = {
    id?: string
    achievementId: string
    userId?: string | null
    sessionId?: string | null
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUpdateWithoutJourneyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    achievement?: AchievementUpdateOneRequiredWithoutUserAwardsNestedInput
    user?: UserUpdateOneWithoutAchievementsNestedInput
    session?: UserSessionUpdateOneWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutJourneyInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUncheckedUpdateManyWithoutJourneyInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementCreateManyAchievementInput = {
    id?: string
    userId?: string | null
    sessionId?: string | null
    journeyId?: string | null
    unlockedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneWithoutAchievementsNestedInput
    session?: UserSessionUpdateOneWithoutAchievementsNestedInput
    journey?: JourneyProgressUpdateOneWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    journeyId?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    journeyId?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoryVersionCreateManyStoryInput = {
    id?: string
    authorId?: string | null
    reviewerId?: string | null
    versionNumber: number
    status?: $Enums.StoryStatus
    changelog?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: string | null
    assetPath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    ownershipStatus?: $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StoryPlaySessionCreateManyStoryInput = {
    id?: string
    versionId?: string | null
    userId?: string | null
    sessionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
  }

  export type StoryNodeCreateManyStoryInput = {
    id?: string
    key: string
    title?: string | null
    synopsis?: string | null
    type?: $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryPathCreateManyStoryInput = {
    id?: string
    key: string
    label: string
    summary?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryTransitionCreateManyStoryInput = {
    id?: string
    fromNodeId: string
    pathId: string
    toNodeId?: string | null
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvatarProfileCreateManyStoryInput = {
    id: string
    name: string
    age?: number | null
    background?: string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: boolean
    experienceClicks?: number
    experienceStarts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryAuditLogCreateManyStoryInput = {
    id?: string
    actorId?: string | null
    action: string
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryInteractionCreateManyStoryInput = {
    id?: string
    avatarId: string
    sessionId?: string | null
    userId?: string | null
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryVersionUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featuredIn?: TwineStoryUpdateOneWithoutLatestVersionNestedInput
    author?: UserUpdateOneWithoutAuthoredVersionsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedVersionsNestedInput
    reviews?: StoryReviewUpdateManyWithoutVersionNestedInput
    playSessions?: StoryPlaySessionUpdateManyWithoutVersionNestedInput
  }

  export type StoryVersionUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featuredIn?: TwineStoryUncheckedUpdateOneWithoutLatestVersionNestedInput
    reviews?: StoryReviewUncheckedUpdateManyWithoutVersionNestedInput
    playSessions?: StoryPlaySessionUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type StoryVersionUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    changelog?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assetPath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipStatus?: EnumStoryOwnershipStatusFieldUpdateOperationsInput | $Enums.StoryOwnershipStatus
    consentSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StoryPlaySessionUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StoryVersionUpdateOneWithoutPlaySessionsNestedInput
    user?: UserUpdateOneWithoutStoryPlaysNestedInput
    session?: UserSessionUpdateOneWithoutStoryPlaysNestedInput
  }

  export type StoryPlaySessionUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoryPlaySessionUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoryNodeUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStoryNodeTypeFieldUpdateOperationsInput | $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outgoing?: StoryTransitionUpdateManyWithoutFromNodeNestedInput
    incoming?: StoryTransitionUpdateManyWithoutToNodeNestedInput
  }

  export type StoryNodeUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStoryNodeTypeFieldUpdateOperationsInput | $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outgoing?: StoryTransitionUncheckedUpdateManyWithoutFromNodeNestedInput
    incoming?: StoryTransitionUncheckedUpdateManyWithoutToNodeNestedInput
  }

  export type StoryNodeUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStoryNodeTypeFieldUpdateOperationsInput | $Enums.StoryNodeType
    content?: NullableJsonNullValueInput | InputJsonValue
    media?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryPathUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transitions?: StoryTransitionUpdateManyWithoutPathNestedInput
  }

  export type StoryPathUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transitions?: StoryTransitionUncheckedUpdateManyWithoutPathNestedInput
  }

  export type StoryPathUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryTransitionUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromNode?: StoryNodeUpdateOneRequiredWithoutOutgoingNestedInput
    toNode?: StoryNodeUpdateOneWithoutIncomingNestedInput
    path?: StoryPathUpdateOneRequiredWithoutTransitionsNestedInput
  }

  export type StoryTransitionUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    pathId?: StringFieldUpdateOperationsInput | string
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryTransitionUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    pathId?: StringFieldUpdateOperationsInput | string
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarProfileUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources?: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    experienceClicks?: IntFieldUpdateOperationsInput | number
    experienceStarts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: StoryInteractionUpdateManyWithoutAvatarNestedInput
  }

  export type AvatarProfileUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources?: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    experienceClicks?: IntFieldUpdateOperationsInput | number
    experienceStarts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: StoryInteractionUncheckedUpdateManyWithoutAvatarNestedInput
  }

  export type AvatarProfileUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    background?: NullableStringFieldUpdateOperationsInput | string | null
    appearance?: NullableJsonNullValueInput | InputJsonValue
    initialResources?: JsonNullValueInput | InputJsonValue
    socialContext?: NullableJsonNullValueInput | InputJsonValue
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    experienceClicks?: IntFieldUpdateOperationsInput | number
    experienceStarts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryAuditLogUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutStoryAuditLogsNestedInput
  }

  export type StoryAuditLogUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryAuditLogUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryInteractionUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: AvatarProfileUpdateOneRequiredWithoutInteractionsNestedInput
    session?: UserSessionUpdateOneWithoutStoryInteractionsNestedInput
    user?: UserUpdateOneWithoutStoryInteractionsNestedInput
  }

  export type StoryInteractionUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryInteractionUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryReviewCreateManyVersionInput = {
    id?: string
    reviewerId: string
    status: $Enums.StoryStatus
    feedback?: string | null
    createdAt?: Date | string
  }

  export type StoryPlaySessionCreateManyVersionInput = {
    id?: string
    storyId: string
    userId?: string | null
    sessionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    feedback?: string | null
  }

  export type StoryReviewUpdateWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type StoryReviewUncheckedUpdateWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryReviewUncheckedUpdateManyWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryPlaySessionUpdateWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    story?: TwineStoryUpdateOneRequiredWithoutPlaySessionsNestedInput
    user?: UserUpdateOneWithoutStoryPlaysNestedInput
    session?: UserSessionUpdateOneWithoutStoryPlaysNestedInput
  }

  export type StoryPlaySessionUncheckedUpdateWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoryPlaySessionUncheckedUpdateManyWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoryTransitionCreateManyFromNodeInput = {
    id?: string
    storyId: string
    pathId: string
    toNodeId?: string | null
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryTransitionCreateManyToNodeInput = {
    id?: string
    storyId: string
    fromNodeId: string
    pathId: string
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryTransitionUpdateWithoutFromNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneRequiredWithoutTransitionsNestedInput
    toNode?: StoryNodeUpdateOneWithoutIncomingNestedInput
    path?: StoryPathUpdateOneRequiredWithoutTransitionsNestedInput
  }

  export type StoryTransitionUncheckedUpdateWithoutFromNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    pathId?: StringFieldUpdateOperationsInput | string
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryTransitionUncheckedUpdateManyWithoutFromNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    pathId?: StringFieldUpdateOperationsInput | string
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryTransitionUpdateWithoutToNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneRequiredWithoutTransitionsNestedInput
    fromNode?: StoryNodeUpdateOneRequiredWithoutOutgoingNestedInput
    path?: StoryPathUpdateOneRequiredWithoutTransitionsNestedInput
  }

  export type StoryTransitionUncheckedUpdateWithoutToNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    pathId?: StringFieldUpdateOperationsInput | string
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryTransitionUncheckedUpdateManyWithoutToNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    pathId?: StringFieldUpdateOperationsInput | string
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryTransitionCreateManyPathInput = {
    id?: string
    storyId: string
    fromNodeId: string
    toNodeId?: string | null
    ordering?: number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryTransitionUpdateWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneRequiredWithoutTransitionsNestedInput
    fromNode?: StoryNodeUpdateOneRequiredWithoutOutgoingNestedInput
    toNode?: StoryNodeUpdateOneWithoutIncomingNestedInput
  }

  export type StoryTransitionUncheckedUpdateWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryTransitionUncheckedUpdateManyWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    fromNodeId?: StringFieldUpdateOperationsInput | string
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    ordering?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryInteractionCreateManyAvatarInput = {
    id?: string
    storyId?: string | null
    sessionId?: string | null
    userId?: string | null
    kind: $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StoryInteractionUpdateWithoutAvatarInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: TwineStoryUpdateOneWithoutInteractionsNestedInput
    session?: UserSessionUpdateOneWithoutStoryInteractionsNestedInput
    user?: UserUpdateOneWithoutStoryInteractionsNestedInput
  }

  export type StoryInteractionUncheckedUpdateWithoutAvatarInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryInteractionUncheckedUpdateManyWithoutAvatarInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumStoryInteractionKindFieldUpdateOperationsInput | $Enums.StoryInteractionKind
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}